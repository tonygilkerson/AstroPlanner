//------------------------------------------------------------------------------------class Pair	// Documented 7/3/2012	//- This is a convenience class that encapsulates a pair of variants. It is used by other	//- framework classes, but can be used by user scripts as well.	//- Instantiation: dim p as new Pair(l,r)		dim left as Variant	dim right as Variant		sub Constructor(l as Variant, r as Variant)		left=l		right=r	end sub	end class	//------------------------------------------------------------------------------------class Dictionary	// Documented 7/3/2012	//- Dictionary class - functionally equivalent to the REALbasic one, except:	//- a. No BinCount property (yet).	//- b. Value(key) will return nil if key not found, rather than triggering an exception.	//- c. Key(Index) will return nil if Index is out-of-bounds, rather than triggering an exception.	//- d. Remove(key) will not trigger an exception if key not found.	//- Instantiation:  dim d as new Dictionary		private dim hash(-1) as integer	private dim item(-1) as Pair		function Count() as integer		//- Return number of items stored in the dictionary		return ubound(item)+1	end function		sub Value(key as Variant, assigns v as Variant)		//- Assign an item by key to the dictionary		if key is nil then return		dim h as integer = key.Hash		dim i as integer = hash.IndexOf(h)		dim p as new Pair(key,v)		if i<0 then			hash.Append h			item.Append p		else			item(i) = p		end if	end sub		function Value(key as Variant) as Variant		//- Retrieve an item by key from the dictionary. Return nil if not found		if key is nil then return nil		dim i as integer = hash.IndexOf(key.Hash)		if i>=0 then return item(i).right else return nil	end function		sub Clear()		//- Clear all items from the dictionary.		redim hash(-1)		redim item(-1)	end sub		function HasKey(key as Variant) as boolean		//- Return TRUE if an item with the given key exists in the dictionary		return hash.IndexOf(key.Hash)>=0	end function		function Key(Index as integer) as Variant		//- Return the Index-th key from the dictionary. Index = 0, 1, ... Count-1		if Index>=0 and Index<=ubound(item) then return item(Index).Left	end function		function Keys() as Variant()		//- Return an array containing all the keys in the dictionary (in 1-to-1 correspondence with Values())		dim v(-1) as Variant		redim v(ubound(item))		for i as integer = 0 to ubound(item)			v(i)=item(i).left		next		return v	end function		function Values() as Variant()		//- Return an array containing all the values in the dictionary (in 1-to-1 correspondence with Keys())		dim v(-1) as Variant		redim v(ubound(item))		for i as integer = 0 to ubound(item)			v(i)=item(i).right		next		return v	end function		function Lookup(key as Variant, default as Variant) as Variant		//- If a value with the given key exists, return it, otherwise return default		if HasKey(key) then return Value(key) else return default	end function		sub Remove(key as Variant)		//- Remove the item with the given key from the dictionary		dim i as integer = hash.IndexOf(key.Hash)		if i>=0 then			hash.Remove i			item.Remove i		end if	end sub	end class//------------------------------------------------------------------------------------module StringUtilities	// Documented 7/3/2012	//- Various string extensions for convenience		Function Chop(extends s As String, charsToCut As Integer) As String		//- Return s with the rightmost 'charsToCut' chars removed.		Dim charsLeft As Integer = s.Len - charsToCut		if charsLeft <= 0 then return ""		return s.Left( s.Len - charsToCut )	End Function		Function Chop(extends s As String, stringToCut As String) As String		//- Chops 'stringToCut' off of s, if stringToCut is found at the end.		//- Useful for removing file extensions, trailing punctuation, etc.		Dim cutLen As Integer = stringToCut.Len		if Right(s, cutLen) = stringToCut then			return s.Left( s.Len - cutLen )		else			return s		end if	End Function		Function ChopB(extends s As String, bytesToCut As Integer) As String		//- Return s with the rightmost 'bytesToCut' bytes removed.		Dim bytesLeft As Integer = s.LenB - bytesToCut		if bytesLeft <= 0 then return ""		return s.LeftB( s.LenB - bytesToCut )	End Function		Function ChopB(extends s As String, stringToCut As String) As String		//- Chops 'stringToCut' off of s, if stringToCut is found at the end.		//- Useful for removing file extensions, trailing punctuation, etc.		Dim cutLenB As Integer = stringToCut.LenB		if StrComp( RightB(s, cutLenB), stringToCut, 0 ) = 0 then			return s.LeftB( s.LenB - cutLenB )		else			return s		end if	End Function		Function Contains(extends s As String, what As String) As Boolean		//- Return true if 's' contains the substring 'what'.		//- By "contains" we mean case-insensitive, encoding-savvy containment		//- as with InStr.		if what = "" then return true		return InStr( s, what ) > 0	End Function		Function ContainsB(extends s As String, what As String) As Boolean		//- Return true if 's' contains the substring 'what'.		//- By "contains" we mean binary containment		//- as with InStrB.		if what = "" then return true		return InStrB( s, what ) > 0	End Function		Function EndsWith(extends s As String, withWhat As String) As Boolean		//- Return true if 's' ends with the string 'withWhat',		//- doing a standard string comparison.		return Right(s, withWhat.Len) = withWhat	End Function		Function EndsWithB(extends s As String, withWhat As String) As Boolean		//- Return true if 's' ends with the string 'withWhat',		//- doing a binary comparison.		return StrComp( RightB(s, withWhat.LenB), withWhat, 0 ) = 0	End Function		Function JoinInt(source() As Integer, optional delimiter As String = " ") As string		//- Join an array of integers together with the given delimiter		Dim fields(-1) As String		redim fields(ubound(source))		for i as integer = 0 to ubound(source)			fields(i)=format(source(i),"-0")		next		return Join(fields,delimiter)	End Function		Function JoinQuoted(fields() as String, delimiter as String) As String		//- Join the given strings with a delimiter, just like the intrinsic Join		//- method, except that if any of the fields contains the delimiter,		//- that item will be surrounded by quotes in the output.  See		//- SplitQuoted for the inverse function.		Dim quoted() As String		Dim ub As Integer = UBound( fields )		Redim quoted( ub )		for i As Integer = 0 to ub			Dim fld As String = fields(i)			if Instr( fld, Delimiter ) > 0 then				quoted(i) = """" + fld + """"			else				quoted(i) = fld			end if		next		return Join( quoted, delimiter )	End Function		Function InStrQuoted(optional start As Integer = 1, source As String, find As String) As Integer	  //- This is the same as the built-in InStr function, except that it ignores	  //- any occurrence of "find" within double quotes.    	  do	    // Find the next occurrence of the search string.  If none, then we're done.	    Dim foundPos As Integer = InStr( start, source, find )	    if foundPos < 1 then return foundPos    	    // Now, also find the next quotation mark; if this comes before	    // our foundPos, then we need to ignore that and resume searching	    // after the closing quote.  Otherwise, we're done.	    Dim quotePos As Integer = InStr( start, source, """" )	    if quotePos = 0 or quotePos > foundPos then return foundPos    	    Dim closeQuotePos As Integer = InStr( quotePos+1, source, """" )	    if closeQuotePos = 0 then return 0 // no closing quote, treat whole end of string as quoted    	    start = closeQuotePos + 1	  loop  	End Function	Function SplitQuoted(source As String, delimiter As String, removeQuotes as Boolean) As String()		//- Same as Split, except that it respects quoted strings.				Dim out() As String				// Easy cases: no occurrences of the separator, or no quotation marks		if InStr( source, delimiter )=0 then			out = Array( source )		elseif InStr( source, """" )= 0 then			out = Split( source, delimiter )		else			// Harder case: both separator and quotation marks.			// We'll use InStrQuoted to help us out.			Dim delimiterLen As Integer = delimiter.Len			Dim startPos As Integer = 1			do				Dim delimiterPos As Integer = InStrQuoted( startPos, source, delimiter )				if delimiterPos = 0 then					// no more separators					out.Append Mid( source, startPos )					exit				end if				out.Append Mid( source, startPos, delimiterPos - startPos )				startPos = delimiterPos + delimiterLen			loop		end if				// Finally, strip quotes if asked to do so.		// (Including the case of a start quote without an end quote, which		// could happen in the last field.)		if removeQuotes then			for i As Integer = 0 to UBound( out )				Dim s As String = out(i)				if s.LeftB( 1 ) = """" then					if s.RightB( 1 ) = """" then						out(i) = MidB( s, 2, s.LenB - 2 )					else						out(i) = MidB( s, 2 )					end if				end if			next		end if				return out			End Function		Function SplitToInt(source As String, optional delimiter As String=" ") As Integer()		//- Split a string into fields, then convert each field into an Integer		//- using the Val function.				Dim fields(-1) As String		fields = source.Split(delimiter)				Dim out(-1) As Integer		Redim out( UBound(fields) )				Dim i As Integer		for i = UBound(fields) DownTo 0			out(i) = Val( fields(i) )		next				return out			End Function		Function StartsWith(extends s As String, withWhat As String) As Boolean		//- Return true if 's' starts with the string 'withWhat',		//- doing a standard string comparison.				return Left(s, withWhat.Len) = withWhat			End Function		Function StartsWithB(extends s As String, withWhat As String) As Boolean		//- Return true if 's' starts with the string 'withWhat',		//- doing a binary comparison.				return StrComp( LeftB(s, withWhat.Len), withWhat, 0 ) = 0			End Function	end module

module FieldConstants
  	const field_Bayer = 17
	//- DefineField fldID parameter value. Field is a Bayer ID (e.g. Alp Cen).	const field_Dec = 2
	//- DefineField fldID parameter value. Field is the object Declination (degrees).	const field_DecPM = 25
	//- DefineField fldID parameter value. Field is Declination Proper Motion (mas/yr).	const field_Flamsteed = 18
	//- DefineField fldID parameter value. Field is a Flamsteed ID (e.g. 47 Tuc).	const field_GCVS = 19
	//- DefineField fldID parameter value. Field is a GCVS ID (e.g. VX Ori).	const field_ID = 3
	//- DefineField fldID parameter value. Field is a generic ID.	const field_Inclination = 21
	//- DefineField fldID parameter value. Field is Inclination (degrees).	const field_Mag = 4
	//- DefineField fldID parameter value. Field is (primary) Magnitude (upper limit for variable stars).	const field_Mag2 = 16
	//- DefineField fldID parameter value. Field is (secondary) Magnitude (lower limit for variable stars).	const field_Name = 13
	//- DefineField fldID parameter value. Field is Name.	const field_Notes = 14
	//- DefineField fldID parameter value. Field is Notes/Description.	const field_Period = 23
	//- DefineField fldID parameter value. Field is Period.	const field_PosAngle = 20
	//- DefineField fldID parameter value. Field is Position Angle (0-359 degrees).	const field_RA = 1
	//- DefineField fldID parameter value. Field is Right Ascension (hours).	const field_RAPM = 24
	//- DefineField fldID parameter value. Field is Right Ascension Proper Motion (mas/yr).	const field_Rating = 22
	//- DefineField fldID parameter value. Field is Rating.	const field_Sep = 9
	//- DefineField fldID parameter value. Field is Separation (arcsec).	const field_Size = 10
	//- DefineField fldID parameter value. Field is Size (primary axis) (arcmin).	const field_Size2 = 11
	//- DefineField fldID parameter value. Field is Size (secondary axis) (arcmin).
	const field_Spect = 15
	//- DefineField fldID parameter value. Field is Spectral Info.
	const field_Type = 6
	//- DefineField fldID parameter value. Field is Type (primary).
	const field_Type2 = 7
	//- DefineField fldID parameter value. Field is Type (secondary).
	const field_Type3 = 8
	//- DefineField fldID parameter value. Field is Type (tertiary).

	const order_None = 0
	//- DefineField fldOrder parameter value. No ordering.
	const order_Sort = 1
	//- DefineField fldOrder parameter value. Sort the field into ascending order.
	const order_Presorted = 2
	//- DefineField fldOrder parameter value. Field is pre-sorted in ascending order.
	const order_Index = 3
	//- DefineField fldOrder parameter value. Field will have an index.

	const format_String = 0
	//- DefineField fldFormat parameter value. Field is a string.
	const format_Int8 = 1
	//- DefineField fldFormat parameter value. Field is a 8-bit integer.
	const format_Int16 = 2
	//- DefineField fldFormat parameter value. Field is a 16-bit integer.
	const format_Int32 = 3
	//- DefineField fldFormat parameter value. Field is a 32-bit integer.
	const format_Double = 10
	//- DefineField fldFormat parameter value. Field is a floating-point double (64-bit).
	const format_Single = 11
	//- DefineField fldFormat parameter value. Field is a floating-point single (32-bit).
	const format_DDMMSS = 4
	//- DefineField fldFormat parameter value. Field is a floating-point double (64-bit) in degrees formatted as +DDMMSS.S.
	const format_DDMMSS_Space = 5
	//- DefineField fldFormat parameter value. Field is a floating-point double (64-bit) in degrees formatted as +DD MM SS.S.
	const format_DDMMSS_Colon = 6
	//- DefineField fldFormat parameter value. Field is a floating-point double (64-bit) in degrees formatted as +DD:MM:SS.S.
	const format_HHMMSS = 7
	//- DefineField fldFormat parameter value. Field is a floating-point double (64-bit) in hours formatted as +HHMMSS.S.
	const format_HHMMSS_Space = 8
	//- DefineField fldFormat parameter value. Field is a floating-point double (64-bit) in hours formatted as +HH MM SS.S.
	const format_HHMMSS_Colon = 9
	//- DefineField fldFormat parameter value. Field is a floating-point double (64-bit) in hours formatted as +HH:MM:SS.S.
	const format_Magnitude = 12
	//- DefineField fldFormat parameter value. Field is a magnitude.
	const format_Size = 13
	//- DefineField fldFormat parameter value. Field is a numeric size in arcmin.
	const format_Size1 = 14
	//- DefineField fldFormat parameter value. Field is the first dimension A of a size field (A x B).
	const format_Size2 = 15
	//- DefineField fldFormat parameter value. Field is the second dimension B of a size field (A x B).

	const type_Star = 1	const type_Double = 2	const type_Triple = 3	const type_Multiple = 4	const type_Open = 5	const type_Globular = 6	const type_Asterism = 7	const type_StarCloud = 8	const type_Variable = 9		const type_Pulsar = 10	const type_XrayBinary = 11	const type_RadioSource = 12	const type_Quasar = 13	const type_BLLac = 14	const type_WhiteDwarf = 15	const type_CataclysmicBinary = 16	const type_RedDwarf = 17	const type_HerbigHaro = 18	const type_Supernova = 19	const type_SNR = 20	const type_PlanetaryNeb = 21	const type_DiffuseNeb = 22	const type_EmissionNeb = 23	const type_Nebula = 24	const type_Knot = 25	const type_Nebulosity = 26	const type_ReflectionNeb = 27	const type_BrightNeb = 28	const type_DarkNeb = 29	const type_Galaxy = 30	const type_InteractingGal = 31	const type_LMC = 32	const type_SMC = 33	const type_SpiralGal = 34	const type_EllipticalGal = 35	const type_IrregularGal = 36	const type_ActiveGal = 37	const type_SeyfertGal = 38	const type_BarredSpiralGal = 39		const type_GalaxyCluster = 40	const type_WolfRayetStar = 50	const type_HIIRegion = 51  	const type_IRSource = 52  	const type_UVSource = 53  	const type_BeStar = 54  	const type_EclipsingBinary = 55  	const type_SpectroscopicBinary = 56  	const type_CepheidVariable = 57  	const type_MolecularCloud = 58  	const type_RedObject = 59    	const type_BlueObject = 60  	const type_GammaRaySource = 61  	const type_GravitationalLens = 62  	const type_TTauStar = 63  	const type_CarbonStar = 64  	const type_BrownDwarf = 65  	const type_Region = 66  	const type_CometaryGlobule = 67  	const type_Exoplanet = 68  	const type_Blazar = 69	const type_NonExist = 90	const type_PlateDefect = 91	const type_USO = 92
  
end module