// Script prefix file

//------------------------------------------------------------------------------------
module VariantStuff
	// Documented 7/9/2012
	//- Constants used to determine the contents of a Variant
	const vtype_Array = 4096
	const vtype_Boolean = 11
	const vtype_Color = 16
	const vtype_CString = 18
	const vtype_Double = 5
	const vtype_Integer = 2
	const vtype_Long = 3
	const vtype_Nil = 0
	const vtype_Object = 9
	const vtype_PString = 20
	const vtype_Single = 4
	const vtype_String = 8
	const vtype_Structure = 36
end module

//------------------------------------------------------------------------------------
interface NamedObject
// Documented 7/9/2012
	//- Used by the Dialog.SetXXXXParameters methods to display arrays of objects that implement this interface,
	//- i.e. objects that have associated names.
	//- By implementing this interface in your own classes you can display lists of your own objects.
	function ObjectName() as string
		//- Return a displayable name for the object
	//# end function
end interface

//------------------------------------------------------------------------------------
interface RADecObject
// Documented 7/9/2012
	//- Used by (for example) AngleBetween to compute distance between objects that implement this interface,
	//- i.e. objects that have associated fixed RA and Dec coordinates.
	function RA() as double
		//- Return the Right Ascension for the object
	//# end function
	function Dec() as double
		//- Return the Declination for the object
	//# end function
end interface

//------------------------------------------------------------------------------------
module MultiFieldObjectConstants
	// Documented 7/9/2012
	//- Used as return values by the ColumnType method of classes implementing the MultiFieldObject interface
	const mfo_String = 0
	//- Column contains string values
	const mfo_Number = 1
	//- Column contains numeric values
	const mfo_Time = 2
	//- Column contains time or RA values
	const mfo_Angle = 3
	//- Column contains angular or Dec values
	const mfo_ID = 4
	//- Column contains ID values (e.g. NGC2345, M62, 3C121, etc.)
end module

//------------------------------------------------------------------------------------
interface MultiFieldObject
  // Documented 7/9/2012
  //- Used by Dialog.CheckListParameter to create a multi-column check list
  
  function nColumns() as integer
  //- Return the number of columns to be displayed
  //# end function
  function ColumnName(idx as integer) as string
  //- Return the column name for the idx-th column (idx = 1 ... nColumns)
  //# end function
  function ColumnValue(idx as integer) as string
  //- Return the column value for the idx-th column (idx = 1 ... nColumns)
  //# end function
  function ColumnType(idx as integer) as integer
  //- Return the column type for the idx-th column (idx = 1 ... nColumns)
  //-  Used to allow correct sorting when the column headers are clicked.
  //-  Return mfo_ constant values, as defined in the MultiFieldObjectConstants module:
  //-  mfo_String = 0 (String)
  //-  mfo_Number = 1 (Number)
  //-  mfo_Time = 2   (RA/Time)
  //-  mfo_Angle = 3  (Dec/Angle)
  //-  mfo_ID = 4     (ID)
  //# end function
end interface

//------------------------------------------------------------------------------------
class Rect
	// Documented 7/9/2012
	//- Implements a rectangle with integer coordinates
	
	dim left as integer
	//- X-coordinate of the left edge of the rectangle.
	dim top as integer
	//- Y-coordinate of the top edge of the rectangle.
	dim width as integer
	//- Width of the rectangle (in X direction).
	dim height as integer
	//- Height of the rectangle (in Y direction).
	
	sub Constructor()
		//- Construct a Rect with all zero properties
	end sub
	
	sub Constructor(left as integer, top as integer, width as integer, height as integer)
		//- Construct a Rect with give coordinates and size
		me.left = left
		me.top = top
		me.width = width
		me.height = height
	end sub
	
	sub Constructor(r as Rect)
		//- Copy constructor (construct a new Rect based on an existing one)
		me.left = r.left
		me.top = r.top
		me.width = r.width
		me.height = r.height
	end sub
	
	function right() as integer
		//- X-coordinate of the right edge of the rectangle. Note: setting this will change the width to (right - left).
		return left+width
	end function
	
	sub right(assigns r as integer)
		width = r - left
	end sub
	
	function bottom() as integer
		//- Y-coordinate of the bottom edge of the rectangle. Note: setting this will change the height to (bottom - top).
		return top+height
	end function
	
	sub bottom(assigns b as integer)
		height = b - top
	end sub
	
	function Contains(x as integer, y as integer) as boolean
		
		//- Returns TRUE if the point (x,y) is contained in or on the rectangle
		return x>=left and x<=right and y>=top and y<=bottom
	end function	
end class

//------------------------------------------------------------------------------------
class APUserField
	// Documented 7/9/2012
	//- Encapsulates the concept of a user-defined field, and is used by other classes that
	//- have user-defined fields (e.g. APObservation, APPlanObject, APResource, etc.)
	//- Note: Do not construct new instances of this class.
	//- Use the methods of the relevant containing class to retrieve
	//- instances (e.g. APPlanObject.UserField(n))
	implements NamedObject
	
	private dim nPlan as integer
	private dim nItem as integer
	private dim nSubItem as integer
	private dim nItemType as integer
	private dim nUserField as integer

	const uftype_String = 0
	const uftype_Integer = 1
	const uftype_Double = 2
	const uftype_File = 3
	const uftype_Boolean = 4
	const uftype_URL = 5
	const uftype_Script = 6
	const uftype_Folder = 7
	const uftype_Choice = 8
	
	const ufstyle_Plain = 0
	const ufstyle_Bold = 1
	const ufstyle_Italic = 2
	const ufstyle_Underlined = 4

	const ufvar_Title = 1  // private
	const ufvar_Type = 2  // private
	const ufvar_From = 3  // private
	const ufvar_To = 4  // private
	const ufvar_Units = 5  // private
	const ufvar_Value = 6  // private
	const ufvar_HasValue = 7  // private
	const ufvar_HasDefinition = 8  // private
	const ufvar_nFields = 9  // private
	const ufvar_DecPts = 10 // private
	const ufvar_ScriptName = 11 // private
	const ufvar_ScriptParameter = 12 // private
	const ufvar_HasTextColor = 13 // private
	const ufvar_TextColor = 14 // private
	const ufvar_HasBackgroundColor = 15 // private
	const ufvar_BackgroundColor = 16 // private
	const ufvar_IsBold = 17 // private
	const ufvar_IsItalic = 18 // private
	const ufvar_IsUnderlined = 19 // private

	const ufnit_Object = 1  // private
	const ufnit_Observation = 2  // private
	const ufnit_Session = 3  // private
	const ufnit_ObsAttachment = 4  // private
	const ufnit_Resource = 100  // Add resource type number to this  // private

  private sub Constructor()
  	// Do not allow creation of instances of this object.
  end sub
  
	sub Constructor(np as integer, ni as integer, nsi as integer, nit as integer, nuf as integer) // private
		nPlan=np
		nItem=ni
		nSubItem=nsi
		nItemType=nit
		nUserField=nuf
	end sub

	function ObjectName() as string // private
		return Title
	end function

	function Title() as string
		//- The user-field title.
		return APC_UF_GetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Title)
	end function

	sub Title(assigns s as string)
		call APC_UF_SetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Title,s)
		if nItemType<ufnit_Resource then Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Type() as integer
		//- The user-field type. Refer to uftype_ constants for available types.
		return APC_UF_GetIntegerVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Type)
	end function

	sub Type(assigns n as integer)
		call APC_UF_SetIntegerVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Type,n)
	end sub

	function RangeFrom() as double
		//- For numeric user-fields, this is the minimum allowable value.
		return APC_UF_GetDoubleVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_From)
	end function

	sub RangeFrom(assigns d as double)
		call APC_UF_SetDoubleVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_From,d)
	end sub

	function RangeTo() as double
		//- For numeric user-fields, this is the maximum allowable value.
		return APC_UF_GetDoubleVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_To)
	end function

	sub RangeTo(assigns d as double)
		call APC_UF_SetDoubleVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_To,d)
	end sub

	function Units() as string
		//- The user-field value units, where applicable (e.g. "mm", "hours", etc.)
		return APC_UF_GetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Units)
	end function

	sub Units(assigns s as string)
		call APC_UF_SetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Units,s)
	end sub

	function Decimals() as integer
		//- For Type = uftype_Double, this specifies the number of decimal places to be displayed.
		return APC_UF_GetIntegerVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_DecPts)
	end function

	sub Decimals(assigns n as integer)
		call APC_UF_SetIntegerVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_DecPts,n)
	end sub

	function ScriptName() as string
		//- Name of the script to execute, if Type = uftype_Script.
		return APC_UF_GetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_ScriptName)
	end function

	sub ScriptName(assigns s as string)
		call APC_UF_SetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_ScriptName,s)
	end sub

	function Parameter() as string
		//- Parameter to be passed to the executing script, if Type = uftype_Script. 
		//- Available as the shared property APUserField.ScriptParameter from within that script.
		return APC_UF_GetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_ScriptParameter)
	end function

	sub Parameter(assigns s as string)
		call APC_UF_SetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_ScriptParameter,s)
	end sub

	function Value() as Variant
		//- The value of the user-field. Can be integer, double, boolean or string.
		select case APC_UF_GetVariableType(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value)
		case 2,3  // Integer
			 return APC_UF_GetIntegerVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value)
		case 4,5  // Double
			 return APC_UF_GetDoubleVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value)
		case 11   // Boolean
			 return APC_UF_GetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value)
		case 8    // String
			 return APC_UF_GetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value)
		end select

		return nil
	end function

	sub Value(assigns v as Variant)
		select case v.Type
		case vtype_Integer, vtype_Long  // Integer
			 call APC_UF_SetIntegerVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value,v)
		case vtype_Single, vType_Double  // Double
			 call APC_UF_SetDoubleVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value,v)
		case vtype_Boolean   // Boolean
			 call APC_UF_SetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value,v)
		case vtype_String    // String
			 call APC_UF_SetStringVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_Value,v)
		end select
		
		if nItemType<ufnit_Resource then Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function HasDefinition() as boolean
		//- True if the user-field value has a corresponding definition (otherwise it will be a plain string user-field).
		if nItem<0 then return true else return APC_UF_GetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_HasDefinition)
	end function

	function HasValue() as boolean
		//- True if the user-field has had a value assigned to it after being defined.
		if nItem<0 then return false else return APC_UF_GetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_HasValue)
	end function
	
	function HasTextColor() as boolean
		//- TRUE if user field is displayed with a custom (i.e. non-black) text colour, FALSE otherwise
		if nItem<0 then return false else return APC_UF_GetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_HasTextColor)
	end function
	
	sub HasTextColor(assigns b as boolean)
		call APC_UF_SetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_HasTextColor,b)
	end sub
	
	function IsBold() as boolean
		//- True if the user-field text is being displayed in bold face.
		if nItem<0 then return false else return APC_UF_GetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_IsBold)
	end function

	sub IsBold(assigns b as boolean)
		call APC_UF_SetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_IsBold,b)
	end sub

	function IsItalic() as boolean
		//- True if the user-field text is being displayed in italic face.
		if nItem<0 then return false else return APC_UF_GetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_IsItalic)
	end function

	sub IsItalic(assigns b as boolean)
		call APC_UF_SetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_IsItalic,b)
	end sub

	function IsUnderlined() as boolean
		//- True if the user-field text is being displayed with underlining.
		if nItem<0 then return false else return APC_UF_GetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_IsUnderlined)
	end function

	sub IsUnderlined(assigns b as boolean)
		call APC_UF_SetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_IsUnderlined,b)
	end sub

	function TextColor() as Color
		//- User field custom text colour. Setting this to any colour other than black (&c000000) will also
		//- set HasTextColor to TRUE
		if nItem<0 then return &c000000 else return APC_UF_GetColorVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_TextColor)
	end function
	
	sub TextColor(assigns c as Color)
		HasTextColor=c<>&c000000
		call APC_UF_SetColorVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_TextColor,c)
	end sub

	function HasBackgroundColor() as boolean
		//- TRUE if user field is displayed with a custom (i.e. non-white) background colour, FALSE otherwise
		if nItem<0 then return false else return APC_UF_GetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_HasBackgroundColor)
	end function
	
	sub HasBackgroundColor(assigns b as boolean)
		call APC_UF_SetBooleanVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_HasBackgroundColor,b)
	end sub

	function BackgroundColor() as Color
		//- User field custom background colour. Setting this to any colour other than white (&cFFFFFF) will also
		//- set HasBackgroundColor to TRUE
		if nItem<0 then return &cFFFFFF else return APC_UF_GetColorVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_BackgroundColor)
	end function
	
	sub BackgroundColor(assigns c as Color)
		HasBackgroundColor=c<>&cFFFFFF
		call APC_UF_SetColorVariable(nPlan,nItem,nSubItem,nItemType,nUserField,ufvar_BackgroundColor,c)
	end sub

// Shared methods

	shared function nDefinedUserFields(np as integer, nit as integer) as integer // private
		// Defined user fields for type
		return APC_UF_nDefined(np,nit)
	end function

	shared function nUserFields(np as integer, ni as integer, nsi as integer, nit as integer) as integer // private
		// User fields for item
		return APC_UF_GetIntegerVariable(np,ni,nsi,nit,1,ufvar_nFields)
	end function

	shared function DefinedUserField(np as integer, nit as integer, nuf as integer) as APUserField // private
		return new APUserField(np,-1,-1,nit,nuf)
	end function

	shared function DefinedUserField(np as integer, nit as integer, title as string) as APUserField // private
		dim uf as APUserField
		dim n as integer = APC_UF_nDefined(np,nit)
		for i as integer=1 to n
			uf=new APUserField(np,-1,-1,nit,i)
			if uf.Title=title then return uf
		next
		return nil
	end function

	shared function UserField(np as integer, ni as integer, nsi as integer, nit as integer, nuf as integer) as APUserField // private
		if nuf<1 or nuf>nUserFields(np,ni,nsi,nit) then
			return nil
		else
			return new APUserField(np,ni,nsi,nit,nuf)
		end if
	end function

	shared function UserField(np as integer, ni as integer, nsi as integer, nit as integer, title as string, createIfMissing as boolean) as APUserField // private
		dim uf as APUserField
		dim n as integer = APC_UF_GetIntegerVariable(np,ni,nsi,nit,1,ufvar_nFields)
		for i as integer=1 to n
			uf=new APUserField(np,ni,nsi,nit,i)
			if uf.Title=title then return uf
		next
		if createIfMissing then uf=AddField(np,ni,nsi,nit,title) else uf=nil
		return uf
	end function

	shared function AddField(np as integer, ni as integer, nsi as integer, nit as integer, title as string) as APUserField // private
		dim n as integer=APC_UF_AddField(np,ni,nsi,nit,title)
		return new APUserField(np,ni,nsi,nit,n)
	end function

	shared function DeleteField(np as integer, ni as integer, nsi as integer, nit as integer, title as string) as boolean // private
		return APC_UF_DeleteField(np,ni,nsi,nit,title)
	end function

  shared function NewUserFieldDefinition(np as integer, nit as integer, title as string, ufType as integer, rangeFrom as double, rangeTo as double, units as string, decimals as integer, scriptName as string, parameter as string, bold as boolean, italic as boolean, underline as boolean) as boolean // private
  	return APC_UF_NewUserFieldDefinition(np,nit,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,parameter,bold,italic,underline)
  end function
  
  shared function NewUserFieldDefinition(np as integer, nit as integer, uf as APUserField) as boolean // private
  	return APC_UF_NewUserFieldDefinition(np,nit,uf.Title,uf.Type,uf.RangeFrom,uf.RangeTo,uf.Units,uf.Decimals,uf.ScriptName,uf.Parameter,uf.IsBold,uf.IsItalic,uf.IsUnderlined)
  end function
  
  shared function DeleteUserFieldDefinition(np as integer, nit as integer, title as string, deleteValues as boolean) as boolean // private
  	return APC_UF_DeleteUserFieldDefinition(np,nit,title,deleteValues)
  end function
  
  shared sub ScriptValue(assigns v as string)
  	//- After a User Field script runs, you must deposit the result into this variable. It will be
  	//- displayed as the value of the user field. The style used will be that defined for the user
  	//- field.
  	APC_SetUFValue(v)
  	APC_SetUFStyle(-1)
  end sub
  
  shared sub ScriptValue(style as integer, assigns v as string)
  	//- After a User Field script runs, you must deposit the result into the ScriptValue variable. It will be
  	//- displayed as the value of the user field. This method deposits the value and changes the default display
  	//- style (style can be any combination of the ufstyle_ constants, e.g. ufstyle_Bold+ufstyle_Underlined).
  	APC_SetUFValue(v)
  	APC_SetUFStyle(style)
  end sub
  
  shared function ScriptParameter() as string
  	//- When running a User Field script, this value will be the Input parameter specified for
  	//- the invoking user field. You can specify different values to enable a single script to
  	//- perform different tasks for different user fields.
  	return APC_GetUFParameter()
  end function
  
  shared function ScriptTarget() as Variant
  	//- When running a User Field script, this value will be the target of the user field. e.g. an APPlanObject if
  	//- the user field is associated with a plan object, an APObservation if associated with an observation, etc.
  	//- Nil is returned if the target cannot be determined, or is not a type supported by the scripting framework.
  	dim ttype,idx as integer
  	
  	if not APC_GetTarget(ttype,idx) then return nil
  	 
  	select case ttype
  	case 1 // APPlanObject
  		return new APPlanObject(-1,idx)
  	case 2 // APSession
  		return new APSession(idx)
  	case 3 // APObservation
  		return new APObservation(idx)
  	case 100+APResource.rsrc_Site
  		return new SiteResource(idx,true)
  	case 100+APResource.rsrc_Telescope
  		return new TelescopeResource(idx,true)
  	case 100+APResource.rsrc_Eyepiece
  		return new EyepieceResource(idx,true)
  	case 100+APResource.rsrc_OpticalAid
  		return new OpticalAidResource(idx,true)
  	case 100+APResource.rsrc_Filter
  		return new FilterResource(idx,true)
  	case 100+APResource.rsrc_Observer
  		return new ObserverResource(idx,true)
  	case 100+APResource.rsrc_Imager
  		return new ImagerResource(idx,true)
  	else
  		return nil
  	end select
  end function

end class

//------------------------------------------------------------------------------------
class APPlan	
	// Documented 7/9/2012
	//- Encapsulates a plan document.
	//- Note: Do not construct new instances of this object.
	//- Use the methods from the framework to retrieve
	//- instances (e.g. Plan(n))
	implements NamedObject

	private dim nPlan as integer
	private dim apc_Highlighted(-1) as APPlanObject

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer) // private
		nPlan=n
	end sub
	
	function Left() as integer
		//- Get/Set the left coordinate of the plan window on the screen.
		//- Coordinates with respect to the top-left of the main screen.
		dim l,t,w,h as integer
		APC_GetPlanPosition(nplan,l,t,w,h)
		return l
	end function
	
	sub Left(assigns n as integer)
		APC_SetPlanPosition(nplan,n,-1,-1,-1)
	end sub
	
	function Top() as integer
		//- Get/Set the top coordinate of the plan window on the screen.
		//- Coordinates with respect to the top-left of the main screen.
		dim l,t,w,h as integer
		APC_GetPlanPosition(nplan,l,t,w,h)
		return t
	end function
	
	sub Top(assigns n as integer)
		APC_SetPlanPosition(nplan,-1,n,-1,-1)
	end sub
	
	function Width() as integer
		//- Get/Set the width of the plan window.
		dim l,t,w,h as integer
		APC_GetPlanPosition(nplan,l,t,w,h)
		return w
	end function
	
	sub Width(assigns n as integer)
		APC_SetPlanPosition(nplan,-1,-1,n,-1)
	end sub
	
	function Height() as integer
		//- Get/Set the height of the plan window.
		dim l,t,w,h as integer
		APC_GetPlanPosition(nplan,l,t,w,h)
		return h
	end function
	
	sub Height(assigns n as integer)
		APC_SetPlanPosition(nplan,-1,-1,-1,n)
	end sub
	
	function Number() as integer
		//- Return the plan number/index
		return APPlan.PlanNumber(me)
	end function

	function Name() as string
		//- Plan document name.
		return APC_GetPlanName(nPlan)
	end function
	
	function ObjectName() as string // private
		return Name
	end function

	function Description() as string
		//- Plan document description.
		return APC_GetPlanDescription(nPlan)
	end function

	sub Description(assigns s as string)
		APC_SetPlanDescription(nPlan,s)
	end sub

	function Creator() as string
		//- Plan document creator name.
		return APC_GetPlanCreator(nPlan)
	end function

	sub Creator(assigns s as string)
	end sub

	function LocalDateTime() as double
		//- Get/set the local date/time of the plan document. 
		//- Setting the value will also fix the date/time (until RealTime is called, or FixedDate is set to false).
		return APC_PlanLocalDateTime(nPlan)
	end function

	sub LocalDateTime(assigns t as double)
		APC_PlanLocalDateTime(nPlan,t)
	end sub

	sub RealTime()
		//- Set the local date time to real time, by (effectively) switching off Fix Date. 
		//- Same as setting FixedDate = false.
		APC_PlanLocalDateTime(nPlan,0.0)
	end sub

	sub FixedDate(assigns b as boolean)
		//- True if the date/time is fixed, false if it is real time.
		if b then APC_PlanLocalDateTime(nPlan,APC_PlanLocalDateTime(nPlan)) else APC_PlanLocalDateTime(nPlan,0.0)
	end sub

	function FixedDate() as boolean
		return APC_GetFixedDate(nPlan)
	end function

	function GMT() as double
		//- Current GMT (Greenwich Mean Time).
		return APC_PlanGMT(nPlan)
	end function

	function GMST() as double
		//- Current Greenwich Mean Sidereal Time (the sidereal time at 0° longitude).
		return APC_PlanGMST(nPlan)
	end function

	function LST() as double
		//- Current Local Sidereal Time at the currently selected site.
		return APC_PlanLST(nPlan)
	end function

	function JulianDate() as double
		//- Current Julian date.
		return APC_PlanJulianDate(nPlan)
	end function

	function HeliocentricJulianDate(ra as double, dec as double) as double
		//- Current Heliocentric Julian Date for the given coordinates.
		return APC_PlanHeliocentricJulianDate(nPlan,ra,dec)
	end function

	function Changed() as boolean
		//- True if changes have been made to the plan document since it was last saved.
		return APC_PlanChanged(nPlan)
	end function

	sub Save()
		//- Save the contents of the plan document.
		APC_SavePlan(nPlan)
	end sub

	sub Close(optional silent as boolean = false)
		//- Close the plan document. If silent is true then the user will not be prompted to save any changes (i.e. they will be saved without asking).
		APC_ClosePlan(nPlan,silent)
		APM_CreatePlanList
	end sub

	sub Choose()
		//- Select this plan document and make it the default plan.
		APC_SelectPlan(nPlan)
		APM_CreatePlanList
	end sub

	function nObjects() as integer
		//- Total number of objects in the plan document.
		return APC_nObjects(nPlan)
	end function

	function nObj() as integer
		//- Total number of objects in the plan document.
		return APC_nObjects(nPlan)
	end function

	function nItems() as integer
		//- Total number of objects in the plan document.
		return APC_nObjects(nPlan)
	end function

	function Obj(n as integer) as APPlanObject
		//- Return the n-th object in the plan document object list, n = 1, ..., nObjects.
		return new APPlanObject(nPlan,n)
	end function

	function Item(n as integer) as APPlanObject
		//- Return the n-th object in the plan document object list, n = 1, ..., nObjects.
		return new APPlanObject(nPlan,n)
	end function
	
	sub APC_Plan_ResetHighlighted() // private
		redim apc_Highlighted(-1)
	end sub

	function nHighlighted() as integer
		//- Number of highlighted objects in the plan document.
		dim i as integer

		APC_Plan_ResetHighlighted

		for i=1 to nObjects
			if Obj(i).IsHighlighted then
				apc_Highlighted.Append Obj(i)
			end if
		next
		return ubound(apc_Highlighted)+1
	end function

	function HighlightedObject(n as integer) as APPlanObject
		//- Return the n-th highlighted object in the plan document object list, n = 1, ..., nHighlighted.
		dim i as integer
		dim m as integer

		if ubound(apc_Highlighted)<0 then call nHighlighted

		if n<=0 or n>ubound(apc_Highlighted)+1 then return nil
	
		return apc_Highlighted(n-1)
	end function

	function HighlightedObjects( ) as APPlanObject()
		//- Return an array containing all highlighted plan objects.
		dim i as integer, ob(-1) as APPlanObject
		redim ob(nHighlighted-1)
		for i=1 to nHighlighted
			 ob(i-1)=me.HighlightedObject(i)
		next
		return ob
	end function

	function TelescopeConnected() as boolean
		//- Returns true if a telescope is currently connected in the plan document. 
		//- Setting this property will connect or disconnect the telescope where appropriate.
		return APC_IsOnline(nPlan)
	end function

	sub TelescopeConnected(assigns b as boolean)
		APC_Online(nPlan,b)
	end sub

	function CurrentRA() as double
		//- Current telescope pointing coordinates, if connected.
		return APC_CurrentRA(nPlan)
	end function

	function CurrentDec() as double
		//- Current telescope pointing coordinates, if connected.
		return APC_CurrentDec(nPlan)
	end function
	
	function Objects() as APPlanObject()
		//- Return an array containing all plan objects.
		dim objects(-1) as APPlanObject
		dim i as integer

		for i=1 to me.nObjects
			objects.Append me.Obj(i)
		next
		return objects
	end function

	function NewObject(optional copyOf as APPlanObject = nil) as APPlanObject
		//- Create a new object in the plan. If the copyOf parameter is specified, and is not nil,
		//- then a copy of that object's fields will be made.
		dim n as integer
		if copyOf=nil then
			n=APC_NewObject(nPlan,-1,-1)
		else
			n=APC_NewObject(nPlan,copyOf.Plan.nPlan,copyOf.ObjNumber)
		end if
		if n>0 then return new APPlanObject(nPlan,n) else return nil
	end function

	function FindObject(ParamArray s as string) as APPlanObject
		//- Search the object list for the first object that contains any of the strings in the parameter list. 
		//- A match occurs if an object contains the string in its ID, Name or Notes fields.
		dim n as integer
		n=APC_FindObject(nPlan,s)+1
		if n>0 then return new APPlanObject(nPlan,n) else return nil
	end function

	function FindObjects(ParamArray s as string) as APPlanObject()
		//- Search the object list for all objects that contain any of the strings in the parameter list, and return the objects in an array. 
		//- A match occurs if an object contains the string in its ID, Name or Notes fields.
		dim i as integer
		dim n(-1) as integer
		dim p(-1) as APPlanObject

		n=APC_FindObjects(nPlan,s)
		redim p(ubound(n))
		for i=0 to ubound(n)
			p(i)=new APPlanObject(nPlan,n(i)+1)
		next
		return p
	end function

  function nSelectedObjects() as integer
  	//- Returns number of selected objects in the plan.
  	return APC_SelectedObjects(nPlan).Ubound+1
  end function
  	
	function SelectedObjectIndex() as integer
		//- Returns the index of the selected object in the plan document object list.
		//- Note: If more than one object is selected, the index of the first one will be returned.
		//- -1 returned if no objects selected.
		//- Use APPlan.SelectedObjectIndices to get all selected object indices.
		dim s() as integer
		s=APC_SelectedObjects(nPlan)
		if ubound(s)<0 then return -1 else return s(0)
	end function

	function SelectedObjectIndices() as integer()
		//- Returns an array of indices of the selected objects in the plan document object list.
		//- Note: Returns empty array if no objects selected.
		return APC_SelectedObjects(nPlan)
	end function

	function SelectedObject() as APPlanObject
		//- Returns the selected object in the plan document object list.
		//- Note: If more than one object is selected, the first one will be returned.
		//- Nil returned if no objects selected.
		//- Use APPlan.SelectedObjects to get all selected objects.
		dim i as integer
		i = SelectedObjectIndex
		if i<0 then return nil else return Obj(i)
	end function

	sub SelectObject(ob as APPlanObject)
		//- Select the specified object in the plan document's object list.
		//- If ob is nil, then deselect all objects.
		if ob<>nil then 
			APC_SelectObject(nPlan,ob.ID,true)
		else
			APC_SelectObject(nPlan,"",false)
		end if
	end sub

	function SelectedObjects() as APPlanObject()
		//- Returns an array of the selected objects in the plan document object list.
		//- Note: Returns empty array if no objects selected.
		dim idx() as integer = SelectedObjectIndices
		dim objs(-1) as APPlanObject
		redim objs(ubound(idx))
		for i as integer = 0 to ubound(idx)
			objs(i)=Obj(idx(i))
		next
		return objs
	end function
	
	function SelectedObservation() as APObservation
		//- Returns the observation currently selected in the Observations tab of the plan document.
		//- Returns nil if nothing is selected
		dim n as integer = APC_SelectedObservation(nPlan)
		if n>=0 then
			return new APObservation(n)
		else
			return nil
		end if
	end function

	function SelectedSession() as APSession
		//- Returns the session associated with the observation currently selected in the Observations tab of the plan document.
		//- Returns nil if nothing is selected
		dim n as integer = APC_SelectedSession(nPlan)
		if n>=0 then
			return new APSession(n)
		else
			return nil
		end if
	end function

	function GetExternalCoords(byref ra as double, byref dec as double) as boolean
		//- If an external application has been defined (e.g. Sky Charts, Equinox, etc.) and is active, then request the external application's current pointing coordinates (ra and dec). 
		//- Return true if the coordinates were obtainable, false otherwise.
		return APC_GetExternalCoords(nPlan,ra,dec)
	end function

	function SetExternalCoords(ra as double, dec as double, optional fov as double = -1.0) as boolean
		//- If an external application has been defined (e.g. Sky Charts, Equinox, etc.) and is active, then request that the external application's current pointing coordinates  be changed to ra and dec. 
		//- Optionally specify the field of view desired in degrees. 
		//- Return true if the coordinates were able to be set, false otherwise.
		return APC_SetExternalCoords(nPlan,ra,dec,fov)
	end function

	function CurrentSite() as SiteResource
		//- Return the current Site as a SiteResource, or nil if it has not been specified, or
		//- if it does not exist in the resource database.
		return SiteResource.Get(APC_GetCurrentSiteName(nPlan))
	end function

	function CurrentSiteName() as string
		Deprecate("Plan.CurrentSiteName","Plan.CurrentSite.Name")
		return APC_GetCurrentSiteName(nPlan)
	end function

	function CurrentTelescope() as TelescopeResource
		//- Return the current Telescope as a TelescopeResource, or nil if it has not been specified, or
		//- if it does not exist in the resource database.
		return TelescopeResource.Get(APC_GetCurrentTelescopeName(nPlan))
	end function

	function CurrentTelescopeName() as string
		Deprecate("Plan.CurrentTelescopeName","Plan.CurrentTelescope.Name")
		return APC_GetCurrentTelescopeName(nPlan)
	end function

	function FoVTelescope() as TelescopeResource
		//- Return the current Telescope being used in the Field of View chart, 
		//- or nil if it has not been specified.
		return TelescopeResource.Get(APC_GetFoVResourceName(nPlan,"Telescope"))
	end function
  
	function FoVEyepiece() as EyepieceResource
		//- Return the current Eyepiece being used in the Field of View chart, 
		//- or nil if it has not been specified, or an Imager has been selected.
		return EyepieceResource.Get(APC_GetFoVResourceName(nPlan,"Eyepiece"))
	end function
  
	function FoVImager() as ImagerResource
		//- Return the current Imager being used in the Field of View chart, 
		//- or nil if it has not been specified, or an Eyepiece is being used.
		return ImagerResource.Get(APC_GetFoVResourceName(nPlan,"Imager"))
	end function
  
	function FoVOpticalAid() as OpticalAidResource
		//- Return the current Optical Aid being used in the Field of View chart, 
		//- or nil if it has not been specified.
		return OpticalAidResource.Get(APC_GetFoVResourceName(nPlan,"Aid"))
	end function
  
	sub SortObjectList(optional byWhat as integer = 0, optional Ascending as boolean = true)
		//- Sort the object list by the specified column/field.
		//- Use the list_ constants to determine sort order (see APCallable module).
		//- If Ascending is true then sort into ascending order, else descending order.
		APC_SortObservingList(nPlan,byWhat,Ascending)
	end sub

	sub SortObjectList(optional byWhat as string = "", optional Ascending as boolean = true)
		//- Sort the object list by the specified column heading.
		//- If Ascending is true then sort into ascending order, else descending order.
		APC_SortObservingList(nPlan,byWhat,Ascending)
	end sub

	sub SortObservingList(optional byWhat as integer = 0, optional Ascending as boolean = true)
	  Deprecate("Plan().SortObservingList","Plan().SortObjectList")
		SortObjectList(byWhat,Ascending)
	end sub

	sub SortObservingList(optional byWhat as string = "", optional Ascending as boolean = true)
		Deprecate("Plan().SortObservingList","Plan().SortObjectList")
		SortObjectList(byWhat,Ascending)
	end sub

	function Sunrise(optional dt as double = 0.0) as double()
		//- Return the times of Sunrise and start times of astronomical, nautical, and civil twilight for the site defined in the plan document.
		//- The result array has four elements:
		//- 0 = rise time (-1 if sun doesn't rise)
		//- 1 = start of civil twilight (<0 if never occurs)
		//- 2 = start of nautical twilight (<0 if never occurs)
		//- 3 = start of astronomical twilight (<0 if never occurs)
		//- If dt = 0 then return the times for the plan document local date/time, 
		//- otherwise use the given local date/time in seconds. 
		//- Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		return APC_SunRiseSet(nPlan,dt,true)
	end function

	function Sunset(optional dt as double = 0.0) as double()
		//- Return the times of Sunset and end times of astronomical, nautical, and civil twilight for the site defined in the plan document.
		//- The result array has four elements:
		//- 0 = set time (-2 if sun doesn't set)
		//- 1 = start of civil twilight (<0 if never occurs)
		//- 2 = start of nautical twilight (<0 if never occurs)
		//- 3 = start of astronomical twilight (<0 if never occurs)
		//- If dt = 0 then return the times for the plan document local date/time, 
		//- otherwise use the given local date/time in seconds. 
		//- Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		return APC_SunRiseSet(nPlan,dt,false)
	end function

	function Moonrise(optional dt as double = 0.0) as double
		//- Return the time of Moonrise.
		//- If dt = 0 then return the time for the plan document local date/time, otherwise use the given local date/time in seconds. 
		//- Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		
		return APC_MoonRiseSet(nPlan,dt,true)
	end function

	function Moonset(optional dt as double = 0.0) as double
		//- Return the time of Moonset.
		//- If dt = 0 then return the time for the plan document local date/time, otherwise use the given local date/time in seconds. 
		//- Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		return APC_MoonRiseSet(nPlan,dt,false)
	end function

	function MoonPhase(optional dt as double = 0.0) as double
		//- Return the moon phase angle (+/-180 = new, 0=full, 90=first quarter, -90 last quarter).
		//- If dt = 0 then return the phase for the plan document local date/time, otherwise use the given local date/time in seconds. 
		//- Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)

		return APC_MoonPhase(nPlan,dt)
	end function

	function MoonIllumination(optional dt as double = 0.0) as double
		//- Return the illuminated fraction of the moon's disk (0 - 1).
		//- If dt = 0 then return the illumination for the plan document local date/time, otherwise use the given local date/time in seconds. 
		//- Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		return APC_MoonIllum(nPlan,dt)
	end function

	function SlewTo(ra as double, dec as double) as integer
		//- Slews to the specified RA/Dec coordinates (assuming it is above the horizon and the telescope is connected).
		//- An integer status is returned. This has the following values:
		//- -1 = telescope is not connected or does not have go-to slewing capabilities. 
		//- 0 = slew successful.
		//- 2 = below horizon (altitude<0)
		//- 3 = outside defined slewing limits for the telescope mount.
		//- 4 = Blocked by user-defined horizon.

		return APC_SlewTo(nPlan,ra,dec)
	end function

	function SlewWait(optional timeout as double = 60.0) as integer
		//- Upon a successful SlewTo, SlewWait will wait for the slew to complete. 
		//- A progress window is displayed while the slew is in progress. 
		//- The user can click the Cancel button to abort the slew. 
		//- The timeout parameter (default = 60.0) represents the amount of time (in seconds) before the SlewWait routine should abort. 
		//- An integer status is returned:
		//- 0 = slew successfully completed.
		//- -1 = routine timed-out.
		//- -2 = user aborted slew (by clicking the Cancel button).
		dim startTime as double
		dim elapsed as double

		StartProgress("Waiting for slew completion",true,timeout)
		startTime=Microseconds
		do
			APC_Yield
			if not APC_IsSlewing(nPlan) then exit
			elapsed=(MicroSeconds-StartTime)*1E-6
			if UpdateProgress(elapsed) then
				StopProgress
				APC_AbortSlew(nPlan)
				return -2
			end if
		loop until elapsed>=timeout
		StopProgress
		if not APC_IsSlewing(nPlan) then return 0 else return -1
	end function
	
	sub SetFoVCenter(ra as double, dec as double)
	//- Redraw the FOV chart in the plan document so that it is centred on the given coordinates.
	APC_SetFoVCenter(nPlan,ra,dec)
	end Sub

	sub MinimumSlewSort()
		//- Perform the default minimum slew sort on the object list.
		APC_MinimumSlewSortBasic(nPlan)
	end sub

	sub MinimumSlewSort(objects() as APPlanObject, optional method as integer = 0, optional weight as integer = 0, optional ra as double = -999.0, optional dec as double = -999.0)
		//- Performs a minimum-slew sort on the array of plan objects 
		//- (i.e. the array of objects is sorted in place to minimize the slewing distance between them).
		//- See the scripting manual for more info.

		dim i,j,m,rawt,azwt,wt,order(-1) as integer, tobj,neworder(-1) as APPlanObject, w,x(-1),y(-1),closest as double

		if ubound(objects)<1 then return

		if ra>=0.0 and ra<=24.0 and dec>=-90.0 and dec<=90.0 then
			j=0
			closest=1E6
			for i=0 to ubound(objects)
				objects(i).flag=false
				w=AngleBetween(objects(i).RA,objects(i).Dec,ra,dec)
				if w<closest then
					closest=w
					j=i
				end if
			next
			objects(j).flag=true
		end if
		redim x(ubound(objects))
		redim y(ubound(objects))

		if method=mss_Application then
			APC_GetMSSParams(nPlan,m,rawt,azwt)
			if m=mss_AzAlt then
				wt=azwt
			else
				wt=rawt
			end if
		else
			m=method
			wt=weight
		end if

		select case wt
		case mss_NoWeight
			w=1.0
		case mss_LowWeight
			w=0.1
		case mss_HighWeight
			w=10.0
		end select

		for i=0 to ubound(objects)
			select case m
			case mss_Default
				x(i)=objects(i).RA
				y(i)=objects(i).Dec
			case mss_RADec
				x(i)=objects(i).RA*15.0*w
				y(i)=objects(i).Dec
			case mss_AzAlt
				x(i)=objects(i).Azimuth*w
				y(i)=objects(i).Altitude
			end select
		next

		order=APC_MinimumSlewSort(x,y,m)

		redim neworder(ubound(order))
		for i=0 to ubound(order)
			neworder(i)=objects(order(i))
		next

		if ra>=0.0 and ra<=24.0 and dec>=-90.0 and dec<=90.0 then
			j=0
			for i=0 to ubound(neworder)
				if neworder(i).flag then j=i
			next
			for i=0 to ubound(neworder)
				objects(i)=neworder(j)
				j=(j+1) mod (ubound(neworder)+1)
			next
		else
			for i=0 to ubound(order)
				objects(i)=neworder(i)
			next
		end if
	end sub

	function AddSolarSystemObject(what as integer) as APPlanObject
		//- Add a solar system object to the plan document. what is one of the SolarSytem.ss_ constants.
		dim n as integer
		n=APC_AddSpecial(nPlan,what)
		if n>0 then return new APPlanObject(nPlan,n) else return nil
	end function
	
	sub SaveValue(title as string, v as Variant)
		//- Save a script value, v, to a non-volatile store associated with the plan document, using the (unique) title as a key.
		//- v can be of type Integer, Double, Boolean, String or Color. Or an array of one of those types.
		if v=nil then return
		APC_SaveIntegerValue(nPlan,title+".Type",v.Type)
		if v.IsArray then
			// Array type
			select case v.ArrayElementType
			case vtype_Integer,vtype_Long  // Integer
			   dim vv() as integer = v
				 APC_SaveIntegerValue(nPlan,title,vv)
			case vtype_Single,vtype_Double  // Double
			   dim vv() as double = v
				 APC_SaveDoubleValue(nPlan,title,vv)
			case vtype_Boolean   // Boolean
			   dim vv() as boolean = v
				 APC_SaveBooleanValue(nPlan,title,vv)
			case vtype_String    // String
			   dim vv() as string = v
				 APC_SaveStringValue(nPlan,title,vv)
			case vtype_Color  // Color
				 dim vv() as Color = v
				 APC_SaveColourValue(nPlan,title,vv)
			end select
		else
			// Scalar type
			select case v.Type
			case vtype_Integer,vtype_Long  // Integer
				 APC_SaveIntegerValue(nPlan,title,v.IntegerValue)
			case vtype_Single,vtype_Double  // Double
				 APC_SaveDoubleValue(nPlan,title,v.DoubleValue)
			case vtype_Boolean   // Boolean
				 APC_SaveBooleanValue(nPlan,title,v.BooleanValue)
			case vtype_String    // String
				 APC_SaveStringValue(nPlan,title,v.StringValue)
			case vtype_Color  // Color
				 APC_SaveColourValue(nPlan,title,v.ColorValue)
			end select
		end if
	end sub

	function RestoreValue(title as string, default as Variant) as Variant
		//- Retrieve a script value from the non-volatile store associated with the plan document, using the (unique) title as a key. 
		//- If title is not found use the defined default value.
		//- default can be of type Integer, Double, Boolean, String or Color. Or an array of one of those types.
		if not APC_HasValue(nPlan,title+".Type") then return default
		dim vt as integer = APC_RestoreIntegerValue(nPlan,title+".Type",-1)
		if vt<0 then return default
    if (vt and vtype_Array)<>0 then
			// Array type
			vt=vt and not vtype_Array
			select case vt
			case vtype_Integer,vtype_Long  // Integer
			   dim d(-1) as integer
			   if not APC_HasValue(nPlan,title+".array") then
			   	if default<>nil and default.IsArray and default.ArrayElementType=vtype_Integer then return default else return d
			   end if
				 return APC_RestoreIntegerValue(nPlan,title,d)
			case vtype_Single,vtype_Double  // Double
			   dim d(-1) as double
			   if not APC_HasValue(nPlan,title+".array") then
			   	if default<>nil and default.IsArray and default.ArrayElementType=vtype_Double then return default else return d
			   end if
				 return APC_RestoreDoubleValue(nPlan,title,d)
			case vtype_Boolean   // Boolean
			   dim d(-1) as boolean
			   if not APC_HasValue(nPlan,title+".array") then
			   	if default<>nil and default.IsArray and default.ArrayElementType=vtype_Boolean then return default else return d
			   end if
				 return APC_RestoreBooleanValue(nPlan,title,d)
			case vtype_String   // String
			   dim d(-1) as string
			   if not APC_HasValue(nPlan,title+".array") then
			   	if default<>nil and default.IsArray and default.ArrayElementType=vtype_String then return default else return d
			   end if
				 return APC_RestoreStringValue(nPlan,title,d)
			case vtype_Color    // Color
			   dim d(-1) as Color
			   if not APC_HasValue(nPlan,title+".array") then
			   	if default<>nil and default.IsArray and default.ArrayElementType=vtype_Color then return default else return d
			   end if
				 return APC_RestoreColourValue(nPlan,title,d)
			end select
		else		
			select case vt
			case vtype_Integer,vtype_Long  // Integer
				 return APC_RestoreIntegerValue(nPlan,title,default.IntegerValue)
			case vtype_Single,vtype_Double  // Double
				 return APC_RestoreDoubleValue(nPlan,title,default.DoubleValue)
			case vtype_Boolean   // Boolean
				 return APC_RestoreBooleanValue(nPlan,title,default.BooleanValue)
			case vtype_String   // String
				 return APC_RestoreStringValue(nPlan,title,default.StringValue)
			case vtype_Color    // Color
				 return APC_RestoreColourValue(nPlan,title,default.ColorValue)
			end select
		end if
		return nil
	end function

	sub ClearSavedValues()
		//- Clear all keys and values associated with this script from the non-volatile store associated with the plan document.
		APC_ClearSavedValues(nPlan)
	end sub

	sub ClearAllSavedValues()
		//- Clear all keys and values associated with all scripts from the non-volatile store associated with the plan document.
		APC_ClearAllSavedValues(nPlan)
	end sub
	
	Sub SaveRestoreGlobal(b as boolean)
		//- If b is false (the default), the non-volatile store is associated with the plan document. 
		//- If b is true then the non-volatile store used by this script is a global one, and can be accessed from any plan document.
		APC_SaveRestoreGlobal(nPlan,b)
	End Sub
	
	Sub SaveRestoreTag(t as string)
		//- Normally, data accessed by SaveValue and RestoreValue uses a tag associated with the script name. 
		//- You can specify a fixed tag that is then used independently of the script name. 
		//- Useful if you want to change the name of the script, but retain any settings.
		APC_SaveRestoreTag(nPlan,t)
	End Sub

	function nUserFieldDefinitions() as integer
		return APUserField.nDefinedUserFields(nPlan,APUserField.ufnit_Object)
	end function

	function UserFieldDefinition(n as integer) as APUserField
		return APUserField.DefinedUserField(nPlan,APUserField.ufnit_Object,n)
	end function

	function UserFieldDefinition(title as string) as APUserField
		return APUserField.DefinedUserField(nPlan,APUserField.ufnit_Object,title)
	end function

  function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(nPlan,APUserField.ufnit_Object,uf)
  end function
  
  function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(nPlan,APUserField.ufnit_Object,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(nPlan,APUserField.ufnit_Object,title,deleteValues)
  end function

	function ChooseObjects(optional multiple as boolean = false) as APPlanObject()
		//- Use a dialog to select one or more objects from the plan's object list.
		//- If multiple is true, allow selecting zero or more objects.
		//- If multiple is false, allow selection of a single object.
		//- If the Cancel button is used (or the dialog closed), or no object is selected, 
		//- then an empty array is returned.

		dim rlist() as APPlanObject = Objects
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,"Object")
		dim result() as APPlanObject
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = APPlanObject(r(i))
		next
		return result
	end function

  
//--- Shared methods
	private shared dim vErrorCode as integer
	
	shared function ErrorCode() as integer
		//- Error codes returned from NewPlan and OpenPlan calls:
		//- 0 – User cancelled operation.
		//- -1 – Bad file name.
		//- -2 – Path specifies existing folder, rather than a file. 
		//- -3 – Could not delete existing file.
		//- -4 – Plan with same name already open.
		//- -5 – Could not create plan document.
		return vErrorCode
	end function

	shared function NewPlan(optional path as string = "", optional silent as boolean = false, optional unique as boolean = false) as APPlan
		//- Create a new plan document, and return it. 
		//- If the method failed, nil is returned. Use the ErrorCode function to find out why the failure occurred.
		//- If path is specified it must be a full path + name. If the path is blank or omitted, the user is prompted for the file path.
		//- If silent is true (default false) then the user will not be prompted if the file already exists, and it will be overwritten silently.
		//- If unique is true (default is false) then, if the specified file is already present, it will attempt to try with “name-1”, “name-2”, etc., in the same folder until a unique file (i.e. non-existent) is found.

		dim n as integer = APC_NewPlan(path,silent,unique)
		APM_CreatePlanList
		if n<=0 then
			vErrorCode=n
			return nil
		else
			vErrorCode=0
			return Plan(n)
		end if
	end function

	shared function OpenPlan(optional path as string = "", optional silent as boolean = true) as APPlan
		//- Open a plan document, given path. If path="", ask the user for the path.
		//- If silent=TRUE (default) don't display any warning dialogs, etc. when attempting
		//- to open the plan document.
		dim n as integer = APC_OpenPlan(path,not silent)
		APM_CreatePlanList
		if n<=0 then
			vErrorCode=n
			return nil
		else
			vErrorCode=0
			return Plan(n)
		end if
	end function

	shared function NewUntitled( ) as APPlan
		//- Create a new untitled plan document
		dim n as integer = APC_UntitledPlan()
		APM_CreatePlanList
		if n<=0 then
			vErrorCode=n
			return nil
		else
			vErrorCode=0
			return Plan(n)
		end if
	end function
	
	shared function Count() as integer
		//- No. of open plan documents
		if ubound(apc_plans)<0 then APM_CreatePlanList
		return ubound(apc_plans)+1
	end function

  private shared dim apc_plans(-1) as APPlan
  
  shared sub APM_CreatePlanList() // private
		dim i,n as integer
		n=APC_PlanCount
		redim apc_plans(-1)
		for i=1 to n
			apc_plans.Append new APPlan(i)
		next
	end sub

  shared function PlanNumber(p as APPlan) as integer // private
  	if ubound(apc_plans)<0 then APM_CreatePlanList
  	if p=nil then return APC_CurrentPlanNumber else return apc_plans.IndexOf(p)+1
  end function
  
  shared function Plan(name as string) as APPlan
  	//- Return the plan with the given name. If name="" then return the current plan.
  	if name="" then return Plan(-1)
  	if ubound(apc_plans)<0 then APM_CreatePlanList
  	for i as integer = 0 to ubound(apc_plans)
  		if apc_plans(i).Name=name then return apc_plans(i)
  	next
  	return nil
  end function
  
  shared function Plan(optional n as integer = -1) as APPlan
  	//- Return the plan with the given plan number. If n = -1 or is omitted, return the current plan.
  	if ubound(apc_plans)<0 then APM_CreatePlanList
  	if n<1 or n>ubound(apc_plans)+1 then return apc_plans(APC_CurrentPlanNumber-1) else return apc_plans(n-1)
  end function
  
  shared function Plans( ) as APPlan()
  	//- Return an array of open plan documents
  	dim p(-1) as APPlan
  	for i as integer = 1 to Count
  		p.Append Plan(i)
  	next
  	return p
  end function
  
	shared function Choose(optional multiple as boolean = false) as APPlan()
		//- Use a dialog to select one or more open plan documents from a list of all open plans.
		//- If multiple is true, allow selecting zero or more plans.
		//- If multiple is false, allow selection of a single plan.
		//- If the Cancel button is used (or the dialog closed), or no plan is selected, 
		//- then an empty array is returned.

		dim rlist() as APPlan = APPlan.Plans
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,"Plan")
		dim result() as APPlan
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = APPlan(r(i))
		next
		return result
	end function

end class

//------------------------------------------------------------------------------------
module APPlanModule // deprecate

	function nPlans() as integer
		Deprecate("nPlans","APPlan.Count")
		return APPlan.Count
	end function

	function PlanNumber(optional p as APPlan = nil) as integer
		Deprecate("PlanNumber(p)","p.Number")
		//- Returns current plan number if parameter missing or nil
		return APPlan.PlanNumber(p)
	end function

	function CurrentPlanNumber() as integer
		Deprecate("CurrentPlanNumber","Plan().Number")
		Return Plan().Number
	end function

	function PlanNumber(name as string) as integer
		Deprecate("PlanNumber(name)","APPlan.Plan(name)")
		dim p as APPlan = APPlan.Plan(name)
		if p=nil then return -1 else return p.Number
	end function

	function CurrentPlan() as APPlan
		Deprecate("CurrentPlan","Plan()")
		Return APPlan.Plan()
	end function

	function GetPlanName(optional n as integer = -1) as string
		Deprecate("GetPlanName","Plan().Name")
		return Plan(n).Name
	end function

	function PlanDescription() as string
		Deprecate("PlanDescription","Plan().Description")
		return Plan().Description
	end function

	sub PlanDescription(assigns s as string)
		Deprecate("PlanDescription","Plan().Description")
		Plan().Description=s
	end sub

	function PlanCreator() as string
		Deprecate("PlanCreator","Plan().Creator")
		return Plan().Creator
	end function

	sub PlanCreator(assigns s as string)
		Deprecate("PlanCreator","Plan().Creator")
		Plan().Creator=s
	end sub

	function PlanLocalDateTime() as double
		Deprecate("PlanLocalDateTime","Plan().LocalDateTime")
		return Plan().LocalDateTime
	end function

	sub PlanLocalDateTime(assigns t as double)
		Deprecate("PlanLocalDateTime","Plan().LocalDateTime")
		Plan().LocalDateTime=t
	end sub

	sub PlanRealTime()
		Deprecate("PlanRealTime","Plan().LocalDateTime=0.0")
		Plan().LocalDateTime=0.0
	end sub

	sub FixedDate(assigns b as boolean)
		Deprecate("FixedDate","Plan().FixedDate")
		Plan().FixedDate=b
	end sub

	function FixedDate() as boolean
		Deprecate("FixedDate","Plan().FixedDate")
		return Plan().FixedDate
	end function

	function PlanGMT() as double
		Deprecate("PlanGMT","Plan().GMT")
		return Plan().GMT
	end function

	function PlanGMST() as double
		Deprecate("PlanGMST","Plan().GMST")
		return Plan().GMST
	end function

	function PlanLST() as double
		Deprecate("PlanLST","Plan().LST")
		return Plan().LST
	end function

	function PlanJulianDate() as double
		Deprecate("PlanJulianDate","Plan().JulianDate")
		return Plan().JulianDate
	end function

	function PlanHeliocentricJulianDate(ra as double, dec as double) as double
		Deprecate("PlanHeliocentricJulianDate","Plan().HeliocentricJulianDate")
		return Plan().HeliocentricJulianDate(ra,dec)
	end function

	function PlanChanged(optional n as integer=-1) as boolean
		Deprecate("PlanChanged(n)","Plan(n).Changed")
		return Plan(n).Changed
	end function

	sub SavePlan(optional n as integer=-1)
		Deprecate("SavePlan(n)","Plan(n).Save")
		Plan(n).Save
	end sub

	sub ClosePlan(optional n as integer = -1, optional silent as boolean = false)
		Deprecate("ClosePlan(n)","Plan(n).Close")
		Plan(n).Close(silent)
	end sub

	sub SelectPlan(n as integer)
		Deprecate("SelectPlan(n)","Plan(n).Choose")
		Plan(n).Choose
	end sub

	function NewPlan(optional path as string = "", optional silent as boolean = false, optional unique as boolean = false) as integer
		Deprecate("NewPlan()","APPlan.NewPlan()")
		dim p as APPlan = APPlan.NewPlan(path,silent,unique)
		if p<>nil then return p.Number else return -1
	end function

	function OpenPlan(optional path as string = "") as integer
		Deprecate("OpenPlan","APPlan.OpenPlan")
		dim p as APPlan = APPlan.OpenPlan(path)
		if p<>nil then return p.Number else return -1
	end function

	function Obj(n as integer) as APPlanObject
		Deprecate("Obj(n)","Plan().Obj(n)")
		return Plan().Obj(n)
	end function

	function nObservations() as integer
		Deprecate("nObservations","APObservation.Count")
		return APObservation.Count
	end function

	function Item(n as integer) as APPlanObject
		Deprecate("Item(n)","Plan().Obj(n)")
		return Plan.Obj(n)
	end function

	function IsOnline() as boolean
		Deprecate("IsOnline","Plan().TelescopeConnected")
		return Plan().TelescopeConnected
	end function

	sub Online(assigns b as boolean)
		Deprecate("Online","Plan().TelescopeConnected")
		Plan().TelescopeConnected=b
	end sub

	function CurrentRA() as double
		Deprecate("CurrentRA","Plan().CurrentRA")
		return Plan().CurrentRA
	end function

	function CurrentDec() as double
		Deprecate("CurrentDec","Plan().CurrentDec")
		return Plan().CurrentDec
	end function

	function nObjects() as integer
		Deprecate("nObjects","Plan().nObjects")
		return Plan().nObjects
	end function

	function nObj() as integer
		Deprecate("nObj","Plan().nObjects")
		return Plan().nObjects
	end function

	function nItems() as integer
		Deprecate("nItems","Plan().nObjects")
		return Plan().nObjects
	end function

	function NewObject() as APPlanObject
		Deprecate("NewObject","Plan().NewObject")
		return Plan().NewObject
	end function

	function FindObject(ParamArray s as string) as APPlanObject
		Deprecate("FindObject","Plan().FindObject")
		dim n as integer
		n=APC_FindObject(-1,s)+1
		if n>0 then return Plan().Obj(n) else return nil
	end function

	function FindObjects(ParamArray s as string) as APPlanObject()
		dim i as integer
		dim n(-1) as integer
		dim p(-1) as APPlanObject

		Deprecate("FindObjects","Plan().FindObjects")
		n=APC_FindObjects(-1,s)
		redim p(ubound(n))
		for i=0 to ubound(n)
			p(i)=Plan().Obj(n(i)+1)
		next
		return p
	end function

	function SelectedObject() as integer
		Deprecate("SelectedObject","Plan().SelectedObjectIndex")
		return Plan().SelectedObjectIndex
	end function

	function GetExternalCoords(byref ra as double, byref dec as double) as boolean
		Deprecate("GetExternalCoords","Plan().GetExternalCoords")
		return Plan().GetExternalCoords(ra,dec)
	end function

	function SetExternalCoords(ra as double, dec as double, optional fov as double = -1.0) as boolean
		Deprecate("SetExternalCoords","Plan().SetExternalCoords")
		return Plan().SetExternalCoords(ra,dec,fov)
	end function

	sub SortObservingList(optional byWhat as integer = 0, optional Ascending as boolean = true)
		Deprecate("SortObservingList","Plan().SortObservingList")
		Plan().SortObservingList(byWhat,Ascending)
	end sub

	function SlewTo(ra as double, dec as double) as integer
		Deprecate("SlewTo","Plan().SlewTo")
		return Plan().SlewTo(ra,dec)
	end function

	function SlewWait(optional seconds as double = 60.0) as integer
		Deprecate("SlewWait","Plan().SlewWait")
		return Plan().SlewWait(seconds)
	end function

	sub MinimumSlewSort(objects() as APPlanObject, optional method as integer = 0, optional weight as integer = 0, optional ra as double = -999.0, optional dec as double = -999.0)
		Deprecate("MinimumSlewSort","Plan().MinimumSlewSort")
		Plan().MinimumSlewSort(objects,method,weight,ra,dec)
	end sub

end module

//------------------------------------------------------------------------------------
module SaveRestoreValues // deprecate

	Sub SaveRestoreGlobal(b as boolean)
		Deprecate("SaveRestoreGlobal()","Plan().SaveRestoreGlobal()")
		Plan().SaveRestoreGlobal(b)
	End Sub

	Sub SaveRestoreTag(t as string)
		Deprecate("SaveRestoreTag()","Plan().SaveRestoreTag()")
		Plan().SaveRestoreTag(t)
	End Sub

	sub SaveIntegerValue(title as string, v as integer)
		Deprecate("SaveIntegerValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveIntegerValue(title as string, v() as integer)
		Deprecate("SaveIntegerValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveDoubleValue(title as string, v as double)
		Deprecate("SaveDoubleValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveDoubleValue(title as string, v() as double)
		Deprecate("SaveDoubleValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveBooleanValue(title as string, v as boolean)
		Deprecate("SaveBooleanValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveBooleanValue(title as string, v() as boolean)
		Deprecate("SaveBooleanValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveStringValue(title as string, v as string)
		Deprecate("SaveStringValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveStringValue(title as string, v() as string)
		Deprecate("SaveStringValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveColorValue(title as string, v as Color)
		Deprecate("SaveColorValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub

	sub SaveColorValue(title as string, v() as Color)
		Deprecate("SaveColorValue","Plan().SaveValue")
		Plan().SaveValue(title,v)
	end sub


	function RestoreIntegerValue(title as string, optional default as integer = 0) as integer
		Deprecate("RestoreIntegerValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreIntegerValue(title as string, default() as integer) as integer()
		Deprecate("RestoreIntegerValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreDoubleValue(title as string, optional default as double = 0.0) as double
		Deprecate("RestoreDoubleValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreDoubleValue(title as string, default() as double) as double()
		Deprecate("RestoreDoubleValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreBooleanValue(title as string, optional default as boolean = false) as boolean
		Deprecate("RestoreBooleanValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreBooleanValue(title as string, default() as boolean) as boolean()
		Deprecate("RestoreBooleanValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreStringValue(title as string, optional default as string = "") as string
		Deprecate("RestoreStringValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreStringValue(title as string, default() as string) as string()
		Deprecate("RestoreStringValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreColorValue(title as string, optional default as Color = &c000000) as Color
		Deprecate("RestoreColorValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	function RestoreColorValue(title as string, default() as Color) as Color()
		Deprecate("RestoreColorValue","Plan().RestoreValue")
		return Plan().RestoreValue(title,default)
	end function

	sub ClearSavedValues()
		Deprecate("ClearSavedValues","Plan().ClearSavedValues")
		Plan().ClearSavedValues
	end sub

	sub ClearAllSavedValues()
		Deprecate("ClearAllSavedValues","Plan().ClearAllSavedValues")
		Plan().ClearAllSavedValues
	end sub

end module

//------------------------------------------------------------------------------------
class APCatalogObject
	// Documented 7/9/2012
	//- Encapsulates an object in a catalogue.
  //- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APCatalog.GetObject(n))
	implements NamedObject
	implements RADecObject
	
  private dim nCat as integer
	private dim nObj as integer
	private dim nSrch as integer
	
	private RADecJD as double
	private coords as Pair

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer) // private
		nObj=n
		nCat=-1
		nSrch=-1
	end sub

	sub Constructor(nc as integer, n as integer) // private
		nObj=n
		nCat=nc
		nSrch=-1
	end sub

	sub Constructor(nc as integer, n as integer, ns as integer) // private
		nObj=n
		nCat=nc
		nSrch=ns
	end sub

	function ID(optional n as integer = 0) as string
		//- Returns the main ID if used without a parameter. 
		//- If a numeric parameter is used then the various IDs are returned (if applicable), or blank otherwise.
		return APC_CatObj_ID(nCat,nObj,nSrch,n)
	end function

	function ID(prefix as string) as string
		//- Return the ID with the specified prefix (e.g. ID("SAO")).
		//- Can also specify prefix as "Bayer", "Flamsteed", or "GCVS" to return the respective ID.
		return APC_CatObj_ID(nCat,nObj,nSrch,prefix)
	end function

	function Bayer(optional encoded as boolean = true) as string
		//- Returns the Bayer ID if applicable. If not, return the Flamsteed ID if applicable. If not, return the primary ID. 
		//- If the encoded parameter is true (the default), then the function returns the string in an UTF-8 encoded form (e.g. α Cen). 
		//- If false, the ASCII version is returned (e.g. Alp Cen).
		return APC_CatObj_String("Bayer",nCat,nObj,nSrch,encoded)
	end function

	function Catalog() as string
		//- Source catalogue for this object.
		return APC_CatObj_String("Catalog",nCat,nObj,nSrch,false)
	end function

	function Name() as string
		//- Object's Name field.
		return APC_CatObj_String("Name",nCat,nObj,nSrch,false)
	end function

	function Components() as string
		//- Object's Components field.
		return APC_CatObj_String("Components",nCat,nObj,nSrch,false)
	end function

	function ObjectName() as string // private
		if Name<>"" then return ID+" - "+Name else return ID
	end function

	function Notes() as string
		//- Object's User Notes field.
		return APC_CatObj_String("User Notes",nCat,nObj,nSrch,false)
	end function

	function UserNotes() as string
		//- Object's User Notes field.
		return APC_CatObj_String("User Notes",nCat,nObj,nSrch,false)
	end function

	function CatalogNotes() as string
		//- Object's Catalogue Notes field.
		return APC_CatObj_String("Cat Notes",nCat,nObj,nSrch,false)
	end function

	function Size() as string
		//- Object's Size field.
		return APC_CatObj_String("Size",nCat,nObj,nSrch,false)
	end function

	function Spectral() as string
		//- Object's Spectral field.
		return APC_CatObj_String("Spectral",nCat,nObj,nSrch,false)
	end function

	function Type() as string
		//- Object's Type field.
		return APC_CatObj_String("Type",nCat,nObj,nSrch,false)
	end function

	function GetTypes() as string()
		//- Returns an array of types associated with this object. This will have at most three elements.
		dim ss(-1) as string
		APC_CatObj_GetTypes(nCat,nObj,nSrch,ss)
		return ss
	end function
	
	private Function Normalise(x as double, vfrom as double, vto as double) As double
	
		// Normalise x so that it lies in the range vfrom >= x < vto
	
	  dim norm,range as double
  
	  norm = x
	  range = vto-vfrom
	  while norm<vfrom
	    norm=norm+range
	  wend
	  while norm>vto
	    norm=norm-range
	  wend
	  return norm
	End Function
	
	private Function ConvertEpoch(fromJD as double, toJD as double, fromRA as double, fromDec as double, raPM as double, decPM as double) As Pair
	  // fromJD and/or toJD can either be a Julian date, or one of the following: 2000.0 (J2000.0), 2050.0 (J2050.0), 1950.0 (B1950.0), 1900.0 (B1900.0)
  
	  // Formulae from Meeus, Pg 134, Rigorous method.
  
	  dim JD0 as double = fromJD
	  dim JD as double = toJD
  
	  // Check for Epoch rather than JD
  
	  if JD0=2000.0 then
	    JD0 = 2451545.0
	  elseif JD0=2050.0 then
	    JD0 = 2469807.5
	  elseif JD0=1950.0 then
	    JD0 = 2433282.4235
	  elseif JD0=1900.0 then
	    JD0 = 2415020.3135
	  end if
	  if JD=2000.0 then
	    JD = 2451545.0
	  elseif JD=2050.0 then
	    JD = 2469807.5
	  elseif JD=1950.0 then
	    JD = 2433282.4235
	  elseif JD=1900.0 then
	    JD = 2415020.3135
	  end if
  
	  dim ra0 as double = fromRA*HoursToRadians
	  dim dec0 as double = fromDec*DegreesToRadians

	  dim SecondsToRadians as double = DegreesToRadians/3600.0

	  // Adjust for proper motion where applicable
	  if raPM<>0.0 or decPM<>0.0 then
	  	dim years as double = (JD-JD0)/365.25
	  	dim deltaRA as double = raPM*0.001*years*SecondsToRadians
	  	dim deltaDec as double = decPM*0.001*years*SecondsToRadians
	  	ra0 = ra0 + deltaRA
	  	dec0 = dec0 + deltaDec
	  end if
  
	  dim BigT as double = (JD0 - 2451545.0) / 36525.0
	  dim LittleT as double = (JD - JD0) / 36525.0
  
	  dim BigT2 as double = BigT*BigT
	  dim LittleT2 as double = LittleT*LittleT
	  dim LittleT3 as double = LittleT2*LittleT
  
	  dim zeta as double = (2306.2181 + 1.39656*BigT - 0.000139*BigT2)*LittleT _
	  + (0.30188 - 0.000344*BigT)*LittleT2 + 0.017998*LittleT3
  
	  dim z as double = (2306.2181 + 1.39656*BigT - 0.000139*BigT2)*LittleT _
	  + (1.09468 + 0.000066*BigT)*LittleT2 + 0.018203*LittleT3
  
	  dim theta as double = (2004.3109 - 0.85330*BigT - 0.000217*BigT2)*LittleT _
	  - (0.42665 + 0.000217*BigT)*LittleT2 - 0.041833*LittleT3
    
	  zeta = zeta * SecondsToRadians
	  z = z * SecondsToRadians
	  theta = theta * SecondsToRadians
    
	  dim cosdec0 as double = cos(dec0)
	  dim sindec0 as double = sin(dec0)
	  dim costheta as double = cos(theta)
	  dim sintheta as double = sin(theta)
  
	  dim A as double = cosdec0*sin(ra0 + zeta)
	  dim B as double = costheta*cosdec0*cos(ra0 + zeta) - sintheta*sindec0
	  dim C as double = sintheta*cosdec0*cos(ra0 + zeta) + costheta*sindec0
  
	  dim ra as double = Normalise(atan2(A,B)+z,0.0,2.0*pi)
	  dim dec as double
	  if abs(fromDec)>89.0 then
	    dec = acos(sqrt(A*A + B*B))
	  else
	    dec = asin(C)
	  end if
  
	  return new Pair(ra*RadiansToHours,dec*RadiansToDegrees)
	End Function

	function RA() as double
		//- Object's Right Ascension value.
		//- This value will be for epoch J2000.0.
		return APC_CatObj_Double("RA",nCat,nObj,nSrch)
	end function

	function RADec(jd as double) as Pair
		//- Object's Right Ascension and Declination values for the epoch specified by the Julian date, jd (0 or greater).
		//- The values will be precessed to that date, including the effects of
		//- proper motion where applicable. 
		if jd>=0.0 then
			if RADecJD<>jd or coords=nil then
				RADecJD = jd
				dim tRA as double = APC_CatObj_Double("RA",nCat,nObj,nSrch)
				dim tDec as double = APC_CatObj_Double("Dec",nCat,nObj,nSrch)
				dim tRAPM as double = APC_CatObj_Double("RAPM",nCat,nObj,nSrch)
				dim tDecPM as double = APC_CatObj_Double("DecPM",nCat,nObj,nSrch)
			
				coords = ConvertEpoch(2000.0,jd,tRA,tDec,tRAPM,tDecPM)
			end if
			return coords
		else
			return nil
		end if
	end function
	
	function Dec() as double
		//- Object's Declination value.
		//- This value will be for epoch J2000.0.
		return APC_CatObj_Double("Dec",nCat,nObj,nSrch)
	end function

	function Magnitude() as double
		//- Object's Magnitude value.
		return APC_CatObj_Double("Mag",nCat,nObj,nSrch)
	end function

	function Magnitude2() as double
		//- Object's Magnitude2 value.
		return APC_CatObj_Double("Mag2",nCat,nObj,nSrch)
	end function

	function Separation() as double
		//- Object's Separation value.
		return APC_CatObj_Double("Sep",nCat,nObj,nSrch)
	end function

	function Period() as double
		//- Object's Period value.
		return APC_CatObj_Double("Period",nCat,nObj,nSrch)
	end function

	function RAProperMotion() as double
		//- Object's proper motion in RA value. milliarcsec/yr
		return APC_CatObj_Double("RAPM",nCat,nObj,nSrch)
	end function

	function DecProperMotion() as double
		//- Object's proper motion in Dec value. milliarcsec/yr
		return APC_CatObj_Double("DecPM",nCat,nObj,nSrch)
	end function

	function Size1() as double
		//- Object's size in arcmin - major axis
		return APC_CatObj_Double("Size1",nCat,nObj,nSrch)
	end function

	function Size2() as double
		//- Object's size in arcmin - minor axis
		return APC_CatObj_Double("Size2",nCat,nObj,nSrch)
	end function

	function PosAngle() as integer
		//- Object's Position Angle value.
		return APC_CatObj_Double("PosAngle",nCat,nObj,nSrch)
	end function

	function nObservations() as integer
		//- Number of observations logged for this object.
		return APC_Obs_CountByID(ID)
	end function

	function Images() as Image()
		//- Return a list of images associated with this object
		dim idx() as integer = APC_CatObj_GetImageList(nCat,nObj,nSrch)
		dim img(-1) as Image
		for i as integer = 0 to idx.Ubound
			img.Append new Image(idx(i)+1)
		next
		return img
	end function

	function Observation(n as integer) as APObservation
		//- Return the n-th observation associated with this object, n = 1, ..., nObservations.
		dim nidx as integer=APC_Obs_ByID(ID,n) // Return index of nth observation
		if nidx<0 then return nil
		return APObservation.APC_GetNewObservation(nidx)
	end function

	function AddToPlan(optional nPlan as integer=-1) as APPlanObject
		//- Add the object to the plan specified by plan number (default is the current plan), and return the corresponding APPlanObject.
		dim n as integer
		Plan(nPlan).APC_Plan_ResetHighlighted
		n=APC_CatObj_AddToPlan(nPlan,nCat,nObj,nSrch)
		if n<1 then return nil else return Plan(nPlan).Obj(n)
	end function

	function AddToPlan(p as APPlan) as APPlanObject
		//- Add the object to the plan specified, and return the corresponding APPlanObject. If p=nil then use the current plan document.
		if p=nil then return AddToPlan(-1) else return AddToPlan(APPlan.PlanNumber(p))
	end function
	
	shared function DreyerTranslation(original as string) as string
		//- Translate Herschel/Dreyer code (such as is used in the NGC/IC catalogues) into a more readable form.
		return APC_DreyerTranslation(original)
	end function
end class

//------------------------------------------------------------------------------------
class APCatalog
	// Documented 7/9/2012
	//- Encapsulates a catalogue (collection of associated astronomical objects, e.g. Messier Catalogue)
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APCatalog.Catalog(n))
	implements NamedObject
	
	private dim nCat as integer

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer) // private
		nCat=n
	end sub
	
	function Name() as string
		//- Name of the catalogue. e.g. "Messier Catalogue"
		return APC_Cat_Name(nCat)
	end function
	
	function ObjectName() as string // private
		return Name
	end function

	function ShortName() as string
		//- Short name of the catalogue. e.g. "Messier"
		return APC_Cat_ShortName(nCat)
	end function

	function FileName() as string
		//- File name of the catalogue. e.g. "Messier.apcat"
		return APC_Cat_FileName(nCat)
	end function

	function nObjects() as integer
		//- Total number of objects in the catalogue.
		return APC_Cat_nObjects(nCat)
	end function

	function GetTypes() as string()
		//- Returns an array of strings containing a list of object types present in the catalogue. 
		//- e.g. “Star”, “Double Star”, “Globular Cluster”.
		dim ss(-1) as string
		APC_Cat_GetTypes(nCat,ss)
		return ss
	end function

	function HasType(ntype as integer) as boolean
		//- Returns true if the catalogue contains at least one object of the specified type, ntype (See APSearch.type_ for type constants).
		return APC_Cat_HasType(nCat,ntype)
	end function

	function nObjectsOfType(ntype as integer) as integer
		//- Returns the number of objects in the catalogue with the given type, ntype (See APSearch.type_ for type constants).
		return APC_Cat_nObjectsOfType(nCat,ntype)
	end function

	sub MagnitudeRangeOfType(ntype as integer, byref mfrom as double, byref mto as double)
		//- Return the magnitude range of objects in the catalogue with the specified type, ntype (See APSearch.type_ for type constants). 
		//- mfrom is the faintest magnitude, mto is the brightest.
		APC_Cat_MagRangeOfType(nCat,ntype,mfrom,mto)
	end sub

	function GetObject(n as integer) as APCatalogObject
		//- Returns an APCatalogObject representing the n-th object in the catalogue, 1 ≤ n ≤ nObjects. Nil otherwise.
		if n>=1 and n<=nObjects then
			return new APCatalogObject(nCat,n)
		else
			return nil
		end if
	end function
	
	// Shared
	
	shared function Count() as integer
		//- Number of installed catalogues.
		return APC_Cat_nCatalogs
	end function

	shared function Catalog(n as integer) as APCatalog
		//- Return n-th catalogue, n = 1, ..., APCatalog.Count
		if n>=1 and n<=Count then return new APCatalog(n) else return nil
	end function

	shared function Catalog(name as string) as APCatalog
		//- Return the catalogue by name (full, short or filename), or nil if it doesn't exist.
		dim n as integer
		n=APC_Cat_ByName(name)
		if n>=1 then return new APCatalog(n) else return nil
	end function

	shared function Catalogs( ) as APCatalog()
		//- Return an array containing all installed catalogues.
		dim i as integer
		dim c(-1) as APCatalog
		for i=1 to Count
			c.Append Catalog(i)
		next
		return c
	end function

	shared function CatalogsWithType(ntype as integer) as APCatalog()
		//- Return an array containing all installed catalogues that have at least one object of the given type, ntype (See APSearch.type_ for type constants).
		dim i as integer
		dim c(-1) as APCatalog
		dim cat as APCatalog

		for i=1 to Count
			cat=Catalog(i)
			if cat.HasType(ntype) then c.Append cat
		next
		return c
	end function

	shared function FindID(s as string, optional cat as string = "") as integer
		//- Search all catalogues for objects matching the given ID (id) or IDs (id contains more than 
		//- one ID separated by commas). If the catname parameter is present and contains one or 
		//- more catalogue names, separated by commas, then only those catalogues will be considered. 
		//- Returns the number of objects found in the catalogue/s, n.
		//- The results are returned by calling FoundObject(1)...FoundObject(n). 
		APC_CatalogFindID(s,cat)
		return APC_nCatalogFind
	end function

	shared function FoundObject(n as integer) as APCatalogObject
		//- Returns the nth object found by the last call to FindID() 
		if n>0 and n<=APC_nCatalogFind then return new APCatalogObject(n) else return nil
	end function
	
	shared function Choose(optional multiple as boolean = false, optional containsType as integer = -1) as APCatalog()
		//- Use a dialog to select one or more catalogues from a list of all installed catalogues.
		//- If multiple is true, allow selecting zero or more catalogues.
		//- If multiple is false, allow selection of a single catalogue.
		//- If containsType is one of the APSearch.type_ constants, then only catalogues containing that type are considered.
		//- If containsType is -1 (default), then all catalogues are considered.
		//- If the Cancel button is used (or the dialog closed), or no catalogue is selected, 
		//- then an empty array is returned.

		dim rlist() as APCatalog = APCatalog.Catalogs
		if containsType>=0 then
			for i as integer = rlist.UBound downto 0
				if not rlist(i).HasType(containsType) then rlist.Remove i
			next
		end if
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,"Catalogue")
		dim result() as APCatalog
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = APCatalog(r(i))
		next
		return result
	end function

end class

//------------------------------------------------------------------------------------
class APSession
	// Documented 7/10/2012
	//- Encapsulates an observing session.
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APSession.Session(n))
  implements NamedObject
  
	private dim index as integer
	private dim last_Index as integer
	private dim last_Obs as APObservation


	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer) // private
		index=n
		last_Index=-999
	end sub

	function GetValueAsString(fldName as string) as string
		//- Return the value of the named field as a string.
		return APC_Session_GetValueAsString(index,fldName)
	end function

	function ObjectName() as string // private
		dim d as new Date(Start)
		return d.SQLDate+" starting at "+d.ShortTime
	end function

	function Name() as string
		//- The session's Name field value.
		return APC_Session_GetString(index,"Name")
	end function

	function Selected() as boolean
		//- Returns TRUE if the observation database window is open and this session is visible and selected in the list of sessions.
		//- The session will not be visible if it is excluded via the restrictions at the bottom-left of the
		//- observations list on the window.
		return APC_Session_Selected(index)
	end function

	function Visible() as boolean
		//- Returns TRUE if the observation database window is open and this session is visible in the list of sessions.
		//- The session will not be visible if it is excluded via the restrictions at the bottom-left of the
		//- observations list on the window.
		return APC_Session_Displayed(index)
	end function

	function Start() as double
		//- The session's Start time value (date/time value in seconds. Can also assign Date objects).
		return APC_Session_GetDouble(index,"Start")
	end function

	sub Start(assigns dt as double)
		//- Note: The actual start time will be adjusted by the rules set in observation preferences.
		APC_Session_SetDouble(index,"Start",dt)
	end sub

	function Finish() as double
		//- The session's Finish time value (date/time value in seconds. Can also assign Date objects).
		return APC_Session_GetDouble(index,"Finish")
	end function

	sub Finish(assigns dt as double)
		//- Note: The actual finish time will be adjusted by the rules set in observation preferences.
		APC_Session_SetDouble(index,"Finish",dt)
	end sub

	function Notes() as string
		//- The session's Notes field value.
		return APC_Session_GetString(index,"Notes")
	end function

	sub Notes(assigns s as string)
		APC_Session_SetString(index,"Notes",s)
	end sub

	function Observer() as string
		//- The session's Observer field value.
		return APC_Session_GetString(index,"Observer")
	end function

	sub Observer(assigns s as string)
		APC_Session_SetString(index,"Observer",s)
	end sub

	function Seeing() as string
		//- The session's Seeing field value.
		return APC_Session_GetString(index,"Seeing")
	end function

	sub Seeing(assigns s as string)
		APC_Session_SetString(index,"Seeing",s)
	end sub

	function Transparency() as string
		//- The session's Transparency field value.
		return APC_Session_GetString(index,"Transparency")
	end function

	sub Transparency(assigns s as string)
		APC_Session_SetString(index,"Transparency",s)
	end sub

	function Site() as string
		//- The session's Site field value.
		return APC_Session_GetString(index,"Site")
	end function

	sub Site(assigns s as string)
		APC_Session_SetString(index,"Site",s)
	end sub

	function Ended() as boolean
		//- The session's Ended status field value.
		return APC_Session_GetBoolean(index,"Ended")
	end function

	sub Ended(assigns b as boolean)
		APC_Session_SetBoolean(index,"Ended",b)
	end sub

	function nObservations() as integer
		//- Number of observations associated with this session.
		return APC_Session_Get_nObs(index)
	end function

	function Observation(n as integer) as APObservation
		//- Return the n-th observation associated with this session, n = 1, ..., nObservations.
		if n=last_Index then return last_Obs
		last_Index=n
		last_Obs=nil
		dim nidx as integer=APC_Session_Get_Obs(index,n) // Return index of nth observation
		if nidx<0 then return nil
		last_Obs=APObservation.APC_GetNewObservation(nidx)
		return last_Obs
	end function

	function nUserFields() as integer
		//- Return the number of user-fields associated with this session.
		return APUserField.nUserFields(-1,index,-1,APUserField.ufnit_Session)
	end function

	function UserField(n as integer) as APUserField
		//- Return the n-th user-field for this session, n = 1, ..., nUserFields.
		return APUserField.UserField(-1,index,-1,APUserField.ufnit_Session,n)
	end function

	function UserField(title as string, optional createIfMissing as boolean = true) as APUserField
		//- Return the user-field for this session with the given title. 
		//- If createIfMissing is true and the user-field doesn't exist, then create it and return it, otherwise return nil if createIfMissing is false.
		return APUserField.UserField(-1,index,-1,APUserField.ufnit_Session,title,createIfMissing)
	end function

	function AddUserField(title as string) as APUserField
		//- Add a new user-field entry to the Session, and return its APUserField object
		//- Note: This only inserts a new item with the given title. You will need to change
		//- The value of the returned APUserField. Also, it does not create a definition for
		//- 'title' - for that you will need to use the corresponding NewUserFieldDefinition() 
		//- method.
		return APUserField.AddField(-1,index,-1,APUserField.ufnit_Session,title)
	end function
	
	function DeleteUserField(title as string) as boolean
		//- Delete an existing user-field entry of the Session.
		//- Note: This only deletes an existing item with the given title, not the definition
		//- (if one exists). Use the corresponding DeleteUserFieldDefinition() method to
		//- delete the underlying definition.
		//- Return TRUE if found and deleted.
		return APUserField.DeleteField(-1,index,-1,APUserField.ufnit_Session,title)
	end function

// Shared methods

	shared function Count() as integer
		//- The total number of sessions in the observation database.
		return APC_Session_Count
	end function

	shared function Session(n as integer) as APSession
		//- Return the n-th session in the observation database, n = 1, ..., APSession.Count.
		if n>=1 and n<=APC_Session_Count then
			return new APSession(n-1)
		else
			return nil
		end if
	end function

	shared function Session(obs as APObservation) as APSession
		//- Return the session associated with the given observation.
		dim n as integer
		n=APC_Session_ForDate(obs.LocalDateTime)
		if n>=0 and n<APC_Session_Count then
			return new APSession(n)
		else
			return nil
		end if
	end function
	
	shared function SelectedSessions() as APSession()
  	//- Returns a list of sessions selected in the observation database window.
  	//- An empty list is returned if the observation database window is not open, or if no
  	//- sessions are selected.
  	dim n() as integer = APC_Obs_SelectedSessions
  	dim s(-1) as APSession
  	for i as integer = 0 to ubound(n)
  		s.Append new APSession(n(i))
  	next
  	return s
  end function
  
	shared function NewSession(startDT as double) as APSession
		//- Create a new session starting at the given time, and add it to the database.
		//- Note: The actual start time will be adjusted by the rules set in observation preferences.
		//- Warning: If a new session is added, any APSession objects should be disposed of, since
		//- the order might change (unless the startTime is greater than that of any other APSession).
		dim n as integer = APC_Session_New(startDT)
		if n>=0 then return new APsession(n) else return nil
	end function

	shared function nUserFieldDefinitions() as integer
		//- Return number of Session user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Session)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Session user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Session,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Session user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Session,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Session,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Session,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Session,title,deleteValues)
  end function
  
  shared function Sessions( ) as APSession()
  	//- Return an array of all sessions
  	dim s(-1) as APSession
  	for i as integer = 1 to Count
  		s.Append Session(i)
  	next
  	return s
  end function
  
  shared function Choose(optional multiple as boolean = false) as APSession()
		//- Use a dialog to select one or more sessions from a list of all sessions.
		//- If multiple is true, allow selecting zero or more sessions.
		//- If multiple is false, allow selection of a single session.
		//- If the Cancel button is used (or the dialog closed), or no session is selected, 
		//- then an empty array is returned.
	
		dim rlist() as NamedObject = APSession.Sessions
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,"Session")
		dim result() as APSession
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = APSession(r(i))
		next
		return result
	end function

end class

//------------------------------------------------------------------------------------
class APObservationAttachment
	// Documented 7/10/2012
	//- Encapsulates an observation attachment.
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APObservation.Attachment(n))
	implements NamedObject
	
	private dim index as integer
	private dim natt as integer
	
	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(idx as integer, optional n as integer = -1) // private
		index=idx
		if n<0 then natt=APC_Obs_NewAttachment(index) else natt=n
	end sub
	
	function Path() as string
		//- Path to the attached file.
		return APC_Obs_GetString(index,"Attachment.Path",natt)
	end function
	
	sub Path(assigns v as string)
		APC_Obs_SetString(index,"Attachment.Path",natt,v)
	end sub

	function Description() as string
		//- Description of the attachment.
		return APC_Obs_GetString(index,"Attachment.Description",natt)
	end function
	
	sub Description(assigns v as string)
		APC_Obs_SetString(index,"Attachment.Description",natt,v)
	end sub

	function ObjectName() as string // private
		return Description
	end function
	
	function nUserFields() as integer
		//- Return the number of user-fields associated with this attachment.
		return APUserField.nUserFields(-1,index,natt,APUserField.ufnit_ObsAttachment)
	end function

	function UserField(n as integer) as APUserField
		//- Return the n-th user-field for this attachment, n = 1, ..., nUserFields.
		return APUserField.UserField(-1,index,natt,APUserField.ufnit_ObsAttachment,n)
	end function

	function UserField(title as string, optional createIfMissing as boolean = true) as APUserField
		//- Return the user-field for this attachment with the given title. 
		//- If createIfMissing is true and the user-field doesn't exist, then create it and return it, otherwise return nil if createIfMissing is false.
		return APUserField.UserField(-1,index,natt,APUserField.ufnit_ObsAttachment,title,createIfMissing)
	end function

	function AddUserField(title as string) as APUserField
		//- Add a new user-field entry to the observation attachment, and return its APUserField object
		//- Note: This only inserts a new item with the given title. You will need to change
		//- The value of the returned APUserField. Also, it does not create a definition for
		//- 'title' - for that you will need to use the corresponding NewUserFieldDefinition() 
		//- method.
		return APUserField.AddField(-1,index,natt,APUserField.ufnit_ObsAttachment,title)
	end function

	function DeleteUserField(title as string) as boolean
		//- Delete an existing user-field entry of the observation attachment.
		//- Note: This only deletes an existing item with the given title, not the definition
		//- (if one exists). Use the corresponding DeleteUserFieldDefinition() method to
		//- delete the underlying definition.
		//- Return TRUE if found and deleted.
		return APUserField.DeleteField(-1,index,-1,APUserField.ufnit_ObsAttachment,title)
	end function

  // Shared methods
  
	shared function nUserFieldDefinitions() as integer
		//- Return number of Observation Attachment user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_ObsAttachment)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Observation Attachment user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_ObsAttachment,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Observation Attachment user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_ObsAttachment,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_ObsAttachment,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_ObsAttachment,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_ObsAttachment,title,deleteValues)
  end function
  
end class

//------------------------------------------------------------------------------------
class APObservation
	// Documented 7/11/2012
	//- Encapsulates an observation.
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APPlanObject.Observation(n))
  implements NamedObject
  implements RADecObject
  
	private dim cindex as integer
	private dim attachments(-1) as APObservationAttachment
	private dim attachmentsdone as boolean

	const obstype_Generic = 0
	const obstype_AAVSO = 1

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer) // private
		cindex=n
	end sub
	
	function Index() as integer
		//- Returns the index of the observation in the database. i.e. if you used obs=APObservation.Get(71) to retrieve
		//- the observation, then obs.Index would be 71.
		return cindex+1
	end function
	
	function GetValueAsString(fldName as string, optional idx as integer = 0) as string
		//- Get the value of an observation field as a string using the field name (and index if it is an array type, e.g. Telescope).
		return APC_Obs_GetValueAsString(cindex,fldName,idx)
	end function

	function Selected() as boolean
		//- Returns TRUE if the observation database window is open and this observation is visible and selected in the list.
		//- The observation will not be visible if it is excluded via the restrictions at the bottom-left of the
		//- observations list on the window.
		return APC_Obs_Selected(cindex)
	end function

	function Visible() as boolean
		//- Returns TRUE if the observation database window is open and this observation is visible in the list.
		//- The observation will not be visible if it is excluded via the restrictions at the bottom-left of the
		//- observations list on the window.
		return APC_Obs_Displayed(cindex)
	end function

	function ObjectName() as string // private
		dim d as new Date(LocalDateTime)
		return d.SQLDateTime+" - "+ID
	end function

	function DateTime() as double
	  Deprecate("APObservation.DateTime","APObservation.LocalDateTime")
		return APC_Obs_GetDouble(cindex,"LocalDateTime",0)
	end function

	sub DateTime(assigns v as double)
	  Deprecate("APObservation.DateTime","APObservation.LocalDateTime")
		APC_Obs_SetDouble(cindex,"LocalDateTime",-1,v)
	end sub

	function LocalDateTime() as double
		//- The observation local date/time in seconds. You can also assign or use a Date object.
		return APC_Obs_GetDouble(cindex,"LocalDateTime",0)
	end function

	sub LocalDateTime(assigns v as double)
		APC_Obs_SetDouble(cindex,"LocalDateTime",-1,v)
	end sub

	function UTDateTime() as double
		//- The observation UT date/time in seconds. You can also assign or use a Date object.
		return APC_Obs_GetDouble(cindex,"UTDateTime",0)
	end function

	sub UTDateTime(assigns v as double)
		APC_Obs_SetDouble(cindex,"UTDateTime",-1,v)
	end sub

	function JulianDate() as double
		//- The UT date/time as a Julian date.
		return APC_Obs_GetDouble(cindex,"JulianDate",0)
	end function

	sub JulianDate(assigns v as double)
		APC_Obs_SetDouble(cindex,"JulianDate",-1,v)
	end sub

	function ID() as string
		//- The ID of the observed object.
		return APC_Obs_GetString(cindex,"ID",0)
	end function

	sub ID(assigns v as string)
		APC_Obs_SetString(cindex,"ID",-1,v)
	end sub

	function Annotations() as Annotation()
		//- Returns an array of Annotations (possibly empty) for this observation.
		return Annotation.ForID(ID)
	end function

	function Name() as string
		//- The Name of the observed object.
		return APC_Obs_GetString(cindex,"Name",0)
	end function

	sub Name(assigns v as string)
		APC_Obs_SetString(cindex,"Name",-1,v)
	end sub

	function Notes() as string
		//- The Notes for the observed object.
		return APC_Obs_GetString(cindex,"Notes",0)
	end function

	sub Notes(assigns v as string)
		APC_Obs_SetString(cindex,"Notes",-1,v)
	end sub

	function Constellation() as string
		//- The constellation (abbreviation) of the observed object.
		return APC_Obs_GetString(cindex,"Constellation",0)
	end function

	function Type() as string
		//- The Type of the observed object.
		return APC_Obs_GetString(cindex,"Type",0)
	end function

	sub Type(assigns v as string)
		APC_Obs_SetString(cindex,"Type",-1,v)
	end sub

	function Plan() as string
		//- The name of the plan document from where the observation was logged.
		return APC_Obs_GetString(cindex,"Plan",0)
	end function

	sub Plan(assigns v as string)
		APC_Obs_SetString(cindex,"Plan",-1,v)
	end sub

	function RA() as double
		//- The Right Ascension of the observed object.
		return APC_Obs_GetDouble(cindex,"RA",0)
	end function

	sub RA(assigns v as double)
		APC_Obs_SetDouble(cindex,"RA",-1,v)
	end sub

	function Dec() as double
		//- The Declination of the observed object.
		return APC_Obs_GetDouble(cindex,"Dec",0)
	end function

	sub Dec(assigns v as double)
		APC_Obs_SetDouble(cindex,"Dec",-1,v)
	end sub

	function nResources() as integer
		//- The number of recorded resource combinations for this observation.
		return APC_Obs_GetInteger(cindex,"nCombos",0)
	end function

	function Rating(optional n as integer = 1) as integer
		//- Return the numerical Rating for resource combination n (n = 1...nResources).
		return APC_Obs_GetInteger(cindex,"Rating",n-1)
	end function

	function RatingString(optional n as integer = 1) as string
		//- Return the Rating as a string for resource combination n (n = 1...nResources).
		return APC_Obs_GetString(cindex,"RatingString",n-1)
	end function

	sub Rating(optional n as integer = 1, assigns v as integer)
		//- Set the numerical Rating for resource combination n (n = 1...nResources).
		APC_Obs_SetInteger(cindex,"Rating",n-1,v)
	end sub

	function OpticalAid(optional n as integer = 1) as string
		//- Return the Optical Aid for resource combination n (n = 1...nResources).
		return APC_Obs_GetString(cindex,"Aid",n-1)
	end function

	sub OpticalAid(optional n as integer = 1, assigns v as string)
		//- Set the Optical Aid for resource combination n (n = 1...nResources).
		APC_Obs_SetString(cindex,"Aid",n-1,v)
	end sub

	function VisualAid(optional n as integer = 1) as string
		Deprecate("APObservation.VisualAid(n)","APObservation.OpticalAid(n)")
		return OpticalAid(n)
	end function

	sub VisualAid(optional n as integer = 1, assigns v as string)
		Deprecate("APObservation.VisualAid(n)","APObservation.OpticalAid(n)")
		OpticalAid(n)=v
	end sub

	function Found(optional n as integer = 0) as boolean
		//- Get the Observed status of the nth resource combination, n = 1...nResources
		//- if n<=0 (default) then TRUE will be returned if any of the resource combinations has 
		//- Observed=TRUE, or FALSE otherwise.
		return APC_Obs_GetBoolean(cindex,"Found",n-1)
	end function

	sub Found(optional n as integer = 1, assigns v as boolean)
		//- Set the Observed status of the nth resource combination, n = 1...nResources
		APC_Obs_SetBoolean(cindex,"Found",n-1,v)
	end sub

  function Images() as Image()
		//- Return a list of images associated with this object
		dim idx() as integer = APC_Obs_GetImageList(cindex)
		dim img(-1) as Image
		for i as integer = 0 to idx.Ubound
			img.Append new Image(idx(i)+1)
		next
		return img
	end function

	function Eyepiece(optional n as integer = 1) as string
		//- Return the Eyepiece for resource combination n (n = 1...nResources).
		return APC_Obs_GetString(cindex,"Eyepiece",n-1)
	end function

	sub Eyepiece(optional n as integer = 1, assigns v as string)
		//- Set the Eyepiece for resource combination n (n = 1...nResources).
		APC_Obs_SetString(cindex,"Eyepiece",n-1,v)
	end sub

	function Imager(optional n as integer = 1) as string
		//- Return the Imager for resource combination n (n = 1...nResources).
		return APC_Obs_GetString(cindex,"Imager",n-1)
	end function

	sub Imager(optional n as integer = 1, assigns v as string)
		//- Set the Imager for resource combination n (n = 1...nResources).
		APC_Obs_SetString(cindex,"Imager",n-1,v)
	end sub

	function Filter(optional n as integer = 1) as string
		//- Return the Filter for resource combination n (n = 1...nResources).
		return APC_Obs_GetString(cindex,"Filter",n-1)
	end function

	sub Filter(optional n as integer = 1, assigns v as string)
		//- Set the Filter for resource combination n (n = 1...nResources).
		APC_Obs_SetString(cindex,"Filter",n-1,v)
	end sub

	function Telescope(optional n as integer = 1) as string
		//- Return the Telescope for resource combination n (n = 1...nResources).
		return APC_Obs_GetString(cindex,"Telescope",n-1)
	end function

	sub Telescope(optional n as integer = 1, assigns v as string)
		//- Set the Telescope for resource combination n (n = 1...nResources).
		APC_Obs_SetString(cindex,"Telescope",n-1,v)
	end sub
	
	function Magnification(optional n as integer = 1) as double
		//- Return the Magnification for resource combination n (n = 1...nResources).
		return APC_Obs_GetDouble(cindex,"Magnification",n-1)
	end function

	function ActualFoV(optional n as integer = 1) as double
		//- Return the Actual field of view for resource combination n (n = 1...nResources).
		return APC_Obs_GetDouble(cindex,"FoV",n-1)
	end function

	function nUserFields() as integer
		//- Return the number of user-fields associated with this observation.
		return APUserField.nUserFields(-1,cindex,-1,APUserField.ufnit_Observation)
	end function

	function UserField(n as integer) as APUserField
		//- Return the n-th user-field for this observation, n = 1, ..., nUserFields.
		return APUserField.UserField(-1,cindex,-1,APUserField.ufnit_Observation,n)
	end function

	function UserField(title as string, optional createIfMissing as boolean = true) as APUserField
		//- Return the user-field for this observation with the given title. 
		//- If createIfMissing is true and the user-field doesn't exist, then create it and return it, 
		//- otherwise return nil if createIfMissing is false.
		return APUserField.UserField(-1,cindex,-1,APUserField.ufnit_Observation,title,createIfMissing)
	end function

	function AddUserField(title as string) as APUserField
		//- Add a new user-field entry to the observation, and return its APUserField object
		//- Note: This only inserts a new item with the given title. You will need to change
		//- The value of the returned APUserField. Also, it does not create a definition for
		//- 'title' - for that you will need to use the corresponding NewUserFieldDefinition() 
		//- method.
		return APUserField.AddField(-1,cindex,-1,APUserField.ufnit_Observation,title)
	end function

	function DeleteUserField(title as string) as boolean
		//- Delete an existing user-field entry of the observation.
		//- Note: This only deletes an existing item with the given title, not the definition
		//- (if one exists). Use the corresponding DeleteUserFieldDefinition() method to
		//- delete the underlying definition.
		//- Return TRUE if found and deleted.
		return APUserField.DeleteField(-1,cindex,-1,APUserField.ufnit_Observation,title)
	end function

	function nAttachments() as integer
		//- Return the number of attachments for this observation.
		if not attachmentsdone then
			dim n,i as integer
			
			n=val(APC_Obs_GetString(cindex,"nAttachments",0))
			attachmentsdone=true
			redim attachments(n-1)
			for i=0 to n-1
				attachments(i)=new APObservationAttachment(cindex,i)
			next
		end if
		return ubound(attachments)+1
	end function
	
	function Attachment(n as integer) as APObservationAttachment
		//- Return the n-th attachment for this observation, n=1...nAttachments.
		if n<1 or n>nAttachments then return nil else return attachments(n-1)
	end function

	function AddAttachment( ) as APObservationAttachment
		//- Add a new attachment to the observation, and return its object (which you can then populate).
		dim att as new APObservationAttachment(cindex)
		attachments.Append att
		return att
	end function
	
	sub DeleteAttachment(n as integer)
		//- Delete the n-th attachment for this observation, n=1...nAttachments.
		APC_Obs_DeleteAttachment(cindex,n)
		attachmentsdone=false
	end sub

// Shared methods

	shared dim last_Index as integer // private
	shared dim last_Obs as APObservation // private

	shared function Count() as integer
		//- Total number of observations in the database.
		return APC_Obs_Count
	end function

	shared function Observation(n as integer) as APObservation
		//- Return the n-th observation in the observation database, n = 1...APObservation.Count.
		if n<1 or n>APC_Obs_Count then return nil
		if n=last_Index then return last_Obs
		last_Index=n
		last_Obs=APC_GetNewObservation(n-1)
		return last_Obs
	end function

	shared function NewObservation(dt as double, optional otype as integer = 0) as APObservation
		//- Create and return a new observation in the database. 
		//- dt is the local date/time in seconds (or a suitable Date object) of the observation. 
		//- otype is the observation type (use the obstype_ constants). 
		//- Once the observation object has been returned, it should be populated with values (e.g. ID, etc.).
		return Observation(APC_CreateObservation(dt,otype))
	end function

	shared function nUserFieldDefinitions() as integer
		//- Return number of Observation user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Observation)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Observation user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Observation,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Observation user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Observation,title)
	end function
	
  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Observation,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Observation,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Observation,title,deleteValues)
  end function
  
  shared function SelectedObservations() as APObservation()
  	//- Returns a list of observations selected in the observation database window.
  	//- An empty list is returned if the observation database window is not open, or if no
  	//- observations are selected.
  	dim n() as integer = APC_Obs_SelectedObservations
  	dim s(-1) as APObservation
  	for i as integer = 0 to ubound(n)
  		s.Append new APObservation(n(i))
  	next
  	return s
  end function
  
  shared function APC_GetNewObservation(n as integer) as APObservation  // private
  	select case APC_Obs_GetInteger(n,"ObsType",0)
		case APObservation.obstype_Generic
			return new APObservation(n)
		case APObservation.obstype_AAVSO
			return new APAAVSOObservation(n)
		else
			return nil
		end select
  end function
  
  shared function Observations( ) as APObservation()
  	//- Return an array of all observations
  	dim s(-1) as APObservation
  	for i as integer = 1 to Count
  		s.Append Observation(i)
  	next
  	return s
  end function
  
  shared function Choose(optional multiple as boolean = false) as APObservation()
		//- Use a dialog to select one or more observations from a list of all observations.
		//- If multiple is true, allow selecting zero or more observations.
		//- If multiple is false, allow selection of a single observation.
		//- If the Cancel button is used (or the dialog closed), or no observation is selected, 
		//- then an empty array is returned.
	
		dim rlist() as NamedObject = APObservation.Observations
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,"Observation")
		dim result() as APObservation
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = APObservation(r(i))
		next
		return result
	end function

end class

//------------------------------------------------------------------------------------
class APAAVSOObservation
	// Documented 7/11/2012
	inherits APObservation
	//- Encapsulates an AAVSO observation.
	//- WARNING: As of V2.1, DO NOT use this class or object type.
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APPlanObject.Observation(n))

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
end class

//------------------------------------------------------------------------------------
class APPlanObject
	// Documented 7/11/2012
	//- Encapsulate an object in a plan document.
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APPlan.Obj(n))
	implements NamedObject
	implements RADecObject
	
	private dim nPlan as integer
	private dim nObj as integer
	public dim flag as boolean // private
	private dim last_Index as integer
	private dim last_Obs as APObservation

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(np as integer, n as integer) // private
		nPlan=np
		nObj=n
		last_Index=-999
	end sub
	
	function ObjectName() as string // private
		if Name<>"" then return ID+" - "+Name else return ID
	end function

	function Plan() as APPlan
		//- Return the plan document containing this object.
		return Plan(nPlan)
	end function
	
	function ObjNumber() as integer // private
		return nObj
	end function

	function GetValueAsString(fldName as string) as string
		//- Return the value of a field by name.
		return APC_Obj_GetValueAsString(nPlan,nObj,fldName)
	end function

	function ID() as string
		return APC_Obj_GetString(nPlan,nObj,"ID")
	end function

	sub ID(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"ID",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Name() as string
		return APC_Obj_GetString(nPlan,nObj,"Name")
	end function

	sub Name(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"Name",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Components() as string
		return APC_Obj_GetString(nPlan,nObj,"Components")
	end function

	sub Components(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"Components",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function CommonName() as string
		//- Return the common name for this object, or an empty string if not found.
		return APC_Obj_GetString(nPlan,nObj,"CommonName")
	end function

	function Notes() as string
		return APC_Obj_GetString(nPlan,nObj,"User Notes")
	end function

	sub Notes(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"User Notes",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function UserNotes() as string
		return APC_Obj_GetString(nPlan,nObj,"User Notes")
	end function

	sub UserNotes(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"User Notes",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function CatalogNotes() as string
		return APC_Obj_GetString(nPlan,nObj,"Cat Notes")
	end function

	function Annotations() as Annotation()
		//- Returns an array of Annotations (possibly empty) for this object
		return Annotation.ForID(ID)
	end function

	function RA() as double
		return APC_Obj_GetDouble(nPlan,nObj,"RA")
	end function

	function RADec() as string
		//- Returns the Right Ascension and Declination of the object in the format:
		//- HHMMSS+DDMM.
		return APC_Obj_Get_RADec(nPlan,nObj)
	end function

	function RAFormatted(optional extended as boolean = false, optional format as string = "") as string
		//- Returns the Right Ascension (0 through 23.99999 hours) of the object, as a formatted string. 
		//- e.g. 12:34:56. If the optional extended parameter is true, then two decimal places of seconds are shown. E.g. 12:23:45.67. 
		//- The optional format parameter allows more control over the final format. 
		//- The value of the parameter is in two parts: the first can be h, hm, or hms, 
		//- depending on whether you want hours, minutes and seconds in the result. 
		//- The second part is a single character which is the delimiter between the h, m, and s parts. 
		//- This can be empty (for no delimiter), “a” for using the letters “h”, “m” and “s”, or any other single character (e.g. “:” or “-“).
		return APC_Obj_Get_RAFormatted(nPlan,nObj,extended,format)
	end function

	sub RA(assigns v as double)
		APC_Obj_SetDouble(nPlan,nObj,"RA",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Dec() as double
		return APC_Obj_GetDouble(nPlan,nObj,"Dec")
	end function

	function DecFormatted(optional extended as boolean = false, optional format as string = "") as string
		//- Returns the Declination (-90° through 90°) of the object, as a formatted string. e.g. +12°45'13". 
		//- If the optional extended parameter is true, then two decimal places of arcseconds are shown. e.g. +12°45'13.81".
		//- The optional format parameter allows more control over the final format. 
		//- The value of the parameter is in two parts: the first can be d, dm, or dms, 
		//- depending on whether you want degrees, minutes and seconds in the result. 
		//- Precede this with "+" if you want positive declination values to have a "+" sign. 
		//- The second part is a single character, which is the delimiter between the d, m, and s parts. 
		//- This can be empty (for no delimiter), "x" for using the symbols (°, ' and "), "a" for using ("d", "m" and "s"), 
		//- or any other single character (e.g. ":" or "-").
		return APC_Obj_Get_DecFormatted(nPlan,nObj,extended,format)
	end function

	sub Dec(assigns v as double)
		APC_Obj_SetDouble(nPlan,nObj,"Dec",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub
	
	function GalacticLatitude() as double
		//- Returns the current galactic latitude of the object
		return APC_Obj_GetDouble(nPlan,nObj,"GLat")
	end function

	function GalacticLongitude() as double
		//- Returns the current galactic longitude of the object
		return APC_Obj_GetDouble(nPlan,nObj,"GLong")
	end function

	function EclipticLatitude() as double
		//- Returns the current ecliptic latitude of the object
		return APC_Obj_GetDouble(nPlan,nObj,"ELat")
	end function

	function EclipticLongitude() as double
		//- Returns the current ecliptic longitude of the object
		return APC_Obj_GetDouble(nPlan,nObj,"ELong")
	end function

	function AirMass() as double
		//- Returns the current Air Mass of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"AirMass")
	end function

	function Extinction() as double
		//- Returns the current Extinction of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"Extinction")
	end function

	function ApparentMagnitude() as double
		//- Returns the current Apparent Magnitude of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"AppMag")
	end function

	function Altitude() as double
		//- Returns the current Altitude of the object (-90 to +90 degrees).
		return APC_Obj_GetDouble(nPlan,nObj,"Altitude")
	end function

	function Azimuth() as double
		//- Returns the current Azimuth of the object (0 to 360 degrees).
		return APC_Obj_GetDouble(nPlan,nObj,"Azimuth")
	end function

	function Chart() as string
		//- Returns the chart number of the object.
		return APC_Obj_GetString(nPlan,nObj,"Chart")
	end function

	function Catalog() as string
		return APC_Obj_GetString(nPlan,nObj,"Catalogue")
	end function

	sub Catalog(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"Catalogue",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Constellation() as string
		//- Returns the constellation (abbreviation) containing the object.
		return APC_Obj_GetString(nPlan,nObj,"Constellation")
	end function

	function DifficultyIndex() as double
		//- Returns the Difficulty Index of the object (0 to 100). For double stars only.
		return APC_Obj_GetDouble(nPlan,nObj,"DifficultyIndex")
	end function

	function LOC() as double
		//- Returns the Log Object Contrast of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"LOC")
	end function

	function MoonDistance() as double
		//- Return the current angular distance between the object and the moon, in degrees.
		return APC_Obj_GetDouble(nPlan,nObj,"MoonDistance")
	end function

	function SunDistance() as double
		//- Return the current angular distance between the object and the sun, in degrees.
		return APC_Obj_GetDouble(nPlan,nObj,"SunDistance")
	end function
	
	function Images() as Image()
		//- Return a list of images associated with this object
		dim idx() as integer = APC_Obj_GetImageList(nPlan,nObj)
		dim img(-1) as Image
		for i as integer = 0 to idx.Ubound
			img.Append new Image(idx(i)+1)
		next
		return img
	end function

	function Found() as boolean
		//- Returns true if (a) at least one observation exists for this object, and (b) at
		//- least one of those observations has a Found status of TRUE
		return APC_Obj_GetBoolean(nPlan,nObj,"Found")
	end function

	function HourAngle() as double
		//- Returns the current Hour Angle of the object (-12 to +12 hours).
		return APC_Obj_GetDouble(nPlan,nObj,"HourAngle")
	end function

  function ImageCounts() as integer()
  	//- Returns a 7-element array with counts of various types of images:
  	//- ImageCounts(0) = Number of user images
  	//- ImageCounts(1) = Number of 5' images
  	//- ImageCounts(2) = Number of 10' images
  	//- ImageCounts(3) = Number of 30' images
  	//- ImageCounts(4) = Number of 1 deg images
  	//- ImageCounts(5) = Number of 2 deg images
  	//- ImageCounts(6) = Number of 5 deg images
		return APC_Obj_GetIntegerArray(nPlan,nObj,"Images")
	end function

	function LordRating() as string
		//- Returns the Lord Rating of the object (double stars only).
		return APC_Obj_GetString(nPlan,nObj,"LordRating")
	end function

	function Magnitude() as double
		return APC_Obj_GetDouble(nPlan,nObj,"Magnitude")
	end function

	sub Magnitude(assigns v as double)
		APC_Obj_SetDouble(nPlan,nObj,"Magnitude",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Magnitude2() as double
		return APC_Obj_GetDouble(nPlan,nObj,"Magnitude2")
	end function

	sub Magnitude2(assigns v as double)
		APC_Obj_SetDouble(nPlan,nObj,"Magnitude2",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Probability() as double
		//- Return the probability of detection in the current telescope (stellar objects only).
		//- Returns -1 if a telescope is not selected in the plan or if Magnitude is not specified or is >30.
		//- <2% is returned as 0, >98% is returned as 100
		return APC_Obj_GetDouble(nPlan,nObj,"Prob")
	end function

	function Probability2() as double
		//- Return the probability of detection of the secondary in the current telescope (double stars only).
		//- Returns -1 if a telescope is not selected in the plan or if Magnitude2 is not specified or is >30.
		//- <2% is returned as 0, >98% is returned as 100
		return APC_Obj_GetDouble(nPlan,nObj,"Prob")
	end function
	
	function TelescopeDistance() as double
		//- Return the current angular distance between the object and the pointing coordinates of the telescope, in degrees.
		//- Returns -1 if a telescope is not connected.
		return APC_Obj_GetDouble(nPlan,nObj,"TDist")
	end function	

	function PosAngle() as integer
		return APC_Obj_GetInteger(nPlan,nObj,"PosAngle")
	end function

	sub PosAngle(assigns v as integer)
		APC_Obj_SetInteger(nPlan,nObj,"PosAngle",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub
	
	function IsInAssociation() as boolean
		//- Returns TRUE if the object is part of an association
		return APC_Obj_GetInteger(nPlan,nObj,"Association")>0
	end function
	
	function IsAssociatedWith(obj as APPlanObject) as boolean
		//- Returns TRUE if the object is part of the same association as obj.
		//- Returns FALSE if the object is not part of the same association as obj,
		//-  or the object or obj is not part of an association.
		dim n as integer = APC_Obj_GetInteger(nPlan,nObj,"Association")
		return n>0 and n=APC_Obj_GetInteger(obj.nPlan,obj.nObj,"Association")
	end function
	
	function ODM() as integer
		//- Returns the Optimum Detection Magnification of the object.
		return APC_Obj_GetInteger(nPlan,nObj,"ODM")
	end function

	function Rating() as double
		//- Returns double value of average rating
		return APC_Obj_GetDouble(nPlan,nObj,"Rating")
	end function

	function RatingString() as string
		//- Returns closest string representation of average rating
		return APC_Obj_GetString(nPlan,nObj,"RatingString")
	end function

	function Rise() as double
		//- Returns the Rise time of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"Rise")
	end function

	function Transit() as double
		//- Returns the Transit time of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"Transit")
	end function

	function TransitDate() as double
		//- Returns the next Transit Date of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"TransitDate")
	end function

	function Set() as double
		//- Returns the Set time of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"Set")
	end function

	function Selected() as boolean
		//- Return true if the object is selected on the object list. Set to true to select the object.
		return APC_Obj_Get_Selected(nPlan,nObj)
	end function

	sub Selected(assigns v as boolean)
		APC_Obj_Set_Selected(nPlan,nObj,v)
	end sub
	
	function Chosen(which as integer) as boolean
		//- Returns TRUE if which equals one of the Dialog.oc_ constants, and
		//- the object complies with that constant's meaning. e.g. if which = Dialog.SelectedObjects
		//- then TRUE is returned only of this object is selected in the plan's object list.
		//- Note: you can also OR or add together multiple Dialog.oc_ constants. In this case, TRUE
		//- is returned if any of those constants are applicable.
		if (which and Dialog.oc_All)<>0 then return true
		if (which and Dialog.oc_Selected)<>0 and Selected then return true
		if (which and Dialog.oc_Highlighted)<>0 and IsHighlighted then return true
		if (which and Dialog.oc_Unselected)<>0 and not Selected then return true
		if (which and Dialog.oc_Unhighlighted)<>0 and not IsHighlighted then return true
		return false
	end function

	function Separation() as double
		return APC_Obj_GetDouble(nPlan,nObj,"Separation")
	end function

	sub Separation(assigns v as double)
		APC_Obj_SetDouble(nPlan,nObj,"Separation",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Period() as double
		 return APC_Obj_GetDouble(nPlan,nObj,"Period")
	end function

	sub Period(assigns v as double)
		APC_Obj_SetDouble(nPlan,nObj,"Period",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Size() as string
		 return APC_Obj_GetString(nPlan,nObj,"Size")
	end function

	sub Size(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"Size",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function Size1() as double
		//- The size of the longer axis of a deep-sky object, in arcminutes.
		return APC_Obj_GetDouble(nPlan,nObj,"Size1")
	end function

	function Size2() as double
		//- The size of the shorter axis of a deep-sky object, in arcminutes.
		return APC_Obj_GetDouble(nPlan,nObj,"Size2")
	end function

	function SlewTo( ) as integer
		//- Slew to the object’s RA and Dec. Returns a status value:
		//- -1 = telescope is not connected or does not have go-to slewing capabilities. 
		//-  0 = slew successful.
		//-  2 = below horizon (altitude < 0°)
		//-  3 = outside slewing limits (see the mount settings for the telescope).
		//-  4 = Blocked by user-defined horizon.
		return APC_SlewTo(nPlan,nObj)
	end function

	function Spectral() as string
		return APC_Obj_GetString(nPlan,nObj,"Spectral")
	end function

	sub Spectral(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"Spectral",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function SurfaceBrightness() as double
		//- Returns the Surface Brightness of the object.
		return APC_Obj_GetDouble(nPlan,nObj,"SurfaceBrightness")
	end function

	function Type() as string
		 return APC_Obj_GetString(nPlan,nObj,"Type")
	end function

	sub Type(assigns v as string)
		APC_Obj_SetString(nPlan,nObj,"Type",v)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function ForceHighlight() as boolean
		//- Get/Set the "force highlighted" status of an object.
		return APC_Obj_Get_ForceHighlight(nPlan,nObj)
	end function

	sub ForceHighlight(assigns v as boolean)
		APC_Obj_Set_ForceHighlight(nPlan,nObj,v)
	end sub

	function nUserFields() as integer
		//- Return the number of user-fields associated with this object.
		return APUserField.nUserFields(nPlan,nObj,-1,APUserField.ufnit_Object)
	end function

	function UserField(n as integer) as APUserField
		//- Return the n-th user-field for this object, n = 1, ..., nUserFields.
		return APUserField.UserField(nPlan,nObj,-1,APUserField.ufnit_Object,n)
	end function

	function UserField(title as string, optional createIfMissing as boolean = true) as APUserField
		//- Return the user-field for this object with the given title. 
		//- If createIfMissing is true and the user-field doesn't exist, then create it and return it, otherwise return nil if createIfMissing is false.
		return APUserField.UserField(nPlan,nObj,-1,APUserField.ufnit_Object,title,createIfMissing)
	end function

	function AddUserField(title as string) as APUserField
		//- Add a new user-field entry to the plan object, and return its APUserField object
		//- Note: This only inserts a new item with the given title. You will need to change
		//- The value of the returned APUserField. Also, it does not create a definition for
		//- 'title' - for that you will need to use the corresponding NewUserFieldDefinition() 
		//- method.
		return APUserField.AddField(nPlan,nObj,-1,APUserField.ufnit_Object,title)
	end function

	function DeleteUserField(title as string) as boolean
		//- Delete an existing user-field entry of the plan object.
		//- Note: This only deletes an existing item with the given title, not the definition
		//- (if one exists). Use the corresponding DeleteUserFieldDefinition() method to
		//- delete the underlying definition.
		//- Return TRUE if found and deleted.
		return APUserField.DeleteField(nPlan,nObj,-1,APUserField.ufnit_Object,title)
	end function

	function Visible() as string
		//- Return the visibility status of the object.
		return APC_Obj_GetString(nPlan,nObj,"Visible")
	end function

	sub Delete()
		//- Delete this object from the plan document. After doing this, do not access this instance again.
		APC_DeleteObject(nPlan,nObj)
		Plan(nPlan).APC_Plan_ResetHighlighted
	end sub

	function IsVisible() as boolean
		//- Return true if the object is currently visible.
		return Visible="Yes"
	end function

	function IsHighlighted() as boolean
		//- Return true if the object is currently highlighted.
		return APC_Obj_Get_Highlighted(nPlan,nObj)
	end function

	function ClosestStar(mag as double) as APCatalogObject
		//- Find the closest bright star (of magnitude less than mag) to the object.
		APC_ClosestStar(nPlan,nObj,mag)
		if APC_nCatalogFind<=0 then
			return nil
		else
			 return new APCatalogObject(1)
		end if
	end function

	function Eccentricity() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"Eccentricity")
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"Eccentricity")
		else
			return -1.0
		end select
	end function

	sub Eccentricity(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"Eccentricity",v)
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"Eccentricity",v)
		end select
	end sub

	function OrbitalInclination() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"OrbitalInclination")
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"OrbitalInclination")
		else
			return -1.0
		end select
	end function

	sub OrbitalInclination(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"OrbitalInclination",v)
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"OrbitalInclination",v)
		end select
	end sub

	function LongOfAscNode() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"LongOfAscNode")
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"LongOfAscNode")
		else
			return -1.0
		end select
	end function

	sub LongOfAscNode(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"LongOfAscNode",v)
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"LongOfAscNode",v)
		end select
	end sub

	function ArgOfPerihelion() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"ArgOfPerihelion")
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"ArgOfPerihelion")
		else
			return -1.0
		end select
	end function

	sub ArgOfPerihelion(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"ArgOfPerihelion",v)
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"ArgOfPerihelion",v)
		end select
	end sub

	function Epoch() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"Epoch")
		else
			return -1.0
		end select
	end function

	sub Epoch(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"Epoch",v)
		end select
	end sub

	function PerihelionDistance() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"PerihelionDistance")
		else
			return -1.0
		end select
	end function

	sub PerihelionDistance(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"PerihelionDistance",v)
		end select
	end sub

	function DateOfPerihelion() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"DateOfPerihelion")
		else
			return -1.0
		end select
	end function

	sub DateOfPerihelion(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"DateOfPerihelion",v)
		end select
	end sub

	function AbsMag() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"AbsMag")
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"VisualMag")
		else
			return -1.0
		end select
	end function

	sub AbsMag(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"AbsMag",v)
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"VisualMag",v)
		end select
	end sub

	function MagConst() as double
		select case Type
		case "Comet"
			return APC_Obj_Get_Comet(nPlan,nObj,"MagConst")
		else
			return -1.0
		end select
	end function

	sub MagConst(assigns v as double)
		select case Type
		case "Comet"
			APC_Obj_Set_Comet(nPlan,nObj,"MagConst",v)
		end select
	end sub

	function SemiMajorAxis() as double
		select case Type
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"SemiMajorAxis")
		else
			return -1.0
		end select
	end function

	sub SemiMajorAxis(assigns v as double)
		select case Type
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"SemiMajorAxis",v)
		end select
	end sub

	function DateOfEpoch() as double
		select case Type
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"DateOfEpoch")
		else
			return -1.0
		end select
	end function

	sub DateOfEpoch(assigns v as double)
		select case Type
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"DateOfEpoch",v)
		end select
	end sub

	function MeanAnomalyAtEpoch() as double
		select case Type
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"MeanAnomalyAtEpoch")
		else
			return -1.0
		end select
	end function

	sub MeanAnomalyAtEpoch(assigns v as double)
		select case Type
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"MeanAnomalyAtEpoch",v)
		end select
	end sub

	function SlopeParam() as double
		select case Type
		case "Minor"
			return APC_Obj_Get_Minor(nPlan,nObj,"SlopeParam")
		else
			return -1.0
		end select
	end function

	sub SlopeParam(assigns v as double)
		select case Type
		case "Minor"
			APC_Obj_Set_Minor(nPlan,nObj,"SlopeParam",v)
		end select
	end sub

	function nObservations() as integer
		//- Number of observations logged for this object.
		return APC_Obs_CountByID(ID)
	end function

	function Observation(n as integer) as APObservation
		//- Return the n-th observation associated with this object, n = 1, ..., nObservations.
		if n=last_Index then return last_Obs
		last_Index=n
		last_Obs=nil
		dim nidx as integer=APC_Obs_ByID(ID,n) // Return index of nth observation
		if nidx<0 then return nil
		last_Obs=APObservation.APC_GetNewObservation(nidx)
		return last_Obs
	end function

	function NewObservation(dt as double, otype as integer) as APObservation
		//- Create and return a new observation for this object in the database. 
		//- dt is the local date/time in seconds (or a suitable Date object) of the observation. 
		//- otype is the observation type (use the obstype_ constants). 
		dim ob as APObservation = APObservation.NewObservation(dt,otype)
		if ob<>nil then
			ob.ID=ID
			ob.Name=Name
			ob.Type=Type
			ob.RA=RA
			ob.Dec=Dec
			ob.Plan=Plan(nPlan).Name
		end if
		return ob
	end function

  shared sub Associate(obj() as APPlanObject)
  	//- Associate the given objects together in the object list
  	//- Note: All objects must be from the same plan document
  	//- Note: This can reorder the object list!
  	if obj.Ubound<0 then return
  	dim nobj(-1) as integer
  	for i as integer = 0 to obj.Ubound
  		if obj(i).nPlan=obj(0).nPlan then nobj.Append obj(i).nObj-1
  	next
  	if nobj.Ubound>0 then APC_Obj_Associate(obj(0).nPlan,nobj)
  end sub

  shared sub Disassociate(obj() as APPlanObject)
  	//- Disassociate the given objects, if they are associated
  	//- Note: All objects must be from the same plan document
  	if obj.Ubound<0 then return
  	dim nobj(-1) as integer
  	for i as integer = 0 to obj.Ubound
  		if obj(i).nPlan=obj(0).nPlan then nobj.Append obj(i).nObj-1
  	next
  	if nobj.Ubound>=0 then APC_Obj_Disassociate(obj(0).nPlan,nobj)
  end sub
end class

//------------------------------------------------------------------------------------
class APMinorPlanetObject
	// Documented 7/12/2012
	//- Encapsulates minor planet objects retrieved from the ASTORB or MPCORB databases.
	//- Note: Do not construct new instances of this object.
	//- Use the shared methods of the relevant class to retrieve
	//- instances (e.g. APMinorPlanetObject.Get(n, APMinorPlanetObject.mp_ASTORB))
  implements NamedObject
  
  const mp_ASTORB = 0
  //- Use the ASTORB.DAT data set
  const mp_MPCORB = 1
  //- Use the MPCORB.DAT data set
  
  private const mp_Last = 1
  
	dim ID as string
	dim Name as string
	dim SemimajorAxis as double
	dim Eccentricity as double
	dim ArgOfPerihelion as double
	dim LongOfAscNode as double
	dim OrbitalInclination as double
	dim AbsMag as double
	dim SlopeParam as double
	dim MeanAnomalyAtEpoch as double
	dim DateOfEpoch as double
	dim ArcLength as double
	
	dim Diameter as double
	//- Field info from ASTORB database only.
	dim B_V as double
	//- Field info from ASTORB database only.
	dim ObjClass as string
	//- Field info from ASTORB database only.

	dim Origin as string
	//- Either "ASTORB" or "MPCORB", depending on the database or origin.

	private dim jdate as double
	private dim mag as double
	private dim ra as double
	private dim dec as double
	private dim motion as double
	private dim eLat as double
	private dim eLong as double

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer) // private
  	
  end sub
  
  function ObjectName() as string // private
  	if ID<>"" and Name="" then
  		return ID
  	elseif ID="" and Name<>"" then
  		return Name
  	elseif ID<>Name then
  		return ID+": "+Name
  	else
  		return ID
  	end if
  end function
  
	private sub ComputeStuff(jd as double)
		dim ra2 as double
		dim dec2 as double
		dim mag2 as double

		if jd=jdate then return
		jdate=jd
		SolarSystem.MinorPlanetPosition(jdate, Eccentricity, SemimajorAxis, OrbitalInclination, LongOfAscNode, ArgOfPerihelion, DateOfEpoch, AbsMag, SlopeParam, MeanAnomalyAtEpoch, ra, dec, mag)
		SolarSystem.MinorPlanetPosition(jdate+1.0/24.0, Eccentricity, SemimajorAxis, OrbitalInclination, LongOfAscNode, ArgOfPerihelion, DateOfEpoch, AbsMag, SlopeParam, MeanAnomalyAtEpoch, ra2, dec2, mag2)

		motion=AngleBetween(ra,dec,ra2,dec2)
		
		APC_EquatorialToEcliptic(ra,dec,jdate,eLat,eLong)
	end sub

	function Magnitude(jd as double) as double
		//- The computed magnitude at the given Julian date.
		ComputeStuff(jd)
		return mag
	end function

	function RA(jd as double) as double
		//- The computed RA at the given Julian date.
		ComputeStuff(jd)
		return ra
	end function

	function Dec(jd as double) as double
		//- The computed Dec at the given Julian date.
		ComputeStuff(jd)
		return dec
	end function

	function EclipticLatitude(jd as double) as double
		//- The computed ecliptic latitude at the given Julian date.
		ComputeStuff(jd)
		return eLat
	end function

	function EclipticLongitude(jd as double) as double
		//- The computed ecliptic longitude at the given Julian date.
		ComputeStuff(jd)
		return eLong
	end function

	function Motion(jd as double) as double
		//- The computed motion (degrees per hour) at the given Julian date.
		ComputeStuff(jd)
		return motion
	end function

	function AddToPlan(optional nPlan as integer = -1) as APPlanObject
		//- Add the minor planet object to the plan specified by plan number (default is the current plan), and return the corresponding APPlanObject.
		dim n as integer
		Plan(nPlan).APC_Plan_ResetHighlighted
		n=APC_MPAddToPlan(nPlan,Origin, ID, Name, Eccentricity, SemimajorAxis, OrbitalInclination, LongOfAscNode, ArgOfPerihelion, DateOfEpoch, AbsMag, SlopeParam, MeanAnomalyAtEpoch)
		if n<1 then return nil else return Plan(nPlan).Obj(n)
	end function

	function AddToPlan(p as APPlan) as APPlanObject
		//- Add the minor planet object to the plan specified, and return the corresponding APPlanObject. If p=nil then use the current plan document.
		return AddToPlan(APPlan.PlanNumber(p))
	end function
	
	private shared dim apc_n(mp_Last) as integer

	shared function Count(dataSet as integer) as integer
		//- Return the number of objects in the specified minor planet data set (use the mp_ constants). 
		//- This assumes that the data set has been cached. 
		//- If not, use File > Import > Minor Planet Data... and select the ASTORB.DAT or MPCORB.DAT option in order to create the cache.
		if apc_n(dataSet)<0 then
			select case dataSet
			case mp_ASTORB
				apc_n(dataSet)=APC_GetnASTORB()
				if apc_n(dataSet)<=0 then print "ASTORB.cache missing. Please access File->Import->Minor Planet Data... and select the ASTORB.DAT option in order to create the cache."
			case mp_MPCORB
				apc_n(dataSet)=APC_GetnMPCORB()
				if apc_n(dataSet)<=0 then print "MPCORB.cache missing. Please access File->Import->Minor Planet Data... and select the MPCORB.DAT option in order to create the cache."
			else
				return 0
			end select
		end if
		return apc_n(dataSet)
	end function

	shared function nASTORBObjects() as integer
		Deprecate("APMinorPlanetObject.nASTORBObjects","APMinorPlanetObject.Count(mp_ASTORB)")
		return Count(mp_ASTORB)
	end function

	shared function nMPCORBObjects() as integer
		Deprecate("APMinorPlanetObject.nMPCORBObjects","APMinorPlanetObject.Count(mp_MPCORB)")
		return Count(mp_MPCORB)
	end function

	shared function Get(n as integer, dataSet as integer) as APMinorPlanetObject
		//- Get the n-th minor planet object from the specified dataSet (use the mp_ constants), n = 1...Count(dataSet).
		dim id as string
		dim nm as string
		dim cl as string
		dim sma as double
		dim ecc as double
		dim aop as double
		dim loan as double
		dim oi as double
		dim vm as double
		dim sp as double
		dim maae as double
		dim doe as double
		dim al as double
		dim d as double
		dim bv as double
		dim ob as APMinorPlanetObject
		
		if n<1 or n>Count(dataSet) then return nil
		select case dataSet
		case mp_ASTORB
			if APC_GetASTORBObject(n-1,id,nm,sma,ecc,aop,loan,oi,vm,sp,maae,doe,al,d,bv,cl) then
				ob = new APMinorPlanetObject(0)
				ob.Origin="ASTORB"
				ob.ID=id
				ob.Name=nm
				ob.SemimajorAxis=sma
				ob.Eccentricity=ecc
				ob.ArgOfPerihelion=aop
				ob.LongOfAscNode=loan
				ob.OrbitalInclination=oi
				ob.AbsMag=vm
				ob.SlopeParam=sp
				ob.MeanAnomalyAtEpoch=maae
				ob.DateOfEpoch=doe
				ob.ArcLength=al
				ob.Diameter=d
				ob.B_V=bv
				ob.ObjClass=cl
				return ob
			else
				return nil
			end if
			
		case mp_MPCORB
			if APC_GetMPCORBObject(n-1,id,nm,sma,ecc,aop,loan,oi,vm,sp,maae,doe,al) then
				ob = new APMinorPlanetObject(0)
				ob.Origin="MPCORB"
				ob.ID=id
				ob.Name=nm
				ob.SemimajorAxis=sma
				ob.Eccentricity=ecc
				ob.ArgOfPerihelion=aop
				ob.LongOfAscNode=loan
				ob.OrbitalInclination=oi
				ob.AbsMag=vm
				ob.SlopeParam=sp
				ob.MeanAnomalyAtEpoch=maae
				ob.DateOfEpoch=doe
				ob.ArcLength=al
				ob.Diameter=0
				ob.B_V=0
				ob.ObjClass=""
				return ob
			else
				return nil
			end if
			
		else
			return nil
		end select
	end function
	
	shared function ASTORBObject(n as integer) as APMinorPlanetObject
		Deprecate("APMinorPlanetObject.ASTORBObject(n)","APMinorPlanetObject.Get(n,mp_ASTORB)")
		return APMinorPlanetObject.Get(n,mp_ASTORB)
	end function

	shared function MPCORBObject(n as integer) as APMinorPlanetObject
		Deprecate("APMinorPlanetObject.MPCORBObject(n)","APMinorPlanetObject.Get(n,mp_MPCORB)")
		return APMinorPlanetObject.Get(n,mp_ASTORB)
	end function
	
	shared sub ASTORB_MPCORB_Initialise() // private
		for i as integer = 0 to mp_Last
			apc_n(i) = -1
		next	
	end sub

end class

//------------------------------------------------------------------------------------
class APCometObject
	// Documented 7/12/2012
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. CometObject(n))
	implements NamedObject
	
	dim ID as string
	dim Name as string

	dim Eccentricity as double
	dim PerihelionDistance as double
	dim OrbitalInclination as double
	dim LongOfAscNode as double
	dim ArgOfPerihelion as double
	dim Epoch as double
	dim DateOfPerihelion as double
	dim AbsMag as double
	dim MagConst as double

	dim Origin as string
	//- Always "COMET".

	private dim jdate as double
	private dim mag as double
	private dim ra as double
	private dim dec as double
	private dim motion as double
	private dim eLat as double
	private dim eLong as double

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer) // private
  	
  end sub
  
  function ObjectName() as string // private
  	if ID<>"" and Name="" then
  		return ID
  	elseif ID="" and Name<>"" then
  		return Name
  	elseif ID<>Name then
  		return ID+": "+Name
  	else
  		return ID
  	end if
  end function

	private sub ComputeStuff(jd as double)
		dim ra2 as double
		dim dec2 as double
		dim mag2 as double

		if jd=jdate then return
		jdate=jd
		SolarSystem.CometPosition(jdate, Eccentricity, PerihelionDistance, OrbitalInclination, LongOfAscNode, ArgOfPerihelion, Epoch, AbsMag, MagConst, DateOfPerihelion, ra, dec, mag)
		SolarSystem.CometPosition(jdate+1.0/24.0, Eccentricity, PerihelionDistance, OrbitalInclination, LongOfAscNode, ArgOfPerihelion, Epoch, AbsMag, MagConst, DateOfPerihelion, ra2, dec2, mag2)
		motion=AngleBetween(ra,dec,ra2,dec2)
		APC_EquatorialToEcliptic(ra,dec,jdate,eLat,eLong)
	end sub

	function Magnitude(jd as double) as double
		//- The computed magnitude at the given Julian date.
		ComputeStuff(jd)
		return mag
	end function

	function RA(jd as double) as double
		//- The computed RA at the given Julian date.
		ComputeStuff(jd)
		return ra
	end function

	function Dec(jd as double) as double
		//- The computed Dec at the given Julian date.
		ComputeStuff(jd)
		return dec
	end function
	
	function EclipticLatitude(jd as double) as double
		//- The computed ecliptic latitude at the given Julian date.
		ComputeStuff(jd)
		return eLat
	end function

	function EclipticLongitude(jd as double) as double
		//- The computed ecliptic longitude at the given Julian date.
		ComputeStuff(jd)
		return eLong
	end function

	function Motion(jd as double) as double
		//- The computed motion (degrees per hour) at the given Julian date.
		ComputeStuff(jd)
		return motion
	end function

	function AddToPlan(optional nPlan as integer = -1) as APPlanObject
		//- Add the comet object to the plan specified by plan number (default is the current plan), and return the corresponding APPlanObject.
		dim n as integer
		Plan(nPlan).APC_Plan_ResetHighlighted
		n=APC_CometAddToPlan(nPlan, origin, ID, Name, Eccentricity, PerihelionDistance, OrbitalInclination, LongOfAscNode, ArgOfPerihelion, Epoch, DateOfPerihelion, AbsMag, MagConst)
		if n<1 then return nil else return Plan(nPlan).Obj(n)
	end function

	function AddToPlan(p as APPlan) as APPlanObject
		//- Add the comet object to the plan specified, and return the corresponding APPlanObject. If p=nil then use the current plan document.
		return AddToPlan(APPlan.PlanNumber(p))
	end function
	
	private shared dim apc_nCOMET as integer
	
	shared function Count() as integer
		//- Return the number of objects in the COMET file. 
		//- This assumes that COMET has been cached. 
		//- If not, use File > Import > Comet Data... and select the COMET.DAT option in order to create the cache.
		if apc_nCOMET<0 then
			apc_nCOMET=APC_GetnCOMET()
			if apc_nCOMET<=0 then print "COMET.cache missing. Please access File->Import->Comet Data... and select the COMET.DAT option in order to create the cache."
		end if
		return apc_nCOMET
	end function

	shared function Get(n as integer) as APCometObject
		//- Get the n-th COMET object, n = 1...Count.
		dim id as string
		dim nm as string
		dim pd as double
		dim ecc as double
		dim aop as double
		dim loan as double
		dim oi as double
		dim ep as double
		dim am as double
		dim mc as double
		dim dop as double
		dim ob as APCometObject

		if n<1 or n>Count then return nil
		if APC_GetCOMETObject(n-1,id,nm,pd,ecc,aop,loan,oi,ep,am,mc,dop) then
			ob = new APCometObject(0)
			ob.Origin="COMET"
			ob.ID=id
			ob.Name=nm
			ob.PerihelionDistance=pd
			ob.Eccentricity=ecc
			ob.ArgOfPerihelion=aop
			ob.LongOfAscNode=loan
			ob.OrbitalInclination=oi
			ob.Epoch=ep
			ob.AbsMag=am
			ob.MagConst=mc
			ob.DateOfPerihelion=dop
			return ob
		else
			return nil
		end if
	end function
	
	shared sub COMET_Initialise() // private
		apc_nCOMET=-1
	end sub

end class

//------------------------------------------------------------------------------------
class APFile
	// Documented 7/12/2012
	//- Encapsulates the concept of a file or folder on disk.
	//- Note: Do not construct new instances of this object.
	//- Use instances of the APTextFile or APBinaryFile subclasses.
	implements NamedObject
	
	const fileError_None = 0
	const fileError_NonExistentOrFolder = -1
	const fileError_CannotOpen = -2
	const fileError_CannotWrite = -3
	const fileError_CannotDeleteExisting = -4
	const fileError_PathInvalid = -5
	const fileError_NotOpenForWrite = -6
	const fileError_NotOpenForRead = -7
	const fileError_NoLongerOpen = -8
	
	const apcftype_Text = 0 // private
	const apcftype_Binary = 1 // private
	
	dim APC_FileID as integer // private
	dim APC_FileType as integer // private

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  	
	sub Constructor(n as integer, t as integer) // private
		APC_FileID=n
		APC_FileType=t
	end sub

	sub Destructor() // private
		Close
	end sub
	
	sub Close()
		//- Close the file after use.
		APC_File_Close(APC_FileID,APC_FileType)
		APC_FileID=-1
	end sub
	
	function Path() as string
		//- Returns the path to the file
		return APC_File_Path(APC_FileID,APC_FileType,false)
	end function

	function ObjectName() as string // private
		return APC_File_Name(APC_FileID,APC_FileType)
	end function

	function Parent() as string
		//- Returns the path to the file's parent folder
		return APC_File_Path(APC_FileID,APC_FileType,true)
	end function

	function EOF() as boolean
		//- Returns true if the file open for reading is at the end-of-file mark.
		return APC_File_EOF(APC_FileID,APC_FileType)
	end function
	
	function CreationDate() as Date
		//- Returns the date/time the file was originally created.
		return new Date(APC_File_Date(APC_FileID,APC_FileType,true))
	end function

	function ModificationDate() as Date
		//- Returns the date/time the file was last modified.
		return new Date(APC_File_Date(APC_FileID,APC_FileType,false))
	end function

	shared function GetPath(optional folder as boolean = false, optional prompt as string = "", optional title as string = "") as string
		//- Request the user to select a file (folder=false) or a folder (folder=true), using the
		//- standard system file selection dialog. Returns empty string if the user cancels.
		//- The prompt and title parameters can be used to customise the dialog.
		return APC_GetPath(folder,prompt,title)
	end function
		
	shared function FileErrorCode() as integer
	  //- Return last file access error. See APFile.fileError_ constants
		return APC_FileErrorCode
	end function
	
	shared function Exists(path as string) As boolean
		//- Return true if the file/folder specified by the path exists on disk.
		return APC_FileExists(path)
	end function
	
	shared function FileLength(path as string) As integer
		//- Return the file length (size in bytes) of the file specified by the path.
		return APC_FileLength(path)
	end function
	
	shared function IsFolder(path as string) As boolean
		//- Return true if the path refers to an existing folder on disk.
	  return APC_IsFolder(path)
	end function
	
	shared function ScanFolder(path as string, optional recursive as boolean = true, optional extension as string = "") as string()
		//- Given a path to a folder, scan that folder for files and return an array of paths to those files.
		//- if path = "" then ask the user to select the folder.
		//- If recursive is FALSE, do not look in any subfolders. If recursive is TRUE, then scan all
		//- subfolders recursively to find all files in the folder tree.
		//- If extension = "" then return all files. If extension <> "" then return only those files whose
		//- name ends in extension (e.g. if extension = ".apd" then return only plan documents). Multiple
		//- file extensions can be specified, separated by semicolons, e.g. extension = ".txt;.csv;.doc".
		return APC_ScanFolder(path,recursive,extension)
	end function
	
	const folder_Desktop = 1 
	const folder_Documents = 2
	const folder_Trash = 3
	const folder_UserHome = 4
	const folder_ObservationAttachments = 5
	const folder_Scripts = 6
	
	shared function SpecialFolder(folderID as integer, optional filename as string = "") as string
		
		//- Return the path to various "special" folders.
		//- folderID is one of the folder_ constants, specifying which special folder you need.
		//- filename is the (optional) name of a file (or subfolder) in that special folder.
		return APC_File_SpecialFolder(folderID,filename)
	end function
	
end class

//------------------------------------------------------------------------------------
class APTextFile
	// Documented 7/12/2012
	//- Encapsulates a text file on disk.
	inherits APFile
	
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APTextFile.ReadFile())
	
	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(optional n as integer = -1) // private
		super.Constructor(n,apcftype_Text)
	end sub

	function ReadLine( ) as string
		//- Read a line (i.e. up to the next end-of-line character) from the text file
		return APC_TextFile_ReadLine(APC_FileID)
	end function

	function ReadCommaSeparatedLine( ) as string()
		//- Read a line containing comma-separated data (possibly quoted) and split it into its constituent columns
		return SplitQuoted(ReadLine,",",true)
	end function

	function ReadTabSeparatedLine( ) as string()
		//- Read a line containing tab-separated data (possibly quoted) and split it into its constituent columns
		return SplitQuoted(ReadLine,Chr(9),true)
	end function

	function ReadAll( ) as string
		//- Read the rest of the text file into a string.
		return APC_TextFile_ReadAll(APC_FileID)
	end function

	sub Write(s as string)
		//- Write the string to a text file.
		APC_TextFile_Write(APC_FileID,s)
	end sub

	sub WriteLine(optional s as string = "")
		//- Write the string to a text file and append an end-of-line.
		APC_TextFile_WriteLine(APC_FileID,s)
	end sub

	sub WriteCommaSeparatedLine(s() as string)
		//- Write an array of strings into a comma-separated line, with quotes around any item containing commas.
		WriteLine(JoinQuoted(s,","))
	end sub

	sub WriteTabSeparatedLine(s() as string)
		//- Write an array of strings into a tab-separated line.
		WriteLine(Join(s,chr(9)))
	end sub

	// Shared stuff
	
	shared function ReadFile( ) as APTextFile
	  //- Open and read from a text file.
	  //- The user will be prompted to select the file name/path to open.
	  //- Returns nil if the user cancelled the file selection dialog, or if the file cannot be opened. 
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

		i=APC_TextFile_Open("")
		if i>=0 then
			return new APTextFile(i)
		else
			return nil
		end if
	end function

	shared function ReadFileUsingPath(fpath as string) as APTextFile
	  //- Open and read from a text file, given its path.
	  //- Returns nil if the file doesn't exist or cannot be opened. 
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer
    
    if fpath="" then
    	APC_FileErrorCode=fileError_PathInvalid
    	return nil
    end if
    
		i=APC_TextFile_Open(fpath)
		if i>=0 then
			return new APTextFile(i)
		else
			return nil
		end if
	end function

	shared function WriteFile(optional default as string = "", optional extension as string = "") as APTextFile
		
	  //- Create and write to a text file. If the file exists, it will be overwritten.
	  //- The user will be prompted to select the file name/path to save.
	  //- Use the default parameter to specify a default file name to use (e.g. "current.txt") 
	  //- Use the extension parameter to save the file with a particular extension. The default is to
	  //- allow the file to be saved with the .txt extension.
	  //- Returns nil if the user cancelled the file selection dialog, if the file cannot be created 
	  //- or overwritten (if the file already exists).
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

		i=APC_TextFile_Save("",false,default,false,extension)
		if i>=0 then
			return new APTextFile(i)
		else
			return nil
		end if
	end function

	shared function WriteFileUsingPath(fpath as string, optional createIfMissing as boolean = false) as APTextFile
	  //- Create and write to a text file, given its path. If the file exists, it will be overwritten.
	  //- The fpath parameter must contain a full file path, including file name.
	  //- If the createIfMissing parameter is true, then the file path will be created if necessary.
	  //- Returns nil if the file cannot be created, or overwritten if the file already exists.
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

    if fpath="" then
    	APC_FileErrorCode=fileError_PathInvalid
    	return nil
    end if
    
		i=APC_TextFile_Save(fpath,false,"",createIfMissing,"")
		if i>=0 then
			return new APTextFile(i)
		else
			return nil
		end if
	end function

	shared function AppendFile(optional extension as string = "") as APTextFile
	  //- Open and append to an existing text file.
	  //- The user will be prompted to select the file name/path to open.
	  //- Use the extension parameter to save the file with a particular extension. The default is to
	  //- allow the file to be saved with the .txt extension.
	  //- Returns nil if the user cancelled the file selection dialog, or if the file cannot be opened. 
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

		i=APC_TextFile_Save("",true,"",false,extension)
		if i>=0 then
			return new APTextFile(i)
		else
			return nil
		end if
	end function
	
	shared function AppendFileUsingPath(fpath as string) as APTextFile
	  //- Open and append to an existing text file, given its path.
	  //- Returns nil if the file cannot be opened. 
	  //- Use APFile.FileErrorCode to check for errors.
		dim i as integer

    if fpath="" then
    	APC_FileErrorCode=fileError_PathInvalid
    	return nil
    end if
    
		i=APC_TextFile_Save(fpath,true,"",false,"")
		if i>=0 then
			return new APTextFile(i)
		else
			return nil
		end if
	end function
	
end class

//------------------------------------------------------------------------------------
class APBinaryFile
	inherits APFile
	// Documented 7/12/2012
	//- Encapsulates a binary file on disk.
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APBinaryFile.ReadFile())
		
	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(optional n as integer = -1) // private
		super.Constructor(n,apcftype_Binary)
	end sub
	
	function Position() as UInt64
		//- Get/set the current file position (for the next read/write)
		//- The first byte of the file is at Position=0.
		return APC_BinFile_GetPosition(APC_FileID)
	end function
	
	sub Position(assigns v as UInt64)
		APC_BinFile_SetPosition(APC_FileID,v)
	end sub
	
	function Length() as UInt64
		//- Returns the current length of the binary file in bytes.
		return APC_BinFile_GetLength(APC_FileID)
	end function
	
	sub LittleEndian(assigns v as boolean)
		//- Numerical values in little- or big-endian format.
		//- Default is big-endian (i.e. LittleEndian=false)
		APC_BinFile_LittleEndian(APC_FileID,v)
	end sub
	
	function LittleEndian() as boolean
		return APC_BinFile_IsLittleEndian(APC_FileID)
	end function
	
	function ReadInt8( ) as Int8
		//- Read one signed byte (8 bits)
		return APC_BinFile_ReadInt(APC_FileID,8)
	end function
	
	function ReadInt16( ) as Int16
		//- Read one signed integer (16 bits)
		return APC_BinFile_ReadInt(APC_FileID,16)
	end function
	
	function ReadInt32( ) as Int32
		//- Read one signed integer (32 bits)
		return APC_BinFile_ReadInt(APC_FileID,32)
	end function
	
	function ReadInt64( ) as Int64
		//- Read one signed integer (64 bits)
		return APC_BinFile_ReadInt(APC_FileID,64)
	end function
	
	function ReadUInt8( ) as UInt8
		//- Read one unsigned byte (8 bits)
		return APC_BinFile_ReadUInt(APC_FileID,8)
	end function
	
	function ReadUInt16( ) as UInt16
		//- Read one unsigned integer (16 bits)
		return APC_BinFile_ReadUInt(APC_FileID,16)
	end function
	
	function ReadUInt32( ) as UInt32
		//- Read one unsigned integer (32 bits)
		return APC_BinFile_ReadUInt(APC_FileID,32)
	end function
	
	function ReadUInt64( ) as UInt64
		//- Read one unsigned integer (64 bits)
		return APC_BinFile_ReadUInt(APC_FileID,64)
	end function
	
	function ReadSingle( ) as double
		//- Read one 32-bit floating point value
		return APC_BinFile_ReadDouble(APC_FileID,32)
	end function
	
	function ReadDouble( ) as double
		//- Read one 64-bit floating point value
		return APC_BinFile_ReadDouble(APC_FileID,64)
	end function
	
	function ReadPString( ) as string
		//- Read a Pascal string (i.e. starts with count byte)
		return APC_BinFile_ReadString(APC_FileID,-1)
	end function
	
	function Read(nbytes as integer) as string
		//- Read nbytes bytes into a string
		return APC_BinFile_ReadString(APC_FileID,nbytes)
	end function
	
	sub WriteInt8(v as Int8)
		//- Write a one-byte (8 bits) signed integer value
		APC_BinFile_WriteInt(APC_FileID,8,v)
	end sub
	
	sub WriteInt16(v as Int16)
		//- Write a two-byte (16 bits) signed integer value
		APC_BinFile_WriteInt(APC_FileID,16,v)
	end sub
	
	sub WriteInt32(v as Int32)
		//- Write a four-byte (32 bits) signed integer value
		APC_BinFile_WriteInt(APC_FileID,32,v)
	end sub
	
	sub WriteInt64(v as Int64)
		//- Write an eight-byte (64 bits) signed integer value
		APC_BinFile_WriteInt(APC_FileID,64,v)
	end sub
	
	sub WriteUInt8(v as UInt8)
		//- Write a one-byte (8 bits) unsigned integer value
		APC_BinFile_WriteUInt(APC_FileID,8,v)
	end sub
	
	sub WriteUInt16(v as UInt16)
		//- Write a two-byte (16 bits) unsigned integer value
		APC_BinFile_WriteUInt(APC_FileID,16,v)
	end sub
	
	sub WriteUInt32(v as UInt32)
		//- Write a four-byte (32 bits) unsigned integer value
		APC_BinFile_WriteUInt(APC_FileID,32,v)
	end sub
	
	sub WriteUInt64(v as UInt64)
		//- Write an eight-byte (64 bits) unsigned integer value
		APC_BinFile_WriteUInt(APC_FileID,64,v)
	end sub
	
	sub WriteSingle(v as double)
		//- Write a four-byte (32 bits) floating point value
		APC_BinFile_WriteDouble(APC_FileID,32,v)
	end sub
	
	sub WriteDouble(v as double)
		//- Write an eight-byte (64 bits) floating point value
		APC_BinFile_WriteDouble(APC_FileID,64,v)
	end sub
	
	sub WritePString(v as string)
		//- Write a Pascal string  (i.e. starts with count byte)
		APC_BinFile_WriteString(APC_FileID,-1,v)
	end sub
	
	sub Write(v as string)
		//- Write the bytes in v
		APC_BinFile_WriteString(APC_FileID,1,v)
	end sub
	
	// Shared stuff
	
	shared function ReadFile( ) as APBinaryFile
	  //- Open a binary file for read access only.
	  //- The user will be prompted to select the file name/path to open.
	  //- Returns nil if the user cancelled the file selection dialog, or if the file cannot be opened. 
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

		i=APC_BinFile_Open("",false)
		if i>=0 then
			return new APBinaryFile(i)
		else
			return nil
		end if
	end function

	shared function ReadFileUsingPath(fpath as string) as APBinaryFile
	  //- Open a binary file for read access only, given its path.
	  //- Returns nil if the file doesn't exist or cannot be opened. 
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer
    
    if fpath="" then
    	APC_FileErrorCode=fileError_PathInvalid
    	return nil
    end if
    
		i=APC_BinFile_Open(fpath,false)
		if i>=0 then
			return new APBinaryFile(i)
		else
			return nil
		end if
	end function

	shared function WriteFile(optional default as string = "") as APBinaryFile
	  //- Create and open a binary file for write access only. If the file exists, it will be overwritten.
	  //- The user will be prompted to select the file name/path to save.
	  //- Use the default parameter to specify a default file name to use (e.g. "current.bin") 
	  //- Returns nil if the user cancelled the file selection dialog, if the file cannot be created 
	  //- or overwritten (if the file already exists).
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

		i=APC_BinFile_Save("",default,false)
		if i>=0 then
			return new APBinaryFile(i)
		else
			return nil
		end if
	end function

	shared function WriteFileUsingPath(fpath as string, optional createIfMissing as boolean = false) as APBinaryFile
	  //- Create and open a binary file for write access only, given a file path. 
	  //- If the file exists, it will be overwritten.
	  //- The fpath parameter must contain a full file path, including file name.
	  //- If the createIfMissing parameter is true, then the file path will be created if necessary.
	  //- Returns nil if the file cannot be created, or overwritten if the file already exists.
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

    if fpath="" then
    	APC_FileErrorCode=fileError_PathInvalid
    	return nil
    end if
    
		i=APC_BinFile_Save(fpath,"",createIfMissing)
		if i>=0 then
			return new APBinaryFile(i)
		else
			return nil
		end if
	end function

	shared function ReadWriteFile( ) as APBinaryFile
	  //- Open an existing binary file for read/write access.
	  //- The user will be prompted to select the file name/path to open.
	  //- Returns nil if the user cancelled the file selection dialog, or if the file cannot be opened. 
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

		i=APC_BinFile_Open("",true)
		if i>=0 then
			return new APBinaryFile(i)
		else
			return nil
		end if
	end function

	shared function ReadWriteFileUsingPath(fpath as string) as APBinaryFile
	  //- Open an existing binary file for read/write access, given its path.
	  //- The fpath parameter must contain a full file path, including file name.
	  //- Returns nil if the file doesn't exist or cannot be opened. 
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer
    
    if fpath="" then
    	APC_FileErrorCode=fileError_PathInvalid
    	return nil
    end if
    
		i=APC_BinFile_Open(fpath,true)
		if i>=0 then
			return new APBinaryFile(i)
		else
			return nil
		end if
	end function

	shared function ReadWriteFileInMemory( ) as APBinaryFile
	  //- Create a memory-based binary file for read/write access.
	  //- This temporary "file" will exist only in memory and once closed will no longer be accessible.
	  //- Use APFile.FileErrorCode to check for errors.
	  
		dim i as integer

		i=APC_BinFile_Open("<<mem>>",true)
		if i>=0 then
			dim b as new APBinaryFile(i)
			b.LittleEndian=false
			return b
		else
			return nil
		end if
	end function

end class

//------------------------------------------------------------------------------------
module FileStuff // deprecate
	
	function ReadTextFile(optional fpath as string = "") as APTextFile
		Deprecate("ReadTextFile()","APTextFile.ReadFile() or APTextFile.ReadFileUsingPath()")
		if fpath="" then
			return APTextFile.ReadFile
		else
			return APTextFile.ReadFileUsingPath(fpath)
		end if
	end function

	function WriteTextFile(optional fpath as string = "", optional default as string = "") as APTextFile
		Deprecate("WriteTextFile()","APTextFile.WriteFile() or APTextFile.WriteFileUsingPath()")
		if fpath="" then
		  return APtextFile.WriteFile(default)
		else
		  return APtextFile.WriteFileUsingPath(fpath)
		end if
	end function

	function AppendTextFile(optional fpath as string = "") as APTextFile
		Deprecate("AppendTextFile()","APTextFile.AppendFile() or APTextFile.AppendFileUsingPath()")
		if fpath="" then
			return APTextFile.AppendFile
		else
			return APTextFile.AppendFileUsingPath(fpath)
		end if
	end function
	
	function GetPath(optional folder as boolean = false) as string
		Deprecate("GetPath()","APFile.GetPath")
		return APTextFile.GetPath(folder)
	end function
	
	function FileErrorCode() as integer
		Deprecate("FileErrorCode","APFile.FileErrorCode")
		return APTextFile.FileErrorCode
	end function
	
	function FileExists(path as string) As boolean
		Deprecate("FileExists()","APFile.Exists()")
		return APTextFile.Exists(path)
	end function
	
	function FileLength(path as string) As integer
		Deprecate("FileLength()","APFile.FileLength()")
		return APTextFile.FileLength(path)
	end function
	
	function IsFolder(path as string) As boolean
		Deprecate("IsFolder()","APFile.IsFolder()")
		return APTextFile.IsFolder(path)
	end function

end module

//------------------------------------------------------------------------------------
class Dialog
	// Documented 10/5/2012
	//- Display a user-defined complex dialog that allows a user to interact with the script.
	//- Sample usage:
	//- 
	//- dim d as new Dialog
	//- dim n as integer = 3
	//- d.IntegerParameter("Parameter A",n)
	//- if not d.Show then return
	//- n = d.IntegerParameter("Parameter A")
	
	private dim apc_Titles(-1) as string
	private dim apc_Columns(-1) as string
	private dim apc_Values(-1) as string
	private dim apc_Choices(-1) as string
	private dim apc_Types(-1) as integer
	private dim apc_Minv(-1) as double
	private dim apc_Maxv(-1) as double
	private dim apc_SameLine(-1) as integer
	private dim apc_ResetValues as boolean
	private dim apc_dependencyA(-1) as string
	private dim apc_dependencyB(-1) as string
	private dim apc_PushButton(-1) as string
	
	private dim apc_AllowNew(-1) as string
	
	private dim didx as integer
	
	private shared dim apc_Dialog_Master as integer
	
	sub Constructor()
		//- Construct a new dialog
		apc_Dialog_Master=apc_Dialog_Master+1
		didx=apc_Dialog_Master
	end sub
	
	function Show(optional title as string = "", optional debugMode as boolean = false, optional minColumnWidth as integer = 0, optional captionsAbove as boolean = false) as boolean
		//- Show the dialog on screen and allow the user to interact with it. 
		//- Return true if the user clicked the OK button, or false if the Cancel button was clicked.
		//- Supply title if you want the dialog to have a title other than the script name.
		//- Set debugMode to true to enable debug mode.
		//- Normally the size of the dialog and its columns are determined automatically. Use minColumnWidth to force the columns to have a particulr point size.
		//- Normally captions are to the left of the editing widgets they correspond to. Set captionsAbove to true to place the captions above the editing widgets.
		
		apc_ResetValues=true
		return APC_EditParameters(title,debugMode,minColumnWidth,captionsAbove,apc_Titles,apc_Columns,apc_Values,apc_Types,apc_Choices,apc_Minv,apc_Maxv,apc_SameLine,apc_dependencyA,apc_dependencyB,apc_PushButton)
	end function

  //....................................................................
	private sub APC_DoResetValues()
		 if apc_ResetValues then
			redim apc_Titles(-1)
			redim apc_Columns(-1)
			redim apc_Values(-1)
			redim apc_Types(-1)
			redim apc_Choices(-1)
			redim apc_Minv(-1)
			redim apc_Maxv(-1)
			redim apc_SameLine(-1)
			redim apc_dependencyA(-1)
			redim apc_dependencyB(-1)
			redim apc_PushButton(-1)
			redim apc_AllowNew(-1)
			apc_ResetValues=false
		end if
	end sub
	
  private sub APC_SetPValue(types as integer, sameline as boolean, title as string, v as string, optional choices as string = "", optional minv as double = 0.0, optional maxv as double = 0.0, optional columns as string = "")
  	APC_DoResetValues
		apc_Titles.Append title
		apc_Columns.Append columns
		apc_Values.Append v
		apc_Choices.Append choices
		apc_Minv.Append minv
		apc_Maxv.Append maxv
		apc_Types.Append types
		if sameline then apc_SameLine.Append 1 else apc_SameLine.Append 0
  end sub
  
	private function APC_GetPIndex(title as string) as integer
		dim i as integer
		dim j as integer

		i = apc_Titles.IndexOf(title)
		if i>=0 then return i
		for i=0 to ubound(apc_Titles)
			if instr(apc_Titles(i),title+":")=1 then
				if IsNumeric(mid(apc_Titles(i),len(title)+2)) then return i
			end if
		next
		return -1
		end function

  private function APC_GetPValue(title as string) as string
		dim i as integer = APC_GetPIndex(title)
		if i>=0 then
			return apc_Values(i)
		else
			return ""
		end if
  end function
  
  //....................................................................	
	sub IntegerParameter(sameline as boolean, title as string, v as integer, optional minv as integer = -2000000000, optional maxv as integer = 2000000000)
		//- Set up an integer parameter field.
		//- Parameters are placed one after the other vertically in the dialog, unless sameline is specified as true, 
		//- in which case the parameter field will be placed to the right of the previous field (i.e. "on the same line").
		//- title is a string used to label the parameter field, e.g. "Number of iterations".
    //- v is the initial value of the parameter field.
		//- minv and maxv are optional parameters to specify the upper and lower bounds of the acceptable range of integer values that can be accepted.
		APC_SetPValue(1,sameline,title,format(v,"-0"),"",minv,maxv)
	end sub

	sub IntegerParameter(title as string, v as integer, optional minv as integer = -2000000000, optional maxv as integer = 2000000000)
		//- Set up an integer parameter field.
		//- title is a string used to label the parameter field, e.g. "Number of iterations".
    //- v is the initial value of the parameter field.
		//- minv and maxv are optional parameters to specify the upper and lower bounds of the acceptable range of integer values that can be accepted.
		IntegerParameter(false,title,v,minv,maxv)
	end sub

	function IntegerParameter(title as string) as integer
		//- After the dialog has been displayed, the user has interacted with it, and the OK button has been clicked, 
		//- this method call is used to retrieve the parameter value. 
		//- title must have exactly the same value as the title parameter in the corresponding setup method.
		return val(APC_GetPValue(title))
	end function

  //....................................................................
	sub BooleanParameter(sameline as boolean, title as string, v as boolean)
		//- Set up an boolean (checkbox) parameter field.
		//- Parameters are placed one after the other vertically in the dialog, unless sameline is specified as true, 
		//- in which case the parameter field will be placed to the right of the previous field (i.e. "on the same line").
		//- title is a string used to label the parameter field, e.g. "Use local date/time".
    //- v is the initial value of the parameter field.
		if v then
			APC_SetPValue(2,sameline,title,"1")
		else
			APC_SetPValue(2,sameline,title,"0")
		end if
	end sub

	sub BooleanParameter(title as string, v as boolean)
		//- Set up an boolean (checkbox) parameter field.
		//- title is a string used to label the parameter field, e.g. "Use local date/time".
    //- v is the initial value of the parameter field.
		BooleanParameter(false,title,v)
	end sub

	function BooleanParameter(title as string) as boolean
		//- After the dialog has been displayed, the user has interacted with it, and the OK button has been clicked, 
		//- this method call is used to retrieve the parameter value. 
		//- title must have exactly the same value as the title parameter in the corresponding setup method.
		return APC_GetPValue(title)<>"0"
	end function

  //....................................................................
	sub DoubleParameter(sameline as boolean, title as string, v as double, optional minv as double = -1E200, optional maxv as double = 1E200)
		//- Set up an double parameter field.
		//- Parameters are placed one after the other vertically in the dialog, unless sameline is specified as true, 
		//- in which case the parameter field will be placed to the right of the previous field (i.e. "on the same line").
		//- title is a string used to label the parameter field, e.g. "Maximum magnitude".
    //- v is the initial value of the parameter field.
		//- minv and maxv are optional parameters to specify the upper and lower bounds of the acceptable range of double values that can be accepted.
		APC_SetPValue(3,sameline,title,DoubleToStr(v),"",minv,maxv)
	end sub

	sub DoubleParameter(title as string, v as double, optional minv as double = -1E200, optional maxv as double = 1E200)
		//- Set up an double parameter field.
		//- title is a string used to label the parameter field, e.g. "Maximum magnitude".
    //- v is the initial value of the parameter field.
		//- minv and maxv are optional parameters to specify the upper and lower bounds of the acceptable range of double values that can be accepted.
		DoubleParameter(false,title,v,minv,maxv)
	end sub

	function DoubleParameter(title as string) as double
		//- After the dialog has been displayed, the user has interacted with it, and the OK button has been clicked, 
		//- this method call is used to retrieve the parameter value. 
		//- title must have exactly the same value as the title parameter in the corresponding setup method.
		return CDbl(APC_GetPValue(title))
	end function

  //....................................................................
	sub ColorParameter(sameline as boolean, title as string, v as Color)
		//- Set up an colour swatch parameter field. The user clicks the swatch to change the colour value.
		//- Parameters are placed one after the other vertically in the dialog, unless sameline is specified as true, 
		//- in which case the parameter field will be placed to the right of the previous field (i.e. "on the same line").
		//- title is a string used to label the parameter field, e.g. "Bad value colour".
    //- v is the initial value of the parameter field.
		APC_SetPValue(13,sameline,title,APC_ColourToString(v))
	end sub

	sub ColorParameter(title as string, v as Color)
		//- Set up an colour swatch parameter field. The user clicks the swatch to change the colour value.
		//- title is a string used to label the parameter field, e.g. "Bad value colour".
    //- v is the initial value of the parameter field.
		ColorParameter(false,title,v)
	end sub

	function ColorParameter(title as string) as Color
		//- After the dialog has been displayed, the user has interacted with it, and the OK button has been clicked, 
		//- this method call is used to retrieve the parameter value. 
		//- title must have exactly the same value as the title parameter in the corresponding setup method.
		return APC_StringToColour(APC_GetPValue(title))
	end function

  //....................................................................
	sub StringParameter(sameline as boolean, title as string, v as string, optional multiline as boolean = false)
		//- Set up an string parameter field.
		//- Parameters are placed one after the other vertically in the dialog, unless sameline is specified as true, 
		//- in which case the parameter field will be placed to the right of the previous field (i.e. "on the same line").
		//- title is a string used to label the parameter field, e.g. "Catalogue name".
    //- v is the initial value of the parameter field.
    //- If multiline is true, then use a field that can accept multiple lines of text.
		if multiline then
			APC_SetPValue(-4,sameline,title,v,"",4.0)
		else
			APC_SetPValue(4,sameline,title,v,"",0.0)
		end if
	end sub

	sub StringParameter(title as string, v as string, optional multiline as boolean = false)
		//- Set up an string parameter field.
		//- title is a string used to label the parameter field, e.g. "Catalogue name".
    //- v is the initial value of the parameter field.
    //- If multiline is true, then use a field that can accept multiple lines of text.
		StringParameter(false,title,v,multiline)
	end sub

	function StringParameter(title as string) as string
		//- After the dialog has been displayed, the user has interacted with it, and the OK button has been clicked, 
		//- this method call is used to retrieve the parameter value. 
		//- title must have exactly the same value as the title parameter in the corresponding setup method.
		return APC_GetPValue(title)
	end function

  //....................................................................
	private sub APC_ChoiceParameter(sameline as boolean, title as string, v as integer, c() as string, ntype as integer)
		APC_SetPValue(ntype,sameline,title,format(v,"-0"),Join(c,chr(9)),0,ubound(c))
	end sub

	sub ChoiceParameter(sameline as boolean, title as string, v as integer, paramarray c as string)
		//- Set up a choice (one of many) parameter in the form of a number of radio buttons. 
		//- The choice, v, is an integer, where 0 is the first radio button, 1 is the second, etc.
		//- c is a number of strings (two or more) separated by commas. 
		//- Each one represents the caption of the corresponding radio button.
		APC_ChoiceParameter(sameline,title,v,c,5)
	end sub

	sub ChoiceParameter(title as string, v as integer, paramarray c as string)
		//- Set up a choice (one of many) parameter in the form of a number of radio buttons. 
		//- The choice, v, is an integer, where 0 is the first radio button, 1 is the second, etc.
		//- c is a number of strings (two or more) separated by commas. 
		//- Each one represents the caption of the corresponding radio button.
		APC_ChoiceParameter(false,title,v,c,5)
	end sub

	sub ChoiceParameter(sameline as boolean, title as string, v as integer, c() as string)
		//- Set up a choice (one of many) parameter in the form of a number of radio buttons. 
		//- The choice, v, is an integer, where 0 is the first radio button, 1 is the second, etc.
		//- c is an array of strings (two or more). 
		//- Each one represents the caption of the corresponding radio button.
		APC_ChoiceParameter(sameline,title,v,c,5)
	end sub

	sub ChoiceParameter(title as string, v as integer, c() as string)
		//- Set up a choice (one of many) parameter in the form of a number of radio buttons. 
		//- The choice, v, is an integer, where 0 is the first radio button, 1 is the second, etc.
		//- c is an array of strings (two or more). 
		//- Each one represents the caption of the corresponding radio button.
		APC_ChoiceParameter(false,title,v,c,5)
	end sub

	sub ChoiceParameter(sameline as boolean, title as string, v as integer, c() as NamedObject)
		//- Set up a choice (one of many) parameter in the form of a number of radio buttons. 
		//- The choice, v, is an integer, where 0 is the first radio button, 1 is the second, etc.
		//- c is an array of objects (two or more) that implement the NamedObject interface. 
		//- Each one represents the caption of the corresponding radio button.
		dim s(-1) as string
		for i as integer = 0 to ubound(c)
			s.Append c(i).ObjectName
		next
		ChoiceParameter(sameline,title,v,s)
	end sub

	sub ChoiceParameter(title as string, v as integer, c() as NamedObject)
		//- Set up a choice (one of many) parameter in the form of a number of radio buttons. 
		//- The choice, v, is an integer, where 0 is the first radio button, 1 is the second, etc.
		//- c is an array of objects (two or more) that implement the NamedObject interface. 
		//- Each one represents the caption of the corresponding radio button.
		ChoiceParameter(false,title,v,c)
	end sub

	function ChoiceParameter(title as string) as integer
		//- Retrieve the chosen item index in the corresponding choice parameter field.
		if IsNumeric(APC_GetPValue(title)) then
			return val(APC_GetPValue(title))
		else
			return -1
		end if
	end function

	function ChoiceParameterAsString(title as string) as string
		//- Retrieve the chosen item caption in the corresponding choice parameter field.
		dim i as integer = APC_GetPIndex(title)
		if i>=0 then
			return NthField(apc_Choices(i),chr(9),val(apc_Values(i))+1)
		else
			return "?"
		end if
	end function

  //....................................................................
	sub ListChoiceParameter(sameline as boolean, title as string, v as integer, c() as string, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		//- Set up a list choice (one of many) parameter in the form of a scrollable list. 
		//- The choice is an integer, where 0 is the first item, 1 is the second item, etc.
		//- c is an array of strings (two or more). Each one represents the caption of the corresponding line in the list.
		//- If sorted is true, then the list will be sorted in alphabetic order. Note that the returned 
		//- choice index will be with respect to the original array, c, not the sorted list ordering.
		//- The maxvisible parameter specifies the number of list rows to display (default = 6). 
		//- If the actual number of list entries exceed this, a vertical scroll bar will be used to scroll to the other entries.
		//- If doubleclick is true, then double-clicking a list entry will select that entry and dismiss the dialog, 
		//- as if OK was clicked.
		dim x as integer
		if sorted then
			x=1
		else
			x=0
		end if
		if doubleclick then x=x+2
    APC_SetPValue(12,sameline,title,format(v,"-0"),Join(c,chr(9)),x,maxvisible)
	end sub

	sub ListChoiceParameter(title as string, v as integer, c() as string, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		//- Set up a list choice (one of many) parameter in the form of a scrollable list. 
		//- The choice is an integer, where 0 is the first item, 1 is the second item, etc.
		//- c is an array of strings (two or more). Each one represents the caption of the corresponding line in the list.
		//- If sorted is true, then the list will be sorted in alphabetic order. Note that the returned 
		//- choice index will be with respect to the original array, c, not the sorted list ordering.
		//- The maxvisible parameter specifies the number of list rows to display (default = 6). 
		//- If the actual number of list entries exceed this, a vertical scroll bar will be used to scroll to the other entries.
		//- If doubleclick is true, then double-clicking a list entry will select that entry and dismiss the dialog, 
		//- as if OK was clicked.
		 ListChoiceParameter(false,title,v,c,sorted,maxvisible,doubleclick)
	end sub

	sub ListChoiceParameter(sameline as boolean, title as string, v as integer, c() as NamedObject, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		//- Set up a list choice (one of many) parameter in the form of a scrollable list. 
		//- The choice is an integer, where 0 is the first item, 1 is the second item, etc.
		//- c is an array of objects (two or more) that implement the NamedObject interface. 
		//- Each one represents the caption of the corresponding line in the list.
		//- If sorted is true, then the list will be sorted in alphabetic order. Note that the returned 
		//- choice index will be with respect to the original array, c, not the sorted list ordering.
		//- The maxvisible parameter specifies the number of list rows to display (default = 6). 
		//- If the actual number of list entries exceed this, a vertical scroll bar will be used to scroll to the other entries.
		//- If doubleclick is true, then double-clicking a list entry will select that entry and dismiss the dialog, 
		//- as if OK was clicked.
		dim s(-1) as string

		for i as integer = 0 to ubound(c)
			s.Append c(i).ObjectName
		next
		ListChoiceParameter(sameline,title,v,s,sorted,maxvisible,doubleclick)
	end sub

	sub ListChoiceParameter(title as string, v as integer, c() as NamedObject, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		//- Set up a list choice (one of many) parameter in the form of a scrollable list. 
		//- The choice is an integer, where 0 is the first item, 1 is the second item, etc.
		//- c is an array of objects (two or more) that implement the NamedObject interface. 
		//- Each one represents the caption of the corresponding line in the list.
		//- If sorted is true, then the list will be sorted in alphabetic order. Note that the returned 
		//- choice index will be with respect to the original array, c, not the sorted list ordering.
		//- The maxvisible parameter specifies the number of list rows to display (default = 6). 
		//- If the actual number of list entries exceed this, a vertical scroll bar will be used to scroll to the other entries.
		//- If doubleclick is true, then double-clicking a list entry will select that entry and dismiss the dialog, 
		//- as if OK was clicked.
		ListChoiceParameter(false,title,v,c,sorted,maxvisible,doubleclick)
	end sub

	sub ListChoiceParameter(sameline as boolean, title as string, v as integer, c() as MultiFieldObject, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		//- Set up a list choice (one of many) parameter in the form of a scrollable list. 
		//- The choice is an integer, where 0 is the first item, 1 is the second item, etc.
		//- c is an array of objects (two or more) that implement the MultiFieldObject interface. 
		//- In this case the list will have multiple columns, with corresponding values from the objects populating the columns. 
		//- Each one represents the caption of the corresponding line in the list.
		//- If sorted is true, then the list will be sorted in alphabetic order. Note that the returned 
		//- choice index will be with respect to the original array, c, not the sorted list ordering.
		//- The maxvisible parameter specifies the number of list rows to display (default = 6). 
		//- If the actual number of list entries exceed this, a vertical scroll bar will be used to scroll to the other entries.
		//- If doubleclick is true, then double-clicking a list entry will select that entry and dismiss the dialog, 
		//- as if OK was clicked.
		dim s(-1) as string

		for i as integer=0 to ubound(c)
			dim sf(-1) as string
			for j as integer = 1 to c(i).nColumns
				sf.Append c(i).ColumnValue(j)
			next
			s.Append Join(sf,"<%>")
		next
		
		dim st(-1) as string
		if ubound(c)>=0 then
			for j as integer = 1 to c(0).nColumns
				st.Append c(0).ColumnName(j)+chr(9)+str(c(0).ColumnType(j))
			next
		end if

		dim x as integer
		if sorted then
			x=1
		else
			x=0
		end if
		if doubleclick then x=x+2

    APC_SetPValue(12,sameline,title,format(v,"-0"),Join(s,chr(9)),x,maxvisible,Join(st,"<%>"))
	end sub

	sub ListChoiceParameter(title as string, v as integer, c() as MultiFieldObject, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		//- Set up a list choice (one of many) parameter in the form of a scrollable list. 
		//- The choice is an integer, where 0 is the first item, 1 is the second item, etc.
		//- c is an array of objects (two or more) that implement the MultiFieldObject interface. 
		//- In this case the list will have multiple columns, with corresponding values from the objects populating the columns. 
		//- Each one represents the caption of the corresponding line in the list.
		//- If sorted is true, then the list will be sorted in alphabetic order. Note that the returned 
		//- choice index will be with respect to the original array, c, not the sorted list ordering.
		//- The maxvisible parameter specifies the number of list rows to display (default = 6). 
		//- If the actual number of list entries exceed this, a vertical scroll bar will be used to scroll to the other entries.
		//- If doubleclick is true, then double-clicking a list entry will select that entry and dismiss the dialog, 
		//- as if OK was clicked.
		ListChoiceParameter(false,title,v,c,sorted,maxvisible,doubleclick)
	end sub

	function ListChoiceParameter(title as string) as integer
		//- Retrieve the chosen item index in the corresponding list choice parameter field.
		return ChoiceParameter(title)
	end function

	function ListChoiceParameterAsString(title as string) as string
		//- Retrieve the chosen item caption in the corresponding list choice parameter field.
		return ChoiceParameterAsString(title)
	end function

  //....................................................................
	sub PopupParameter(sameline as boolean, title as string, v as integer, c() as string)
		//- Set up a popup (one of many) parameter in the form of a popup menu. 
		//- The choice is an integer, where 0 is the first item in the menu, 1 is the second item, etc.
		//- c is an array of strings (two or more). 
		//- Each one represents the caption of the corresponding entry in the menu.
		APC_ChoiceParameter(sameline,title,v,c,8)
	end sub

	sub PopupParameter(title as string, v as integer, c() as string)
		//- Set up a popup (one of many) parameter in the form of a popup menu. 
		//- The choice is an integer, where 0 is the first item in the menu, 1 is the second item, etc.
		//- c is an array of strings (two or more). 
		//- Each one represents the caption of the corresponding entry in the menu.
		APC_ChoiceParameter(false,title,v,c,8)
	end sub

	sub PopupParameter(sameline as boolean, title as string, v as integer, c() as NamedObject)
		//- Set up a popup (one of many) parameter in the form of a popup menu. 
		//- The choice is an integer, where 0 is the first item in the menu, 1 is the second item, etc.
		//- c is an array of objects (two or more) that implement the NamedObject interface. 
		//- Each one represents the caption of the corresponding entry in the menu.
		dim s(-1) as string

		for i as integer = 0 to ubound(c)
			s.Append c(i).ObjectName
		next
		PopupParameter(sameline,title,v,s)
	end sub

	sub PopupParameter(title as string, v as integer, c() as NamedObject)
		//- Set up a popup (one of many) parameter in the form of a popup menu. 
		//- The choice is an integer, where 0 is the first item in the menu, 1 is the second item, etc.
		//- c is an array of objects (two or more) that implement the NamedObject interface. 
		//- Each one represents the caption of the corresponding entry in the menu.
		PopupParameter(false,title,v,c)
	end sub

	function PopupParameter(title as string) as integer
		//- Retrieve the selected item caption in the corresponding popup parameter field.
		return ChoiceParameter(title)
	end function

	function PopupParameterAsString(title as string) as string
		//- Retrieve the selected item caption in the corresponding popup parameter field.
		return ChoiceParameterAsString(title)
	end function

  //....................................................................
	sub DateParameter(sameline as boolean, title as string, v as double, optional minv as double = 0.0, optional maxv as double = 1E200)
		//- Set up a date parameter in the form of a date-selection widget. 
		//- The choice is a double value representing the date-time value (number of seconds since 1 Jan 1904). 
		//- You can also use a Date object instead of the doubles.
		//- Use minv and maxv to set up minimum and maximum date limits if required.
		APC_SetPValue(6,sameline,title,APC_DoubleToDate(v),"",minv,maxv)
	end sub

	sub DateParameter(title as string, v as double, optional minv as double = 0.0, optional maxv as double = 1E200)
		//- Set up a date parameter in the form of a date-selection widget. 
		//- The choice is a double value representing the date-time value (number of seconds since 1 Jan 1904). 
		//- You can also use a Date object instead of the doubles.
		//- Use minv and maxv to set up minimum and maximum date limits if required.
		DateParameter(false,title,v,minv,maxv)
	end sub

	function DateParameter(title as string) as double			
		//- Retrieve the date value from the corresponding date parameter field.
		return APC_DateToDouble(APC_GetPValue(title))
	end function

  //....................................................................
	sub TimeParameter(sameline as boolean, title as string, v as double)
		//- Set up a time parameter in the form of a time-selection widget. 
		//- The time is a double value between 0 and 24.
		APC_SetPValue(9,sameline,title,APC_DoubleToTime(v,true),"",0.0,23.99999999999)
	end sub

	sub TimeParameter(title as string, v as double)
		//- Set up a time parameter in the form of a time-selection widget. 
		//- The time is a double value between 0 and 24.
		TimeParameter(false,title,v)
	end sub

	function TimeParameter(title as string) as double
		//- Retrieve the time value from the corresponding time parameter field.
		return APC_ParseTime(APC_GetPValue(title))
	end function

  //....................................................................
	sub SliderParameter(sameline as boolean, title as string, v as double, optional minv as double = 0.0, optional maxv as double = 100.0, optional stepv as double = 1.0)
		//- Set up a slider parameter as a "continuously-variable) double value. 
		//- Use minv and maxv to set up the lower and upper limits for the slider (minv < maxv). 
		//- The step size (stepv) specifies the minimum step size. Make sure (maxv - minv) / stepv is not too large.
		dim x as double
		dim mn as double
		dim mx as double
		dim st as double
		
		if minv>maxv then
			mn=maxv
			mx=minv
		else
			mx=maxv
			mn=minv
		end if
		if mn=mx then mx=mn+1
		if v<mn then
			x=mn
		elseif v>mx then
			x=mx
		else
			x=v
		end if
		if stepv<=0.0 then
			st=(mx-mn)*0.1
		elseif stepv>mx-mn then
			st=mx-mn
		else
			st=stepv
		end if
		APC_SetPValue(10,sameline,title,DoubleToStr(x),DoubleToStr(st),mn,mx)
	end sub

	sub SliderParameter(title as string, v as double, optional minv as double = 0.0, optional maxv as double = 100.0, optional stepv as double = 1.0)
		//- Set up a slider parameter as a "continuously-variable) double value. 
		//- Use minv and maxv to set up the lower and upper limits for the slider (minv < maxv). 
		//- The step size (stepv) specifies the minimum step size. Make sure (maxv - minv) / stepv is not too large.
		SliderParameter(false,title,v,minv,maxv,stepv)
	end sub

	sub SliderParameter(sameline as boolean, title as string, v as integer, c() as string)
		//- Set up a slider parameter to select one of a small number of values. 
		//- c contains the values as strings (they need not be numeric. e.g. "Small", "Medium", and "Large").

		while ubound(c)<1
			c.Append "Unknown"
		wend
		APC_SetPValue(10,sameline,title,format(min(max(v,0),ubound(c)),"-0"),Join(c,chr(9)),0,ubound(c))
	end sub

	sub SliderParameter(title as string, v as integer, c() as string)
		//- Set up a slider parameter to select one of a small number of values. 
		//- c contains the values as strings (they need not be numeric. e.g. "Small", "Medium", and "Large").
		SliderParameter(false,title,v,c)
	end sub

	sub SliderParameter(sameline as boolean, title as string, v as integer, paramarray c as string)
		//- Set up a slider parameter to select one of a small number of values. 
		//- c contains the values as strings (they need not be numeric. e.g. "Small", "Medium", and "Large").
		SliderParameter(sameline,title,v,c)
	end sub

	sub SliderParameter(title as string, v as integer, paramarray c as string)
		//- Set up a slider parameter to select one of a small number of values. 
		//- c contains the values as strings (they need not be numeric. e.g. "Small", "Medium", and "Large").
		SliderParameter(false,title,v,c)
	end sub

	sub SliderParameter(sameline as boolean, title as string, v as integer, c() as NamedObject)
		//- Set up a slider parameter to select one of a small number of values. 
		//- c contains the values as objects that implement the NamedObjects interface.
		dim i as integer
		dim s(-1) as string

		for i=0 to ubound(c)
			s.Append c(i).ObjectName
		next
		SliderParameter(sameline,title,v,s)
	end sub

	sub SliderParameter(title as string, v as integer, c() as NamedObject)
		//- Set up a slider parameter to select one of a small number of values. 
		//- c contains the values as objects that implement the NamedObjects interface.
		SliderParameter(false,title,v,c)
	end sub

	function SliderParameter(title as string) as double
		//- Retrieve the slider value from the corresponding slider parameter field. 
		//- If the string parameter versions were used, then the index to the original array will be returned.
		return CDbl(APC_GetPValue(title))
	end function

  //....................................................................
	sub CheckListParameter(sameline as boolean, title as string, v() as boolean, c() as string, optional sorted as boolean = false, optional maxvisible as integer = 6)
		//- Select one or more items from a given set of items by means of a scrolling list with a checkbox associated with each entry. 
		//- The value for this type of parameter is an array of boolean values, 
		//- with each value being true if the corresponding item was selected/checked.
		//- c is an array of strings representing the items. It should have the same dimensionality as v.
		//- If sorted is true then the displayed list will be sorted alphabetically. However, 
		//- this does not affect the ordering of v or c.
		//- maxvisible represents the number of visible rows in the list (default = 6). If the 
		//- number of entries exceeds this, a vertical scroll bar will be displayed.

		dim i as integer
		dim m as integer
		dim b(-1) as string
		dim cap(-1) as string

		redim cap(ubound(c))
		redim b(ubound(v))

		for i=0 to ubound(v)
			if v(i) then b(i)="1" else b(i)="0"
		next

		for i=0 to ubound(c)
			cap(i)=c(i)
		next

		m=max(ubound(v),ubound(c))
		if m<0 then m=0

		while ubound(cap)<m
			cap.Append "Unknown"
		wend

		while ubound(b)<m
			b.Append "0"
		wend
		dim vsorted as double
		if sorted then
			vsorted=1
		else
			vsorted=0
		end if

		APC_SetPValue(11,sameline,title,Join(b,chr(9)),Join(cap,chr(9)),vsorted,maxvisible)
	end sub

	sub CheckListParameter(title as string, v() as boolean, c() as string, optional sorted as boolean = false, optional maxvisible as integer = 6)
		//- Select one or more items from a given set of items by means of a scrolling list with a checkbox associated with each entry. 
		//- The value for this type of parameter is an array of boolean values, 
		//- with each value being true if the corresponding item was selected/checked.
		//- c is an array of strings representing the items. It should have the same dimensionality as v.
		//- If sorted is true then the displayed list will be sorted alphabetically. However, 
		//- this does not affect the ordering of v or c.
		//- maxvisible represents the number of visible rows in the list (default = 6). If the 
		//- number of entries exceeds this, a vertical scroll bar will be displayed.
		CheckListParameter(false,title,v,c,sorted,maxvisible)
	end sub

	sub CheckListParameter(title as string, v() as boolean, paramarray c as string)
		//- Select one or more items from a given set of items by means of a scrolling list with a checkbox associated with each entry. 
		//- The value for this type of parameter is an array of boolean values, 
		//- with each value being true if the corresponding item was selected/checked.
		//- c is a list of comma-separated strings representing the items. It should have the same dimensionality as v.
		//- If sorted is true then the displayed list will be sorted alphabetically. However, 
		//- this does not affect the ordering of v or c.
		//- maxvisible represents the number of visible rows in the list (default = 6). If the 
		//- number of entries exceeds this, a vertical scroll bar will be displayed.
		CheckListParameter(false,title,v,c)
	end sub

	sub CheckListParameter(sameline as boolean, title as string, v() as boolean, paramarray c as string)
		//- Select one or more items from a given set of items by means of a scrolling list with a checkbox associated with each entry. 
		//- The value for this type of parameter is an array of boolean values, 
		//- with each value being true if the corresponding item was selected/checked.
		//- c is a list of comma-separated strings representing the items. It should have the same dimensionality as v.
		//- If sorted is true then the displayed list will be sorted alphabetically. However, 
		//- this does not affect the ordering of v or c.
		//- maxvisible represents the number of visible rows in the list (default = 6). If the 
		//- number of entries exceeds this, a vertical scroll bar will be displayed.
		CheckListParameter(sameline,title,v,c)
	end sub

	sub CheckListParameter(sameline as boolean, title as string, v() as boolean, c() as NamedObject, optional sorted as boolean = false, optional maxvisible as integer = 6)
		//- Select one or more items from a given set of items by means of a scrolling list with a checkbox associated with each entry. 
		//- The value for this type of parameter is an array of boolean values, 
		//- with each value being true if the corresponding item was selected/checked.
		//- c is an array of objects (implementing the NamedObjects interface) representing the items. It 
		//- should have the same dimensionality as v.
		//- If sorted is true then the displayed list will be sorted alphabetically. However, 
		//- this does not affect the ordering of v or c.
		//- maxvisible represents the number of visible rows in the list (default = 6). If the 
		//- number of entries exceeds this, a vertical scroll bar will be displayed.
		 dim i as integer
		 dim s(-1) as string

		for i=0 to ubound(c)
			s.Append c(i).ObjectName
		next
		CheckListParameter(sameline,title,v,s,sorted, maxvisible)
	end sub

	sub CheckListParameter(title as string, v() as boolean, c() as NamedObject, optional sorted as boolean = false, optional maxvisible as integer = 6)
		//- Select one or more items from a given set of items by means of a scrolling list with a checkbox associated with each entry. 
		//- The value for this type of parameter is an array of boolean values, 
		//- with each value being true if the corresponding item was selected/checked.
		//- c is an array of objects (implementing the NamedObjects interface) representing the items. It 
		//- should have the same dimensionality as v.
		//- If sorted is true then the displayed list will be sorted alphabetically. However, 
		//- this does not affect the ordering of v or c.
		//- maxvisible represents the number of visible rows in the list (default = 6). If the 
		//- number of entries exceeds this, a vertical scroll bar will be displayed.
		CheckListParameter(false,title,v,c,sorted,maxvisible)
	end sub

 function CheckListParameter(title as string) as boolean()
 	//- Retrieve a boolean array representing the selected/checked items.
		dim i as integer
		dim s(-1) as string
		dim v(-1) as boolean

		i = APC_GetPIndex(title)
		if i>=0 then
			s=Split(apc_Values(i),chr(9))
			for i=0 to ubound(s)
				v.Append val(s(i))<>0
			next
		end if
		return v
	end function
	
	sub CheckListParameter(sameline as boolean, title as string, v() as boolean, c() as MultiFieldObject, optional sorted as boolean = false, optional maxvisible as integer = 6)
		//- Select one or more items from a given set of items by means of a scrolling list with a checkbox associated with each entry. 
		//- The value for this type of parameter is an array of boolean values, 
		//- with each value being true if the corresponding item was selected/checked.
		//- c is an array of objects (two or more) that implement the MultiFieldObject interface. In 
		//- this case the list will have multiple columns, with corresponding values from the objects 
		//- populating the columns. Each one represents the caption of the corresponding line in the list. It 
		//- should have the same dimensionality as v.
		//- If sorted is true then the displayed list will be sorted alphabetically. However, 
		//- this does not affect the ordering of v or c.
		//- maxvisible represents the number of visible rows in the list (default = 6). If the 
		//- number of entries exceeds this, a vertical scroll bar will be displayed.
	  
		 dim i as integer
		 dim s(-1) as string

		for i=0 to ubound(c)
			dim sf(-1) as string
			for j as integer = 1 to c(i).nColumns
				sf.Append c(i).ColumnValue(j)
			next
			s.Append Join(sf,"<%>")
		next
		
		dim st(-1) as string
		if ubound(c)>=0 then
			for j as integer = 1 to c(0).nColumns
				st.Append c(0).ColumnName(j)+chr(9)+str(c(0).ColumnType(j))
			next
		end if
		
		dim m as integer
		dim b(-1) as string
		dim cap(-1) as string

		redim cap(ubound(s))
		redim b(ubound(v))

		for i=0 to ubound(v)
			if v(i) then b(i)="1" else b(i)="0"
		next

		for i=0 to ubound(s)
			cap(i)=s(i)
		next

		m=max(ubound(v),ubound(s))
		if m<0 then m=0

		while ubound(cap)<m
			cap.Append "Unknown"
		wend

		while ubound(b)<m
			b.Append "0"
		wend
		dim vsorted as double
		if sorted then
			vsorted=1
		else
			vsorted=0
		end if

		APC_SetPValue(11,sameline,title,Join(b,chr(9)),Join(cap,chr(9)),vsorted,maxvisible,Join(st,"<%>"))
	end sub

	sub CheckListParameter(title as string, v() as boolean, c() as MultiFieldObject, optional sorted as boolean = false, optional maxvisible as integer = 6)
		//- Select one or more items from a given set of items by means of a scrolling list with a checkbox associated with each entry. 
		//- The value for this type of parameter is an array of boolean values, 
		//- with each value being true if the corresponding item was selected/checked.
		//- c is an array of objects (two or more) that implement the MultiFieldObject interface. In 
		//- this case the list will have multiple columns, with corresponding values from the objects 
		//- populating the columns. Each one represents the caption of the corresponding line in the list. It 
		//- should have the same dimensionality as v.
		//- If sorted is true then the displayed list will be sorted alphabetically. However, 
		//- this does not affect the ordering of v or c.
		//- maxvisible represents the number of visible rows in the list (default = 6). If the 
		//- number of entries exceeds this, a vertical scroll bar will be displayed.
		CheckListParameter(false,title,v,c,sorted,maxvisible)
	end sub

  //....................................................................
  private function BooleanToStr(b as boolean) as string
		if b then return "1" else return "0"
	end function

	//....................................................................
	sub CaptionParameter(sameline as boolean, title as string, optional lines as integer = 1, optional grey as boolean = false, optional bold as boolean = false, optional italic as boolean = false, optional small as boolean = false, optional fullwidth as boolean = false)
		//- Display a simple text caption in the dialog.
		//- lines is the number of lines the caption should have (default = 1).
		//- If grey is true then the text is displayed in a grey shade rather than the default black.
		//- If bold is true then text is displayed in bold-face.
		//- If italic is true then text is displayed in italics.
		//- If small is true then text is displayed in a smaller text size.
		//- If fullwidth is true then text is displayed across all columns of the dialog.

		APC_SetPValue(7,sameline,title+"~"+format(Microseconds,"0"),format(lines,"-0"),BooleanToStr(grey)+ BooleanToStr(bold)+ BooleanToStr(italic)+ BooleanToStr(small)+ BooleanToStr(fullwidth))
	end sub

	sub CaptionParameter(title as string, optional lines as integer = 1, optional grey as boolean = false, optional bold as boolean = false, optional italic as boolean = false, optional small as boolean = false, optional fullwidth as boolean = false)
		//- Display a simple text caption in the dialog.
		//- lines is the number of lines the caption should have (default = 1).
		//- If grey is true then the text is displayed in a grey shade rather than the default black.
		//- If bold is true then text is displayed in bold-face.
		//- If italic is true then text is displayed in italics.
		//- If small is true then text is displayed in a smaller text size.
		//- If fullwidth is true then text is displayed across all columns of the dialog.
		CaptionParameter(false,title,lines,grey,bold,italic,small,fullwidth)
	end sub

	//....................................................................
	sub ImageParameter(sameline as boolean, img as Image, optional width as integer = 0, optional height as integer = 0)
		//- Draw an Image into the dialog. 
		//- If width and height are 0 (default) then the Image will be drawn at its full size (where possible).
		//- If width and/or height are >0 then the Image will be scaled to fit to the given size.
		
		APC_SetPValue(14,sameline,"Image."+str(img.APC_Img_Index)+"~"+format(Microseconds,"0"),format(img.APC_Img_Index,"-0"),"",width,height)
	end sub
	
	sub ImageParameter(img as Image, optional width as integer = 0, optional height as integer = 0)
		//- Draw an Image into the dialog. 
		//- If width and height are 0 (default) then the Image will be drawn at its full size (where possible).
		//- If width and/or height are >0 then the Image will be scaled to fit to the given size.
		ImageParameter(false,img,width,height)
	end sub
	
	//....................................................................
	sub CanvasParameter(sameline as boolean, c as Canvas, optional width as integer = 0, optional height as integer = 0)
		//- Draw a Canvas into the dialog. 
		//- The Canvas should be created using the Dialog.NewCanvas(width,height,...) constructor.
		//- If width and height are 0 (default) then the Canvas will be drawn at its full size (where possible).
		//- If width and/or height are >0 then the Canvas will be scaled to fit to the given size.
		
		APC_SetPValue(14,sameline,"Canvas."+str(c.cIdx)+"~"+format(Microseconds,"0"),format(c.cIdx,"-0"),"",width,height)
	end sub
	
	sub CanvasParameter(c as Canvas, optional width as integer = 0, optional height as integer = 0)
		//- Draw a Canvas into the dialog. 
		//- The Canvas should be created using the Dialog.NewCanvas(width,height,...) constructor.
		//- If width and height are 0 (default) then the Canvas will be drawn at its full size (where possible).
		//- If width and/or height are >0 then the Canvas will be scaled to fit to the given size.
		
		CanvasParameter(false,c,width,height)
	end sub
	
	shared function NewCanvas(width as integer, height as integer, optional plan as APPlan = nil) as Canvas
		//- Create a Canvas suitable (only) for adding to a Dialog via the CanvasParameter method.
		return new Canvas(0,width,height,plan)
	end function
	
	//....................................................................
  sub PlanParameter(sameline as boolean, title as string, v as APPlan, optional allowNew as boolean = false)
  	//- Select an open plan document. v is initial plan, or nil for creating a new plan (if allowed).
  	//- If allowNew is true then a "Create New Plan" entry is included.
  	dim s() as string
  	if allowNew then s.Append "Create New Plan"
  	dim n as integer = -1
  	for i as integer = 1 to APPlan.Count
  		dim p as APPlan = APPlan.Plan(i)
  		s.Append p.Name
  		if v<>nil and v=p then n=ubound(s)
  	next
  	if v=nil and allowNew then n=0
  	if n=-1 then n=CurrentPlanNumber
  	PopupParameter(sameline,title,n,s)
  	if allowNew then apc_AllowNew.Append title
  end sub
  
  sub PlanParameter(title as string, v as APPlan, optional allowNew as boolean = false)
  	//- Select an open plan document. v is initial plan, or nil for creating a new plan (if allowed).
  	//- If allowNew is true then a "Create New Plan" entry is included.
  	PlanParameter(false,title,v,allowNew)
  end sub
  	
	function PlanParameter(title as string) as APPlan
		//- Get the selected plan. If a new plan document was selected,
		//- a new untitled plan document will be created and its number returned.
		dim i as integer = PopupParameter(title)
		if apc_AllowNew.IndexOf(title)>=0 then
			if i=0 then 
				return APPlan.NewUntitled
			else 
				return Plan(i)
			end if
		else
			return Plan(i+1)
		end if
	end function

  //....................................................................
  sub UserFieldParameter(sameline as boolean, title as string, v as string, optional allowNew as boolean = false)
  	//- Select a user field from the current plan document. v is the initial user field title, or "<new>" for creating a new user field (if allowed).
  	//- If allowNew is true then a "New User Field" entry is included.
  	dim s() as string
  	if allowNew then s.Append "Create New User Field"
  	for i as integer = 1 to Plan().nUserFieldDefinitions
  		s.Append Plan().UserFieldDefinition(i).Title
  	next
  	dim n as integer
  	if v="<new>" and allowNew then 
  		n=0
  	else
  		n=s.IndexOf(v)
  	end if
  	if n<0 then n=0
  	PopupParameter(sameline,title,n,s)
  	if allowNew then apc_AllowNew.Append title
  end sub
  
  sub UserFieldParameter(title as string, v as string, optional allowNew as boolean = false)
  	//- Select a user field from the current plan document. v is the initial user field title, or "<New>" for creating a new user field (if allowed).
  	//- If allowNew is true then a "New User Field" entry is included.
  	UserFieldParameter(false,title,v,allowNew)
  end sub
  	
	function UserFieldParameter(title as string) as string
		//- Get the selected user field. If a new user field was requested, then you'll be prompted
		//- to create it. If you Cancel from that operation, "" will be returned.
		dim i as integer = PopupParameter(title)
		if apc_AllowNew.IndexOf(title)>=0 then
			if i=0 then 
				// create and select a new user field
				return APC_CreateNewUserFieldDefinition(-1)
			else 
				return Plan().UserFieldDefinition(i).Title
			end if
		else
			return Plan().UserFieldDefinition(i+1).Title
		end if
	end function

  //....................................................................
  
  const oc_All = 1
  const oc_Selected = 2
  const oc_Unselected = 4
  const oc_Highlighted = 8
  const oc_Unhighlighted = 16
  
  sub ObjectChoiceParameter(sameline as boolean, title as string, plan as APPlan, v as integer, optional which as uint32 = -1)
  	//- Choose what objects are to be considered in the given plan document.
  	//- This is a convenience parameter that sets up a ChoiceParameter containing these choices:
  	//- - All objects [nnn]
  	//- - Selected objects only [nnn]
  	//- - Unselected objects only [nnn]
  	//- - Highlighted objects only [nnn]
  	//- - Unhighlighted objects only [nnn]
  	//- If any of the nnn values is zero, then that entry will be omitted, 
  	//- apart from the first (which is always present)
  	//- Parameter v is the initial choice and is one of the following constants:
  	//-   oc_All
  	//-   oc_Selected
  	//-   oc_Unselected
  	//-   oc_Highlighted
  	//-   oc_Unhighlighted
  	//- If v represents a choice with a zero count, then oc_All will be assumed.
  	//- Parameter which is an OR-ed or added collection of the above oc_ constants, and defines which
  	//- options are presented. The default is for all options. e.g. if you're only interested in All or Selected objects
  	//- then use oc_All+oc_Selected. Note that even if you omit oc_All, 
  	//- it will be assumed to be present. 
  	
  	dim choices(-1) as string
  	dim p as APPlan = plan
  	if p=nil then p = Plan(-1)
  	
  	dim vdef as integer = 0
  	dim nAll as integer = p.nObjects
  	choices.Append "All objects ["+format(nAll,",0")+"]"
  	
  	dim n,what as integer
  	what=v
  	if what<oc_All or what>oc_Unhighlighted then what=oc_All
  	
  	n = p.nSelectedObjects
  	if n>0 then
  		if (which and oc_Selected)<>0 then 
  			choices.Append "Selected objects only ["+format(n,",0")+"]"
  			if what=oc_Selected then vdef=choices.Ubound
  		end if
  		if n<nAll and (which and oc_Unselected)<>0 then 
  			choices.Append "Unselected objects only ["+format(nAll-n,",0")+"]"
  			if what=oc_Unselected then vdef=choices.Ubound
  		end if
  	else
  		if what=oc_Selected or what=oc_Unselected then what=oc_All
  	end if
  	
  	n = p.nHighlighted
  	if n>0 then
  		if (which and oc_Highlighted)<>0 then 
  			choices.Append "Highlighted objects only ["+format(n,",0")+"]"
  			if what=oc_Highlighted then vdef=choices.Ubound
  		end if
  		if n<nAll and (which and oc_Unhighlighted)<>0 then 
  			choices.Append "Unhighlighted objects only ["+format(nAll-n,",0")+"]"
  			if what=oc_Unhighlighted then vdef=choices.Ubound
  		end if
  	else
  		if what=oc_Highlighted or what=oc_Unhighlighted then what=oc_All
  	end if
  	
  	ChoiceParameter(sameline,title,vdef,choices)
  end sub
  
  sub ObjectChoiceParameter(title as string, plan as APPlan, v as integer, optional which as uint32 = -1)
  	//- Choose what objects are to be considered.
  	//- This is a convenience parameter that sets up a ChoiceParameter containing these choices:
  	//- - All objects [nnn]
  	//- - Selected objects only [nnn]
  	//- - Unselected objects only [nnn]
  	//- - Highlighted objects only [nnn]
  	//- - Unhighlighted objects only [nnn]
  	//- If any of the nnn values is zero, then that entry will be omitted, 
  	//- apart from the first (which is always present)
  	//- Parameter v is the initial choice and is one of the following constants:
  	//-   oc_All
  	//-   oc_Selected
  	//-   oc_Unselected
  	//-   oc_Highlighted
  	//-   oc_Unhighlighted
  	//- If v represents a choice with a zero count, then oc_All will be assumed.
  	//- Parameter which is an OR-ed or added collection of the above oc_ constants, and defines which
  	//- options are presented. The default is for all options. e.g. if you're only interested in All or Selected objects
  	//- then use oc_All+oc_Selected. Note that even if you omit oc_All, 
  	//- it will be assumed to be present. 
  	ObjectChoiceParameter(false,title,plan,v,which)
  end sub
  
  function ObjectChoiceParameter(title as string) as integer
  	//- Returns one of the following constants:
  	//-   oc_All
  	//-   oc_Selected
  	//-   oc_Unselected
  	//-   oc_Highlighted
  	//-   oc_Unhighlighted
    
    dim s as string = ChoiceParameterAsString(title)
    if s.Contains("Unselected") then return oc_Unselected
    if s.Contains("Selected") then return oc_Selected
    if s.Contains("Unhighlighted") then return oc_Unhighlighted
    if s.Contains("Highlighted") then return oc_Highlighted
    return oc_All
  end function
  
  //....................................................................
	sub AddPushButton(caption as string)
		//- Add a push button with the given caption to the dialog. 
		//- Clicking the button dismisses the dialog in the same fashion as OK. 
		//- Use the GetPushButton method to determine if this button was clicked.
		if apc_PushButton.IndexOf(caption)<0 then apc_PushButton.Append caption
	end sub

	function GetPushButton(caption as string) as boolean
		//- Determine if the push button with the given caption was clicked.
		return apc_PushButton.IndexOf(caption)>=0
	end function

	sub ParameterDependency(dependent as string, dependentOn as string)
		//- Creates a dependency between a parameter (dependent) and a BooleanParameter (dependentOn). 
		//- The two parameters must match the titles of a xxxParameter call and, in particular, 
		//- dependentOn must match the title of a BooleanParameter call.
		//- When the dependentOn Boolean parameter is checked, the dependent parameter will be enabled and vice-versa.
		apc_dependencyA.Append dependent
		apc_dependencyB.Append dependentOn
	end sub

	sub ParameterWindowBackdrop(path as string, optional startBelow as boolean = false, optional cacheImage as boolean = false)
		Deprecate("Dialog.ParameterWindowBackdrop","Dialog.BackdropImage")
		BackdropImage(path,startBelow,cacheImage)
	end sub

	sub BackdropImage(path as string, optional startBelow as boolean = false, optional cacheImage as boolean = false)
		//- Put a backdrop image in the dialog, as defined by path. 
		//- If path is an URL, i.e. starts with “http://...” then the URL is assumed to point at an image file on the Internet. 
		//- Otherwise, path is assumed to be a file path. Must be called prior to calling the Show method.
		//- The backdrop image will be displayed in the dialog. 
		//- The dialog will be increased in size to fit the image if necessary. 
		//- The image will be anchored at the top left corner of the dialog window. 
		//- If startBelow is true (default: false), then any controls in the dialog will appear below the image, 
		//- rather than superimposed on top (useful for banners); 
		//- in either case the OK/Cancel button will always be displayed below the graphic.
		//- If cacheImage is true (default: false), then the image file will be cached on disk and 
		//- any future calls with the same path will use the cached image rather than loading/downloading the original.
		APC_ParameterWindowBackdrop(path,startBelow,cacheImage)
	end sub

	sub ParameterWindowNoCancel()
		Deprecate("Dialog.ParameterWindowNoCancel","Dialog.NoCancel")
		NoCancel
	end sub

	sub NoCancel()
		//- Omit the Cancel button.
		APC_ParameterWindowNoCancel
	end sub

	sub ParameterWindowOKCaption(caption as string)
		Deprecate("Dialog.ParameterWindowOKCaption","Dialog.OKCaption")
		OKCaption(caption)
	end sub

	sub OKCaption(caption as string)
		//- Change the caption of the OK button.
		APC_ParameterWindowOKCaption(caption)
	end sub

	function DoubleClickedList() as string
		//- If two or more list parameters can be double-clicked to dismiss the dialog, 
		//- then this function can be used to return the title of the list that was double-clicked.
		return APC_DoubleClickedList()
	end function

  // Shared stuff
  
	shared function Choice(ParamArray s as string) as integer
		//- Display a dialog with a number of radio buttons, with the captions contained in s. 
		//- Return the index of the selected radio button (0...s.UBound), 
		//- or -1 if the Cancel button is clicked.
		return APC_Choice(s)
	end function

	shared function Choice(s() as string) as integer
		//- Display a dialog with a number of radio buttons, with the captions contained in s. 
		//- Return the index of the selected radio button (0...s.UBound), 
		//- or -1 if the Cancel button is clicked.
		return APC_Choice(s)
	end function

	shared function Options(ParamArray s as string) as integer
		//- Display a dialog with a number of checkboxes, with the captions contained in s. 
		//- Return an integer comprised of bits, where bit 0 corresponds to s(0), etc. 
		//- Each bit will be 1 if the corresponding checkbox is checked, 0 otherwise. 
		//- -1 is returned if the Cancel button is clicked.
		return APC_Options(s)
	end function

	shared function Options(s() as string) as integer
		//- Display a dialog with a number of checkboxes, with the captions contained in s. 
		//- Return an integer comprised of bits, where bit 0 corresponds to s(0), etc. 
		//- Each bit will be 1 if the corresponding checkbox is checked, 0 otherwise. 
		//- -1 is returned if the Cancel button is clicked.
		return APC_Options(s)
	end function

	shared function OKCancel(body as string, optional default as boolean = true) as boolean
		//- Creates a dialog with OK and Cancel buttons and the text contained in body. 
		//- The default parameter (default = true) specifies which is the default button (true = OK, false = Cancel). 
		//- Returns true if OK clicked, false if Cancel clicked. 
		//- If necessary, the dialog is enlarged to handle large amounts of text.
		return APC_OKCancel("OK","Cancel",body,default)
	end function

	shared function YesNo(body as string, optional default as boolean = true) as boolean
		//- Creates a dialog with Yes and No buttons and the text contained in body. 
		//- The default parameter (default = true) specifies which is the default button (true = Yes, false = No). 
		//- Returns true if Yes clicked, false if No clicked. 
		//- If necessary, the dialog is enlarged to handle large amounts of text.
		return APC_OKCancel("Yes","No",body,default)
	end function

	shared function Confirmation(body as string, button1 as string, button2 as string, optional default as boolean = true) as boolean
		//- This is identical to YesNo or OKCancel, except that you can choose your own text for the buttons. 
		//- Returns true if button1 is pressed (right button on Mac, left button on Windows) or false if button2 is pressed. 
		//- If necessary, buttons are resized to handle long captions. 
		//- If either button1 or button2 (but not both) is an empty string, the corresponding button will be invisible.
		return APC_OKCancel(button1,button2,body,default)
	end function

	shared sub StartProgress(optional c as string = "", optional canCancel as boolean = false, optional mx as double = 100.0)
		//- Show a floating progress window.
		//- If c is present and non-blank, then it is included above the progress bar.
		//- If canCancel is true (default is false) then a Cancel button is displayed. 
		//- Cancellation is identified by the UpdateProgress method.
		//- If mx is present (default = 100.0) then this specifies the upper value of the progress bar. 
		//- The lower value is 0.0.
		APC_StartProgress(c,canCancel,mx)
	end sub

	shared sub StopProgress()
		//- Remove the progress window displayed by StartProgress.
		APC_StopProgress
	end sub

	shared function UpdateProgress(optional v as double = -999.0) as boolean
		//- Call this regularly in a StartProgress/StopProgress-bracketed loop. 
		//- Pass the current value of the progress bar as v. 
		//- If v is omitted the progress bar will display the “barber pole” pattern (Mac) or the “idling” pattern (Windows).
		//- If true is returned, it means the Cancel button was clicked.
		return APC_UpdateProgress(v)
	end function
	
	shared function Choose(multiple as boolean, plist() as NamedObject, objectDescription as string) as NamedObject()
		//- Use a dialog to select one or more objects from a list of NamedObjects.
		//- If multiple is true, allow selecting zero or more objects.
		//- If multiple is false, allow selection of a single object.
		//- plist() is an array of NamedObjects to choose from.
		//- objectDescription is a description of the object. e.g. "Plan", "Telescope", etc.
		//- If the Cancel button is used (or the dialog closed), or no object is selected, 
		//- then an empty array is returned.
	
		dim p(-1) as NamedObject
	
		dim dlg as new Dialog
	
		dim caption as string = "Select "+objectDescription
		if multiple then caption = caption + "s"
		dim heading as string = objectDescription+"s"
	
		dim vlist() as boolean
		dim v as integer = -1
		if multiple then
			redim vlist(plist.Ubound)

			dlg.CheckListParameter(heading,vlist,plist,true,12)
		else
			dlg.ListChoiceParameter(heading,v,plist,true,12,true)
		end if
		if not dlg.Show(caption) then return p
	
		if multiple then
			vlist = dlg.CheckListParameter(heading)
			for i as integer = 0 to vlist.Ubound
				if vlist(i) then p.Append plist(i)
			next
		else
			v = dlg.ListChoiceParameter(heading)
			if v>=0 then p.Append plist(v)
		end if
		return p
	end function

end class

//------------------------------------------------------------------------------------
module EditParametersStuff // deprecate
	//- Use Dialog class instead of the methods in this module
	private dim apc_dlg as Dialog
	private dim apc_dlg_restart as boolean
	
	private sub APC_dlg_Setup()
		if apc_dlg=nil or apc_dlg_restart then 
			apc_dlg=new Dialog
			apc_dlg_restart=false
		end if
	end sub
	
	sub SetIntegerParameter(sameline as boolean, title as string, v as integer, optional minv as integer = -2000000000, optional maxv as integer = 2000000000)
		Deprecate("SetIntegerParameter","Dialog.IntegerParameter")
		APC_dlg_Setup
		apc_dlg.IntegerParameter(sameline,title,v,minv,maxv)
	end sub

	sub SetIntegerParameter(title as string, v as integer, optional minv as integer = -2000000000, optional maxv as integer = 2000000000)
		Deprecate("SetIntegerParameter","Dialog.IntegerParameter")
		SetIntegerParameter(false,title,v,minv,maxv)
	end sub

	sub SetBooleanParameter(sameline as boolean, title as string, v as boolean)
		Deprecate("SetBooleanParameter","Dialog.BooleanParameter")
		APC_dlg_Setup
		apc_dlg.BooleanParameter(sameline,title,v)
	end sub

	sub SetBooleanParameter(title as string, v as boolean)
		Deprecate("SetBooleanParameter","Dialog.BooleanParameter")
		SetBooleanParameter(false,title,v)
	end sub

	sub SetDoubleParameter(sameline as boolean, title as string, v as double, optional minv as double = -1E200, optional maxv as double = 1E200)
		Deprecate("SetDoubleParameter","Dialog.DoubleParameter")
		APC_dlg_Setup
		apc_dlg.DoubleParameter(sameline,title,v,minv,maxv)
	end sub

	sub SetDoubleParameter(title as string, v as double, optional minv as double = -1E200, optional maxv as double = 1E200)
		Deprecate("SetDoubleParameter","Dialog.DoubleParameter")
		SetDoubleParameter(false,title,v,minv,maxv)
	end sub

	sub SetColorParameter(sameline as boolean, title as string, v as Color)
		Deprecate("SetColorParameter","Dialog.ColorParameter")
		APC_dlg_Setup
		apc_dlg.ColorParameter(sameline,title,v)
	end sub

	sub SetColorParameter(title as string, v as Color)
		Deprecate("SetColorParameter","Dialog.ColorParameter")
		SetColorParameter(false,title,v)
	end sub

	sub SetStringParameter(sameline as boolean, title as string, v as string, optional multiline as boolean = false)
		Deprecate("SetStringParameter","Dialog.StringParameter")
		APC_dlg_Setup
		apc_dlg.StringParameter(sameline,title,v,multiline)
	end sub

	sub SetStringParameter(title as string, v as string, optional multiline as boolean = false)
		Deprecate("SetStringParameter","Dialog.StringParameter")
		SetStringParameter(false,title,v,multiline)
	end sub

	sub SetChoiceParameter(sameline as boolean, title as string, v as integer, paramarray c as string)
		Deprecate("SetChoiceParameter","Dialog.ChoiceParameter")
		APC_dlg_Setup
		apc_dlg.ChoiceParameter(sameline,title,v,c)
	end sub

	sub SetChoiceParameter(title as string, v as integer, paramarray c as string)
		Deprecate("SetChoiceParameter","Dialog.ChoiceParameter")
		APC_dlg_Setup
		apc_dlg.ChoiceParameter(title,v,c)
	end sub

	sub SetChoiceParameter(sameline as boolean, title as string, v as integer, c() as string)
		Deprecate("SetChoiceParameter","Dialog.ChoiceParameter")
		APC_dlg_Setup
		apc_dlg.ChoiceParameter(sameline,title,v,c)
	end sub

	sub SetChoiceParameter(title as string, v as integer, c() as string)
		Deprecate("SetChoiceParameter","Dialog.ChoiceParameter")
		APC_dlg_Setup
		apc_dlg.ChoiceParameter(title,v,c)
	end sub

	sub SetChoiceParameter(sameline as boolean, title as string, v as integer, c() as NamedObject)
		Deprecate("SetChoiceParameter","Dialog.ChoiceParameter")
		APC_dlg_Setup
		apc_dlg.ChoiceParameter(sameline,title,v,c)
	end sub

	sub SetChoiceParameter(title as string, v as integer, c() as NamedObject)
		Deprecate("SetChoiceParameter","Dialog.ChoiceParameter")
		SetChoiceParameter(false,title,v,c)
	end sub

	sub SetListChoiceParameter(sameline as boolean, title as string, v as integer, c() as string, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		Deprecate("SetListChoiceParameter","Dialog.ListChoiceParameter")
		APC_dlg_Setup
		apc_dlg.ListChoiceParameter(sameline,title,v,c,sorted,maxvisible,doubleclick)
	end sub

	sub SetListChoiceParameter(title as string, v as integer, c() as string, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		Deprecate("SetListChoiceParameter","Dialog.ListChoiceParameter")
		SetListChoiceParameter(false,title,v,c,sorted,maxvisible,doubleclick)
	end sub

	sub SetListChoiceParameter(sameline as boolean, title as string, v as integer, c() as NamedObject, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		Deprecate("SetListChoiceParameter","Dialog.ListChoiceParameter")
		APC_dlg_Setup
		apc_dlg.ListChoiceParameter(sameline,title,v,c,sorted,maxvisible,doubleclick)
	end sub

	sub SetListChoiceParameter(title as string, v as integer, c() as NamedObject, optional sorted as boolean = false, optional maxvisible as integer = 6, optional doubleclick as boolean = false)
		Deprecate("SetListChoiceParameter","Dialog.ListChoiceParameter")
		SetListChoiceParameter(false,title,v,c,sorted,maxvisible,doubleclick)
	end sub

	function DoubleClickedList() as string
		Deprecate("DoubleClickedList","Dialog.DoubleClickedList")
		return APC_DoubleClickedList()
	end function

	sub SetPopupParameter(sameline as boolean, title as string, v as integer, c() as string)
		Deprecate("SetPopupParameter","Dialog.PopupParameter")
		APC_dlg_Setup
		apc_dlg.PopupParameter(sameline,title,v,c)
	end sub

	sub SetPopupParameter(title as string, v as integer, c() as string)
		Deprecate("SetPopupParameter","Dialog.PopupParameter")
		SetPopupParameter(false,title,v,c)
	end sub

	sub SetPopupParameter(sameline as boolean, title as string, v as integer, c() as NamedObject)
		Deprecate("SetPopupParameter","Dialog.PopupParameter")
		APC_dlg_Setup
		apc_dlg.PopupParameter(sameline,title,v,c)
	end sub

	sub SetPopupParameter(title as string, v as integer, c() as NamedObject)
		Deprecate("SetPopupParameter","Dialog.PopupParameter")
		SetPopupParameter(false,title,v,c)
	end sub

	sub SetDateParameter(sameline as boolean, title as string, v as double, optional minv as double = 0.0, optional maxv as double = 1E200)
		Deprecate("SetDateParameter","Dialog.DateParameter")
		APC_dlg_Setup
		apc_dlg.DateParameter(sameline,title,v,minv,maxv)
	end sub

	sub SetDateParameter(title as string, v as double, optional minv as double = 0.0, optional maxv as double = 1E200)
		Deprecate("SetDateParameter","Dialog.DateParameter")
		SetDateParameter(false,title,v,minv,maxv)
	end sub

	sub SetTimeParameter(sameline as boolean, title as string, v as double)
		Deprecate("SetTimeParameter","Dialog.TimeParameter")
		APC_dlg_Setup
		apc_dlg.TimeParameter(sameline,title,v)
	end sub

	sub SetTimeParameter(title as string, v as double)
		Deprecate("SetTimeParameter","Dialog.TimeParameter")
		SetTimeParameter(false,title,v)
	end sub

	sub SetSliderParameter(sameline as boolean, title as string, v as double, optional minv as double = 0.0, optional maxv as double = 100.0, optional stepv as double = 1.0)
		Deprecate("SetSliderParameter","Dialog.SliderParameter")
		APC_dlg_Setup
		apc_dlg.SliderParameter(sameline,title,v,minv,maxv,stepv)
	end sub

	sub SetSliderParameter(title as string, v as double, optional minv as double = 0.0, optional maxv as double = 100.0, optional stepv as double = 1.0)
		Deprecate("SetSliderParameter","Dialog.SliderParameter")
		SetSliderParameter(false,title,v,minv,maxv,stepv)
	end sub

	sub SetSliderParameter(sameline as boolean, title as string, v as integer, c() as string)
		Deprecate("SetSliderParameter","Dialog.SliderParameter")
		APC_dlg_Setup
		apc_dlg.SliderParameter(sameline,title,v,c)
	end sub

	sub SetSliderParameter(title as string, v as integer, c() as string)
		Deprecate("SetSliderParameter","Dialog.SliderParameter")
		SetSliderParameter(false,title,v,c)
	end sub

	sub SetSliderParameter(sameline as boolean, title as string, v as integer, paramarray c as string)
		Deprecate("SetSliderParameter","Dialog.SliderParameter")
		SetSliderParameter(sameline,title,v,c)
	end sub

	sub SetSliderParameter(title as string, v as integer, paramarray c as string)
		Deprecate("SetSliderParameter","Dialog.SliderParameter")
		SetSliderParameter(false,title,v,c)
	end sub

	sub SetSliderParameter(sameline as boolean, title as string, v as integer, c() as NamedObject)
		Deprecate("SetSliderParameter","Dialog.SliderParameter")
		APC_dlg_Setup
		apc_dlg.SliderParameter(sameline,title,v,c)
	end sub

	sub SetSliderParameter(title as string, v as integer, c() as NamedObject)
		Deprecate("SetSliderParameter","Dialog.SliderParameter")
		SetSliderParameter(false,title,v,c)
	end sub

	sub SetCheckListParameter(sameline as boolean, title as string, v() as boolean, c() as string, optional sorted as boolean = false, optional maxvisible as integer = 6)
		Deprecate("SetCheckListParameter","Dialog.CheckListParameter")
		APC_dlg_Setup
		apc_dlg.CheckListParameter(sameline,title,v,c,sorted,maxvisible)
	end sub

	sub SetCheckListParameter(title as string, v() as boolean, c() as string, optional sorted as boolean = false, optional maxvisible as integer = 6)
		Deprecate("SetCheckListParameter","Dialog.CheckListParameter")
		SetCheckListParameter(false,title,v,c,sorted,maxvisible)
	end sub

	sub SetCheckListParameter(title as string, v() as boolean, paramarray c as string)
		Deprecate("SetCheckListParameter","Dialog.CheckListParameter")
		SetCheckListParameter(false,title,v,c)
	end sub

	sub SetCheckListParameter(sameline as boolean, title as string, v() as boolean, paramarray c as string)
		Deprecate("SetCheckListParameter","Dialog.CheckListParameter")
		SetCheckListParameter(sameline,title,v,c)
	end sub

	sub SetCheckListParameter(sameline as boolean, title as string, v() as boolean, c() as NamedObject, optional sorted as boolean = false, optional maxvisible as integer = 6)
		Deprecate("SetCheckListParameter","Dialog.CheckListParameter")
		APC_dlg_Setup
		apc_dlg.CheckListParameter(sameline,title,v,c,sorted,maxvisible)
	end sub

	sub SetCheckListParameter(title as string, v() as boolean, c() as NamedObject, optional sorted as boolean = false, optional maxvisible as integer = 6)
		Deprecate("SetCheckListParameter","Dialog.CheckListParameter")
		SetCheckListParameter(false,title,v,c,sorted,maxvisible)
	end sub

	sub SetCaptionParameter(sameline as boolean, title as string, optional lines as integer = 1, optional grey as boolean = false, optional bold as boolean = false, optional italic as boolean = false, optional small as boolean = false, optional fullwidth as boolean = false)
		Deprecate("SetCaptionParameter","Dialog.CaptionParameter")
		APC_dlg_Setup
		apc_dlg.CaptionParameter(sameline,title,lines,grey,bold,italic,small,fullwidth)
	end sub

	sub SetCaptionParameter(title as string, optional lines as integer = 1, optional grey as boolean = false, optional bold as boolean = false, optional italic as boolean = false, optional small as boolean = false, optional fullwidth as boolean = false)
		Deprecate("SetCaptionParameter","Dialog.CaptionParameter")
		SetCaptionParameter(false,title,lines,grey,bold,italic,small,fullwidth)
	end sub

  sub SetPlanParameter(sameline as boolean, title as string, v as APPlan, optional allowNew as boolean = false)
  	//- Select an open plan document. v is initial plan, or nil for creating a new plan (if allowed).
  	//- If allowNew is true then a "Create New Plan" entry is included.
		Deprecate("SetPlanParameter","Dialog.PlanParameter")
		APC_dlg_Setup
		apc_dlg.PlanParameter(sameline,title,v,allowNew)
  end sub
  
  sub SetPlanParameter(title as string, v as APPlan, optional allowNew as boolean = false)
  	//- Select an open plan document. v is initial plan, or nil for creating a new plan (if allowed).
  	//- If allowNew is true then a "Create New Plan" entry is included.
		Deprecate("SetPlanParameter","Dialog.PlanParameter")
  	SetPlanParameter(false,title,v,allowNew)
  end sub
  	
  sub SetUserFieldParameter(sameline as boolean, title as string, v as string, optional allowNew as boolean = false)
  	//- Select a user field from the current plan document. v is the initial user field title, or "<new>" for creating a new user field (if allowed).
  	//- If allowNew is true then a "New User Field" entry is included.
		Deprecate("SetUserFieldParameter","Dialog.UserFieldParameter")
		APC_dlg_Setup
		apc_dlg.UserFieldParameter(sameline,title,v,allowNew)
  end sub
  
  sub SetUserFieldParameter(title as string, v as string, optional allowNew as boolean = false)
  	//- Select a user field from the current plan document. v is the initial user field title, or "<New>" for creating a new user field (if allowed).
  	//- If allowNew is true then a "New User Field" entry is included.
		Deprecate("SetUserFieldParameter","Dialog.UserFieldParameter")
  	SetUserFieldParameter(false,title,v,allowNew)
  end sub
  	
	sub AddPushButton(caption as string)
		Deprecate("AddPushButton","Dialog.AddPushButton")
		APC_dlg_Setup
		apc_dlg.AddPushButton(caption)
	end sub

	function GetPushButton(caption as string) as boolean
		Deprecate("GetPushButton","Dialog.GetPushButton")
		APC_dlg_Setup
		return apc_dlg.GetPushButton(caption)
	end function

	sub ParameterDependency(dependent as string, dependentOn as string)
		Deprecate("ParameterDependency","Dialog.ParameterDependency")
		APC_dlg_Setup
		apc_dlg.ParameterDependency(dependent,dependentOn)
	end sub

	sub ParameterWindowBackdrop(path as string, optional startBelow as boolean = false, optional cacheImage as boolean = false)
		Deprecate("ParameterWindowBackdrop","Dialog.ParameterWindowBackdrop")
		APC_dlg_Setup
		apc_dlg.ParameterWindowBackdrop(path,startBelow,cacheImage)
	end sub

	sub ParameterWindowNoCancel()
		Deprecate("ParameterWindowNoCancel","Dialog.ParameterWindowNoCancel")
		APC_dlg_Setup
		apc_dlg.ParameterWindowNoCancel
	end sub

	sub ParameterWindowOKCaption(caption as string)
		Deprecate("ParameterWindowOKCaption","Dialog.ParameterWindowOKCaption")
		APC_dlg_Setup
		apc_dlg.ParameterWindowOKCaption(caption)
	end sub

	function EditParameters(optional title as string = "", optional debugMode as boolean = false) as boolean
		Deprecate("EditParameters","Dialog.Show")
		APC_dlg_Setup
		apc_dlg_restart=true
		return apc_dlg.Show(title,debugMode)
	end function

	function GetDoubleParameter(title as string) as double
		Deprecate("GetDoubleParameter","Dialog.DoubleParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.DoubleParameter(title)
	end function

	function GetColorParameter(title as string) as Color
		Deprecate("GetColorParameter","Dialog.ColorParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.ColorParameter(title)
	end function

	function GetPlanParameter(title as string) as APPlan
		//- Get the selected plan. If a new plan document was selected,
		//- a new untitled plan document will be created and its number returned.
		Deprecate("GetPlanParameter","Dialog.PlanParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.PlanParameter(title)
	end function

	function GetUserFieldParameter(title as string) as string
		//- Get the selected user field. If a new user field was requested, then you'll be prompted
		//- to create it. If you Cancel from that operation, "" will be returned.
		Deprecate("GetUserFieldParameter","Dialog.UserFieldParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.UserFieldParameter(title)
	end function

	function GetIntegerParameter(title as string) as integer
		Deprecate("GetIntegerParameter","Dialog.IntegerParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.IntegerParameter(title)
	end function

	function GetBooleanParameter(title as string) as boolean
		Deprecate("GetBooleanParameter","Dialog.BooleanParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.BooleanParameter(title)
	end function

	function GetStringParameter(title as string) as string
		Deprecate("GetStringParameter","Dialog.StringParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.StringParameter(title)
	end function

	function GetChoiceParameter(title as string) as integer
		Deprecate("GetChoiceParameter","Dialog.ChoiceParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.ChoiceParameter(title)
	end function

	function GetChoiceParameterAsString(title as string) as string
		Deprecate("GetChoiceParameterAsString","Dialog.ChoiceParameterAsString")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.ChoiceParameterAsString(title)
	end function

	function GetListChoiceParameter(title as string) as integer
		Deprecate("GetListChoiceParameter","Dialog.ListChoiceParameter")
		return GetChoiceParameter(title)
	end function

	function GetListChoiceParameterAsString(title as string) as string
		Deprecate("GetListChoiceParameterAsString","Dialog.ListChoiceParameterAsString")
		return GetChoiceParameterAsString(title)
	end function

	function GetPopupParameter(title as string) as integer
		Deprecate("GetPopupParameter","Dialog.PopupParameter")
		return GetChoiceParameter(title)
	end function

	function GetPopupParameterAsString(title as string) as string
		Deprecate("GetPopupParameterAsString","Dialog.PopupParameterAsString")
		return GetChoiceParameterAsString(title)
	end function

	function GetDateParameter(title as string) as double
		Deprecate("GetDateParameter","Dialog.DateParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.DateParameter(title)
	end function

	function GetTimeParameter(title as string) as double
		Deprecate("GetTimeParameter","Dialog.TimeParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.TimeParameter(title)
	end function

	function GetSliderParameter(title as string) as double
		Deprecate("GetSliderParameter","Dialog.SliderParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.SliderParameter(title)
	end function

	function GetCheckListParameter(title as string) as boolean()
		Deprecate("GetCheckListParameter","Dialog.CheckListParameter")
		if apc_dlg=nil then apc_dlg=new Dialog
		return apc_dlg.CheckListParameter(title)
	end function
	
end module

//------------------------------------------------------------------------------------
module OldListWindowStuff // deprecate
	//- NOTE: Deprecated: Use the ListWindow class instead.
	
	sub AddToList(listnum as integer, row as integer, column as integer, v as string)
		Deprecate("AddToList","ListWindow.Cell")
		APC_LW_Add(listnum,row,column,v,"")
	end sub

	sub AddToList(listnum as integer, row as integer, column as integer, v as integer)
		Deprecate("AddToList","ListWindow.Cell")
		APC_LW_Add(listnum,row,column,v)
	end sub

	sub AddToList(listnum as integer, row as integer, column as integer, v as boolean)
		Deprecate("AddToList","ListWindow.Cell")
		APC_LW_Add(listnum,row,column,v)
	end sub

	sub AddToList(listnum as integer, row as integer, column as integer, v as double, optional fmat as string = "")
		Deprecate("AddToList","ListWindow.Cell")
		APC_LW_Add(listnum,row,column,v,fmat)
	end sub

	sub ListHeading(listnum as integer, column as integer, title as string, optional alignment as integer = 0)
		Deprecate("ListHeading","ListWindow.Heading")
		APC_LW_SetHeading(listnum,column,title,alignment)
	end sub

	function NewList(optional title as string = "") as integer
		Deprecate("NewList","new ListWindow")
		return APC_LW_New(title)
	end function

	sub SortList(list as integer, column as integer, optional ascending as boolean = true, optional num as boolean = false)
		Deprecate("SortList","ListWindow.Sort")
		APC_LW_Sort(list,column,ascending,num)
	end sub

	function GetList(list as integer, row as integer, column as integer) as string
		Deprecate("GetList","ListWindow.Cell")
		return APC_LW_Get(list,row,column)
	end function
	
end module

//------------------------------------------------------------------------------------
module CatalogueStuff // deprecate
	
	function nCatalogs() as integer
		Deprecate("nCatalogs","APCatalog.Count")
		return APCatalog.Count
	end function

	function GetCatalog(n as integer) as APCatalog
		Deprecate("GetCatalog(n)","APCatalog.Catalog(n)")
		return APCatalog.Catalog(n)
	end function

	function GetCatalog(name as string) as APCatalog
		Deprecate("GetCatalog(name)","APCatalog.Catalog(name)")
		return APCatalog.Catalog(name)
	end function

	function Catalogs( ) as APCatalog()
		Deprecate("Catalogs()","APCatalog.Catalogs()")
		return APCatalog.Catalogs
	end function

	function CatalogsWithType(ntype as integer) as APCatalog()
		Deprecate("CatalogsWithType()","APCatalog.CatalogsWithType()")
		return APCatalog.CatalogsWithType(ntype)
	end function
	
end module

//------------------------------------------------------------------------------------
module APCallable
	// Documented 2012/9/24
	//- This module contains various constants and methods that are not logically part of any other framework class. 
	//- In all cases you can call the methods or use the constants directly 
	//- (i.e. you do not need to precede the call with "APCallable.").

  const pi = 3.14159265359
  //- Ratio of the circumference of a circle to the diameter.
  const RadiansToDegrees = 57.29577951308
  //- Convert radians to degrees by multiplying by this value (180/pi)
  const DegreesToRadians = 0.01745329251994
  //- Convert degrees to radians by multiplying by this value (pi/180)
  const RadiansToHours = 3.819718634205
  //- Convert radians to hours (1 hour = 15 degrees) by multiplying by this value (12/pi)
  const HoursToRadians = 0.2617993877991
  //- Convert hours (1 hour = 15 degrees) to radians by multiplying by this value (pi/12)
  
	const list_ID = 1
	//- Used by the APPlan.SortObjectList method to assign which column determines the sort order of the object list.
	const list_Images = 2
	const list_Name = 3
	const list_Type = 4
	const list_RA = 5
	const list_Dec = 6
	const list_Azimuth = 7
	const list_Altitude = 8
	const list_Rise = 9
	const list_Transit = 10
	const list_Set = 11
	const list_Visible = 12
	const list_Observations = 13
	const list_Rating = 14
	const list_ODM = 15
	const list_Magnitude = 16
	const list_Magnitude2 = 17
	const list_Separation = 18
	const list_DifficultyIndex = 19
	const list_LordRating = 20
	const list_Size = 21
	const list_Constellation = 22
	const list_Catalog = 23
	const list_AirMass = 24
	//- Used by the APPlan.SortObjectList method to assign which column determines the sort order of the object list.
	const list_HJD = 25
	const list_Extinct = 26
	const list_AppMag = 27
	const list_HourAngle = 28
	const list_Chart = 29
	const list_Spectral = 30
	const list_SurfaceBrightness = 31
	const list_PosAngle = 32
	const list_Period = 33
	const list_LogObjectContrast = 34
	const list_TransitDate = 35
	const list_MoonDistance = 36
	const list_SunDistance = 37
	const list_TransitAltitude = 38
	const list_Notes = 39
	const list_Found = 40
	const list_TelescopeDistance = 41
	const list_Probability = 42
	const list_Probability2 = 43
	const list_ParallacticAngle = 44
	const list_PCWLevel = 45
	const list_Observability = 46
	const list_BestTime = 47
	const list_Splitability = 48

	const platform_MacOSX = 1
	//- Returned by the Platform method if the script is running on Mac OS X
	const platform_Windows = 3
	//- Returned by the Platform method if the script is running on Windows

	const kbd_Shift = 2233441
	//- Used as the parameter in the KeyDown and KeyName methods
	const kbd_Control = 2233442
	const kbd_Option = 2233443
	const kbd_Command = 2233444
	const kbd_Alt = 2233444
	//- Used as the parameter in the KeyDown and KeyName methods

	const mss_Default = 0
	//- Constants used by parameters in the MinimumSlewSort methods of APPlan.
	const mss_RADec = 1
	const mss_AzAlt = 2
	const mss_Application = -1
	//- Constants used by parameters in the MinimumSlewSort methods of APPlan.

	const mss_NoWeight = 0
	const mss_LowWeight = 1
	const mss_HighWeight = 2

	const pfont_Heading = 0
	const pfont_Footer = 1
	const pfont_Body = 2
	//- Used by the PrintingFont and PrintingFontSize methods.
	const pfont_Chart = 3
	const pfont_Legend = 4
	const pfont_Script = 5

  const evt_None = -1
  //- Used by the EventType method to determine which (if any) event caused the script to run.
	const evt_OnOpen = 0
	const evt_OnClose = 1
	const evt_OnNewObject = 2
	const evt_OnDeleteObject = 3
	const evt_OnObjectChange = 4
	const evt_OnVisibilityUpdate = 5
	const evt_OnPrintObjectsStart = 6
	const evt_OnPrintObjectsEnd = 7
	const evt_OnNewObservation = 8
	const evt_OnDeleteObservation = 9
	const evt_OnObservationChange = 10
	const evt_OnPrintObservationsStart = 11
	const evt_OnPrintObservationsEnd = 12
	
	const icon_Note = 0
	//- Used by the Print(icon,body,title) method.
	const icon_Stop = 1
	const icon_Caution = 2
	//- Used by the Print(icon,body,title) method.
	const icon_Question = 3
	


//# Function EventType() As integer
//- Return the event type that caused this script to run (see evt_ constants), or -1 (evt_None) if it was not caused by an event.
//# End Function

//# Function KeyDown(keycode as integer) As boolean
//- Determine if the specified key on the keyboard is currently down. 
//- Keys are specified by a numeric keycode, which is keyboard and OS dependent (see KeyName below). 
//- Some modifier keycodes have predefined constants that can be used (use kbd_ constants).
//# End Function

//# Function KeyName(keycode as integer) As string
//- Return the name of the specified modifier key on the keyboard. 
//- Use the kbd_ constants to specify the keycode.
//# End Function

Sub MinimumSlewSort(nPlan as integer)
	Deprecate("MinimumSlewSort(nPlan)","APPlan.MinimumSlewSort")
	APC_MinimumSlewSortBasic(nPlan)
End Sub

//# Sub OpenURL(url as string)
//- Open the specified URL using the appropriate application 
//- (e.g. an "http://..." URL will be opened in your web browser, 
//- a "mailto:" URL will be handled by your e-mail client application, etc.)
//# End Sub

//# Function Platform() As integer
//- Returns the hardware platform upon which the script is running (see platform_ constants)
//# End Function

//# Function PlaySound(path as string, volume as integer) As integer
//- Plays a sound file asynchronously (i.e. sound plays in the background while script continues). 
//- The path parameter is the full path to the sound file (e.g. "c:\sounds\football.mp3"). 
//- Pass an empty string in path to bring up the file chooser. 
//- The volume parameter is an integer between 0 (no sound) and 100 (play at the current system volume setting). 
//- Returns an integer number identifying the sound being played. 
//- This number can be passed to StopSound (see below) to stop the sound.
//- All sounds still playing when the script terminates will be stopped at that time.
//# End Function

//# Sub StopSound(n as integer)
//- Stop the sound identified by n (previously returned by PlaySound). 
//- StopSound(0) will stop all sounds.
//# End Sub

//# Function ScriptFilePath() As string
//- Returns the full file path of the currently running script. 
//- (e.g. “c:\AstroPlanner\AstroPlanner Scripts\Find All Red Stars.txt”)
//# End Function

//# Function ScriptFilePaths() As string()
//- Returns the full file paths of all available scripts as an array of strings, in ascending order.
//# End Function

//# Function ScriptName() As string
//- Returns the name of the currently running script. (e.g. “Find All Red Stars”)
//# End Function

//# Function ScriptNames() As string()
//- Returns the names of all available scripts as an array of strings, in ascending order.
//# End Function

Sub SetFoVCenter(nPlan as integer, ra as double, dec as double)
	//- Redraw the FOV chart in the current plan document so that it is centred on the given coordinates.
	Deprecate("SetFoVCenter(nPlan,RA,Dec)","APPlan.SetFoVCenter(RA,Dec)")
	APC_SetFoVCenter(nPlan,ra,dec)
End Sub

//# Function SplitComma(s as string) As string()
//- Splits the comma-separated string, s, into an array of strings. Takes into account quoted strings, etc.
//# End Function

//# Function Version() As string
//- Returns the application version. e.g. "2.0.1", "2.1b3"
//# End Function

//# Function VersionNumeric() As integer
//- Returns the application version as a number ABC, where the version is "A.B.C" (pre-release/beta version release numbers are ignored). 
//- e.g. "2.0.1" would return 201, "2.5b3" would return 250.
//# End Function

//# Function NetworkConnected() As boolean
//- Returns TRUE if there is a usable Iternet/WAN connection available.
//# End Function

//# Function Fonts() As string()
//- Returns a list of available fonts. The first element will be the standard system font.
//# End Function

//# Function PrintingFont(n as integer) As string
//- Returns the font name of the default printing font from Preferences > Printing. n can take one of the pfont_ constant values
//# End Function

//# Function PrintingFontSize(n as integer) As integer
//- Returns the font size of the default printing font from Preferences > Printing. n can take one of the pfont_ constant values.
//# End Function

	sub Print(icon as integer, body as string, optional title as string = "")
		//- Same as the Print method, but allows control over the icon displayed
		//- in the dialog. Use the icon_ constants. The default is icon_Note.
		//- The title parameter specifies the title on the alert dialog. The default
		//- is "Alert!".
		Print "$!"+str(icon)+"|*|"+title+"!$"+body
	end sub

  function DoubleToStr(r as double, decpt as integer) as string
  	//- Convert a double value to a "nice" string, with decpt decimals. 
  	//- If decpt<0 then convert to a "nice" string with a maximum of |decpt| decimals. 
  	//- e.g. DoubleToStr(3.1415926, 2) would return "3.14". 
  	//- DoubleToStr(2.00035, 2) would return "2.00". 
  	//- DoubleToStr(2.00035, -2) would return "2". 
  	//- Note that the string will be localised for your operating system. e.g. in France, DoubleToStr(3.1415926, 2) would return "3,14".
  	return APC_DoubleToStr(r,decpt)
  end function
  
  function DoubleToStr(r as double) as string
  	//- Convert a double value to a "nice" string. Equivalent to DoubleToStr(r,-7)
  	return APC_DoubleToStr(r,-7)
  end function
  
  function AngleFormatted(x as double, optional decpts as integer = -999) as string
  	//- Formats an angle (in degrees) to a suitable string. 
  	//- e.g. AngleFormatted(1.6) would return “1.6°”. AngleFormatted(0.5) would return “30'”. 
  	//- If the decpts parameter is specified, then the displayed value is always in degrees, 
  	//- with decpts having the same meaning as for DoubleToStr().
  	return APC_AngleFormatted(x,decpts)
  end function
  
	function NewLine() as string
		//- Newline character string suitable for your platform (i.e. CR for Mac, CR+LF for Windows).
		return APC_EndOfLine
	end function

	sub Bleep()
		//- Make the computer “beep”.
		APC_Bleep
	end sub
	
	function UserAbort() as boolean
		//- Returns TRUE if the user cancelled an operation (by hitting the ESC key, or Cmd-Period on Mac).
		return APC_UserAbort
	end function

	sub CatalogFindID(s as string, optional cat as string = "")
		Deprecate("CatalogFindID","APCatalog.FindID")
		APC_CatalogFindID(s,cat)
	end sub

	function nCatalogFound() as integer
		Deprecate("nCatalogFound","result of APCatalog.FindID")
		return APC_nCatalogFind
	end function

	function CatalogFound(n as integer) as APCatalogObject
		Deprecate("CatalogFound(n)","APCatalog.FoundObject(n)")
		return new APCatalogObject(n)
	end function

	function Choice(ParamArray s as string) as integer
		Deprecate("Choice","Dialog.Choice")
		return APC_Choice(s)
	end function

	function Choice(s() as string) as integer
		Deprecate("Choice","Dialog.Choice")
		return APC_Choice(s)
	end function

	function Options(ParamArray s as string) as integer
		Deprecate("Options","Dialog.Options")
		return APC_Options(s)
	end function

	function Options(s() as string) as integer
		Deprecate("Options","Dialog.Options")
		return APC_Options(s)
	end function

	sub Speak(s as string)
		//- Speak the string in s using the computer's speech synthesizer.
		APC_Speak(s)
	end sub

	function IsNumeric(s as string) as boolean
		//- Returns TRUE if the string parameter, s, contains a valid number.
		return APC_IsNumeric(s)
	end function

	function GetFilePath(optional title as string = "") as string
		Deprecate("GetFilePath","APFile.GetPath")
		return APC_GetFilePath(title)
	end function

	function Launch(optional fpath as string = "", optional activate as boolean = true) as boolean
		//- Launches the document or application specified by path. 
		//- If path is absent, or an empty string, then the open file dialog will be used to select a document/application. 
		//- If the activate parameter is false (default = true) then the application/document will be launched in the background (if possible). 
		//- The function returns false if the document/folder is not specified, does not exist, is a folder, etc. 
		//- If the function returns true, AstroPlanner will attempt to open the document/application, but success is not guaranteed.
		return APC_Launch(fpath,activate)
	end function

	function Shell(cmd as string, optional params as string = "", optional timeout as integer = 2000) as string
		//- Execute a shell command. 
		//- In Mac OS X, this is similar to executing a command line in the Terminal application. 
		//- In Windows, this is similar to executing a DOS command. 
		//- The cmd parameter is the shell command you wish to execute (e.g. “ls –ra”, “dir –w”). 
		//- If the actual command name contains blanks and requires parameters, you can also separate the 
		//- parameters into the optional params (e.g. Shell(“My App.exe”,”File1.doc File2.doc”)). 
		//- The function returns any text returned by the executed shell command. 
		//- The timeout parameter is used on Windows systems, and provides the timeout period for 
		//- the shell command in milliseconds (default = 2000, i.e. 2 seconds). 
		//- You might have to increase this from the default for shell commands that take a while to complete.
		return APC_Shell(cmd,params,timeout)
	end function

	function DateToDouble(s as string) as double
		Deprecate("DateToDouble","Date.ParseDate")
		return APC_DateToDouble(s)
	end function

	function DoubleToDate(r as double) as string
		Deprecate("DoubleToDate","Date.ShortDate, Date.LongDate, etc.")
		return APC_DoubleToDate(r)
	end function

	function DoubleToTime(r as double, optional showSeconds as boolean = true) as string
		Deprecate("DoubleToTime","Date.ShortTime, Date.LongTime, etc.")
		return APC_DoubleToTime(r,showSeconds)
	end function

	function TimeToDouble(s as string) as double
		Deprecate("TimeToDouble","Date.ParseTime")
		return APC_ParseTime(s)
	end function

//# Function DayOfDate(r as double) As integer
//# Deprecate("DayOfDate","Date.Day")
//# end function

	function DaysInMonth(month as integer, year as integer) As integer
		Deprecate("DaysInMonth","Date.DaysInMonth")
		return APC_DaysInMonth(month,year)
	end Function

	function DayAbbreviations() As string()
		Deprecate("DayAbbreviations","Date.DayAbbreviations")
		return APC_DayAbbreviations
	end function

	function DayNames() As string()
		Deprecate("DayNames","Date.DayNames")
		return APC_DayNames
	end function

	function MonthAbbreviations() As string()
		Deprecate("MonthAbbreviations","Date.MonthAbbreviations")
		return APC_MonthAbbreviations
	end function

	function MonthNames() As string()
		Deprecate("MonthNames","Date.MonthNames")
		return APC_MonthNames
	end function
	
	Function YearOfDate(r as double) As integer
		Deprecate("YearOfDate","Date.Year")
		dim d as new Date(r)
		return d.Year
	End Function
	
	Function SecondOfDate(r as double) As integer
		Deprecate("SecondOfDate","Date.Second")
		dim d as new Date(r)
		return d.Second
	End Function
	
	Function MonthOfDate(r as double) As integer
		Deprecate("MonthOfDate","Date.Month")
		dim d as new Date(r)
		return d.Month
	End Function
	
	Function MinuteOfDate(r as double) As integer
		Deprecate("MinuteOfDate","Date.Minute")
		dim d as new Date(r)
		return d.Minute
	End Function
	
	Function HourOfDate(r as double) As integer
		Deprecate("HourOfDate","Date.Hour")
		dim d as new Date(r)
		return d.Hour
	End Function
	
	Function DayOfDate(r as double) As integer
		Deprecate("DayOfDate","Date.Day")
		dim d as new Date(r)
		return d.Day
	End Function
	
	Function MakeDate(year as integer, month as integer, day as integer) As double
		Deprecate("MakeDate","new Date(year,month,day)")
		dim d as new Date(year,month,day)
		return d.TotalSeconds
	End Function

	sub CurrentEpochFrom2000(byref ra as double, byref dec as double)
		//- Converts epoch 2000.0 coordinates to the epoch of the current date
		APC_CurrentEpoch(ra,dec)
	end sub

	sub ChangeEpoch(fromEpoch as double, toEpoch as double, byref ra as double, byref dec as double)
		//- Change the given coordinates (assumed to be in the fromEpoch epoch) to the toEpoch epoch.
		APC_ChangeEpoch(fromEpoch,toEpoch,ra,dec)
	end sub
	
	function CurrentEpoch( ) as double
		//- Returns the current epoch (e.g. 2012.9)
		dim d as new Date
		return d.Year+d.DayofYear/365.25
	end function

	function CurrentDate() as double
		Deprecate("CurrentDate","new Date()")
		return APC_CurrentDate
	end function

	function GetURL(url as string, optional timeout as integer = 30) as string
		Deprecate("GetURL","Web.HTTPGet")
		return APC_GetURL(url,timeout)
	end function

	function GetURL(url as string, params() as string, optional doPost as boolean = false, optional timeout as integer = 30) as string
		Deprecate("GetURL","Web.HTTPGet or Web.HTTPPost")
		return APC_GetURL(url,doPost,params,timeout)
	end function
	
	sub ShowURL(url as string, optional useBrowser as boolean = true)
		//- Show the contents of the given URL (e.g. "http://www.astroplanner.net") in 
		//- either an application window (if useBrowser is false) or in your default 
		//- web browser application (if useBrowser is true).
		APC_HTMLWindow(url,"","",useBrowser)
	end sub

	sub ShowHTML(body as string)
		//- Render the HTML page source in body in an application window.
		APC_HTMLWindow("","",body,false)
	end sub

	sub ShowHTMLFile(path as string)
		//- Render the HTML page source in a text file specified by path in an application window.
		APC_HTMLWindow("",path,"",false)
	end sub

	function DegreeSymbol() as string
		//- Return the degree symbol (°) as a string.
		Return APC_DegreeSymbol
	end function

	function MinuteSymbol() as string
		//- Return the minute symbol (') as a string.
		Return "'"
	end function

	function SecondSymbol() as string
		//- Return the second symbol (") as a string.
		Return """"
	end function

	sub StartProgress(optional c as string = "", optional canCancel as boolean = false, optional mx as double = 100.0)
		Deprecate("StartProgress","Dialog.StartProgress")
		Dialog.StartProgress(c,canCancel,mx)
	end sub

	sub StopProgress()
		Deprecate("StopProgress","Dialog.StopProgress")
		Dialog.StopProgress
	end sub

	function UpdateProgress(optional v as double = -999.0) as boolean
		Deprecate("UpdateProgress","Dialog.UpdateProgress")
		return Dialog.UpdateProgress(v)
	end function

	function AngleBetween(ra1 as double, dec1 as double, ra2 as double, dec2 as double) as double
		//- Return the angular distance between ra1,dec1 and ra2,dec2 in degrees.
		return APC_AngleBetween(ra1, dec1, ra2, dec2)
	end function

	function AngleBetween(ra as double, dec as double, obj as RADecObject) as double
		//- Return the angular distance between ra,dec and the given object in degrees. 
		//- obj must conform to the RADecObject interface.
		if obj=nil then return 999.0
		return APC_AngleBetween(ra, dec, obj.RA, obj.Dec)
	end function

	function AngleBetween(obj as RADecObject, ra as double, dec as double) as double
		//- Return the angular distance between the given object and ra,dec in degrees. 
		//- obj must conform to the RADecObject interface.
		if obj=nil then return 999.0
		return APC_AngleBetween(obj.RA, obj.Dec, ra,dec)
	end function

	function AngleBetween(a as RADecObject, b as RADecObject) as double
		//- Return the angular distance between the given objects in degrees. 
		//- a and b must conform to the RADecObject interface.
		if a=nil or b=nil then return 999.0
		return APC_AngleBetween(a.RA, a.Dec, b.RA, b.Dec)
	end function

	function BearingTo(ra1 as double, dec1 as double, ra2 as double, dec2 as double) as double
		//- Bearing from ra1,dec1 to ra2,dec2 in degrees w.r.t. North (0 degrees)
		return APC_BearingTo(ra1, dec1, ra2, dec2)
	end function

	function BearingTo(ra as double, dec as double, obj as RADecObject) as double
		//- Bearing from ra,dec to obj in degrees w.r.t. North (0 degrees)
		//- obj must conform to the RADecObject interface.
		if obj=nil then return 999.0
		return APC_BearingTo(ra, dec, obj.RA, obj.Dec)
	end function

	function BearingTo(obj as RADecObject, ra as double, dec as double) as double
		//- Bearing from obj to ra,dec in degrees w.r.t. North (0 degrees)
		//- obj must conform to the RADecObject interface.
		if obj=nil then return 999.0
		return APC_BearingTo(obj.RA, obj.Dec, ra,dec)
	end function

	function BearingTo(obj1 as RADecObject, obj2 as RADecObject) as double
		//- Bearing from obj1 to obj2 in degrees w.r.t. North (0 degrees)
		//- obj1 and obj2 must conform to the RADecObject interface.
		if obj1=nil or obj2=nil then return 999.0
		return APC_BearingTo(obj1.RA, obj1.Dec, obj2.RA, obj2.Dec)
	end function

	function nHighlighted() as integer
		Deprecate("nHighlighted","Plan().nHighlighted")
		return Plan().nHighlighted
	end function

	function HighlightedObject(n as integer) as APPlanObject
		Deprecate("HighlightedObject(n)","Plan().HighlightedObject(n)")
		return Plan().HighlightedObject(n)
	end function

	function HighlightedObjects( ) as APPlanObject()
		Deprecate("HighlightedObjects","Plan().HighlightedObjects")
		return Plan().HighlightedObjects()
	end function

	function FormatRA(ra as double, optional extended as boolean = false, optional form as string = "") as string
		//- Formats the given value as hh:mm:ss, or if the optional extended parameter is true, as hh:mm:ss.ss.
		//- The optional format parameter allows more control over the final format. 
		//- The value of the parameter is in two parts: the first can be h, hm, or hms, 
		//- depending on whether you want hours, minutes and seconds in the result. 
		//- The second part is a single character which is the delimiter between the h, m, and s parts. 
		//- This can be empty (for no delimiter), "a" for using the letters "h", "m" and "s", 
		//- or any other single character (e.g. ":" or "-").
		return APC_FormatRA(ra,extended,form)
	end function

	function FormatDec(dec as double, optional extended as boolean = false, optional form as string = "") as string
		//- Formats the given value as +dd°mm'ss", or if the optional extended parameter is true, as +dd°mm'ss.ss".
		//- The optional format parameter allows more control over the final format. 
		//- The value of the parameter is in two parts: the first can be d, dm, or dms, depending on 
		//- whether you want degrees, minutes and seconds in the result. 
		//- Precede this with "+" if you want positive declination values to have a "+" sign. 
		//- The second part is a single character, which is the delimiter between the d, m, and s parts. 
		//- This can be empty (for no delimiter), "x" for using the symbols (°, ' and "), 
		//- "a" for using ("d", "m" and "s"), or any other single character (e.g. ":" or "-").
		return APC_FormatDec(dec,extended,form)
	end function

	function ParseRA(s as string) as double
		//- Parse a string containing an RA value and return that value as a double. e.g. ParseRA("12:30") would return 12.5.
		return APC_ParseRA(s)
	end function

	function ParseDec(s as string) as double
		//- Parse a string containing an Declination value and return that value as a double. e.g. ParseDec("122°30'") would return 122.5.
		return APC_ParseDec(s)
	end function

	function nConstellations() as integer
		Deprecate("nConstellations","Constellation.Count")
		return Constellation.Count
	end function

	function ConstellationName(n as integer) as string
		Deprecate("ConstellationName(n)","Constellation.GetConstellation(n).Name")
		return Constellation.GetConstellation(n).Name
	end function

	function ConstellationAbbreviation(n as integer) as string
		Deprecate("ConstellationAbbreviation(n)","Constellation.GetConstellation(n).Abbreviation")
		return Constellation.GetConstellation(n).Abbreviation
	end function

	function Constellations() as string()
		Deprecate("Constellations()","Constellation.Descriptions()")
		return Constellation.Descriptions
	end function

	function ConstellationNames() as string()
		Deprecate("ConstellationNames()","Constellation.Names()")
		return Constellation.Names()
	end function

	function ConstellationAbbreviations() as string()
		Deprecate("ConstellationAbbreviations()","Constellation.Abbreviations()")
		return Constellation.Abbreviations
	end function

	function Clipboard() as string
		//- Sets or gets a text string to/from the system clipboard.
		//- e.g. if you copied some text onto the clipboard in a text editor (using Edit–>Copy), 
		//- you can access that text in your script:
		//-   dim s as string = Clipboard
		//- Conversely, if you generate text in the script, you can copy it onto the clipboard:
		//-   Clipboard = s
    //- and then paste that into another external application.
		return APC_GetClipboard
	end function

	sub Clipboard(assigns s as string)
		//- Sets or gets a text string to/from the system clipboard.
		//- e.g. if you copied some text onto the clipboard in a text editor (using Edit–>Copy), 
		//- you can access that text in your script:
		//-   dim s as string = Clipboard
		//- Conversely, if you generate text in the script, you can copy it onto the clipboard:
		//-   Clipboard = s
    //- and then paste that into another external application.
		APC_SetClipboard(s)
	end sub
	
	function ClipboardHasText() as boolean
		//- Returns TRUE if the clipboard contains text.
		return APC_ClipboardHas("Text")
	end function
	
	function ClipboardHasImage() as boolean
		//- Returns true if the system clipboard contains a usable image, false otherwise.
		return APC_ClipboardHas("Picture")
	end function
	
//# Function ClipboardHasImage(byref width as integer, byref height as integer) As boolean
//- Returns true if the system clipboard contains a usable image, false otherwise. 
//- The width and height of the image (in pixels) is returned if there is an image.
//# end function

	function OKCancel(body as string, optional default as boolean = true) as boolean
		Deprecate("OKCancel","Dialog.OKCancel")
		return APC_OKCancel("OK","Cancel",body,default)
	end function

	function YesNo(body as string, optional default as boolean = true) as boolean
		Deprecate("YesNo","Dialog.YesNo")
		return APC_OKCancel("Yes","No",body,default)
	end function

	function Confirmation(body as string, button1 as string, button2 as string, optional default as boolean = true) as boolean
		Deprecate("Confirmation","Dialog.Confirmation")
		return APC_OKCancel(button1,button2,body,default)
	end function

	function EndOfLine() as string
		//- Returns an end-of-line delimiter string, suitable for the platform you are using.
		return APC_EndOfLine
	end function

	sub Yield()
		//- Yields processing time back to AstroPlanner and other applications in the system. 
		//- Can be used during long processes to allow AstroPlanner or other applications to be 
		//- used while the script proceeds. 
		//- NOTE: it is imperative that you do not make changes to open plan documents, 
		//- open or close plan documents, modify resources, etc. while the script is running, 
		//- as this can cause unexpected results or crashes. Hence, use Yield() with caution.
		APC_Yield
	end sub

  private dim stopDebugging as boolean
  
  private function APC_ConvertVariantsToStrings(v() as Variant) as string()
  	dim s() as string
	  for i as integer = 0 to v.ubound
	  	if v(i)=nil then
	  		s.Append "nil"
	  	else
		  	select case v(i).Type
		  	case vtype_Structure
		  		s.Append "[Structures not allowed!]"
		  	case vtype_Array+Vtype_String
		  		dim ss() as string = v(i)
		  		for j as integer = 0 to ss.Ubound
		  			s.Append ss(j)
		  		next
		  	case vtype_Array+Vtype_Integer
		  		dim ss() as integer = v(i)
		  		for j as integer = 0 to ss.Ubound
		  			s.Append str(ss(j))
		  		next
		  	case vtype_Array+Vtype_Double
		  		dim ss() as double = v(i)
		  		for j as integer = 0 to ss.Ubound
		  			s.Append DoubleToStr(ss(j))
		  		next
		  	case vtype_Array+Vtype_Boolean
		  		dim ss() as boolean = v(i)
		  		for j as integer = 0 to ss.Ubound
		  			dim vv as Variant = ss(j)
		  			s.Append vv.StringValue
		  		next
		  	case vtype_Array+Vtype_Color
		  		dim ss() as Color = v(i)
		  		for j as integer = 0 to ss.Ubound
		  			dim vv as Variant = ss(j)
		  			s.Append vv.StringValue
		  		next
		  	case Vtype_Double
		  			s.Append DoubleToStr(v(i))
		  	else
		  		if v(i).IsArray then
		  			s.Append "[This type of array not allowed!]"
		  		elseif v(i).IsNull then
		  			s.Append "null"
		  		else
		  			s.Append v(i).StringValue
		  		end if
		  	end select
	  	end if
	  next
		return s
  end function
	
	sub Debug(paramarray v as Variant)
		//- Write (zero or more) parameters to the Debug window (opening it where needed).
		//- The parameters will be separated by a space character.
		//- e.g. Debug("No. of objects:",Plan().nObjects)
		//- Note: Parameters must be simple types or arrays of simple types (i.e. integer, double, string, color, or boolean), 
		//- or an object that does an operator_Convert to a simple type (e.g. Date). i.e. arrays and structures not allowed.
		
		if stopDebugging then return
		APC_Debug(Join(APC_ConvertVariantsToStrings(v)," "))
	end sub

	sub Console(paramarray v as Variant)
		//- Write (zero or more) parameters to the system console.
		//- The parameters will be separated by a space character.
		//- e.g. Console("No. of objects:",Plan().nObjects)
		//- Note: Parameters must be simple types or arrays of simple types (i.e. integer, double, string, color, or boolean), 
		//- or an object that does an operator_Convert to a simple type (e.g. Date). i.e. arrays and structures not allowed.
		//- Console can be accessed in Mac OS X via Applications/Utilities/Console.app.
		//- Console can be accessed in Windows via DebugView.exe (free download from Microsoft)
		//- Obeys DebugOn and DebugOff.
		if stopDebugging then return
		APC_Console(Join(APC_ConvertVariantsToStrings(v)," "))
	end sub

	sub Debug(v() as Variant)
		//- Write each element of v to the Debug window (opening it where needed).
		//- One element per line.
		//- Note: elements of v must be simple types or arrays of simple types (i.e. integer, double, string, color, or boolean),
		//- or an object that does an operator_Convert to a simple type (e.g. Date). i.e. arrays and structures not allowed.
		
		if stopDebugging then return
		for i as integer = 0 to ubound(v)
			Debug(v(i))
		next
	end sub
	
	sub Console(v() as Variant)
		//- Write each element of v to the system console.
		//- One element per line.
		//- Note: elements of v must be simple types or arrays of simple types (i.e. integer, double, string, color, or boolean),
		//- or an object that does an operator_Convert to a simple type (e.g. Date). i.e. arrays and structures not allowed.
		//- Console can be accessed in Mac OS X via Applications/Utilities/Console.app.
		//- Console can be accessed in Windows via DebugView.exe (free download from Microsoft)
		//- Obeys DebugOn and DebugOff.
		
		if stopDebugging then return
		for i as integer = 0 to ubound(v)
			Console(v(i))
		next
	end sub
	
	sub DebugClear()
		//- Clear the contents of the Debug window (if applicable). Debug must be ON. 
		if stopDebugging then return
		APC_Debug("#**clr**#")
	end sub

	sub DebugOn()
		//- Turn debugging ON (this is the default condition when a script starts).
		//- All subsequent Debug() calls will output to the Debug window.
		stopDebugging=false
	end sub

	sub DebugOff()
		//- Turn debugging OFF.
		//- All subsequent Debug() calls will be ignored.
		stopDebugging=true
	end sub

	sub ScreenSize(byref width as integer, byref height as integer, byref left as integer, byref top as integer)
		Deprecate("ScreenSize","Screen.Width, etc.")
		width=Screen.Width
		height=Screen.Height
		left=Screen.Left
		top=Screen.Top
	end sub

	function nASTORBObjects() as integer
		Deprecate("nASTORBObjects","APMinorPlanetObject.nASTORBObjects")
		return APMinorPlanetObject.nASTORBObjects
	end function

	function nMPCORBObjects() as integer
		Deprecate("nMPCORBObjects","APMinorPlanetObject.nMPCORBObjects")
		return APMinorPlanetObject.nMPCORBObjects
	end function

	function ASTORBObject(n as integer) as APMinorPlanetObject
		Deprecate("ASTORBObject(n)","APMinorPlanetObject.ASTORBObject(n)")
		return APMinorPlanetObject.ASTORBObject(n)
	end function

	function MPCORBObject(n as integer) as APMinorPlanetObject
		Deprecate("MPCORBObject(n)","APMinorPlanetObject.MPCORBObject(n)")
		return APMinorPlanetObject.MPCORBObject(n)
	end function

	function nCOMETObjects() as integer
		Deprecate("nCOMETObjects","APCometObject.Count")
		return APCometObject.Count
	end function

	function COMETObject(n as integer) as APCometObject
		Deprecate("COMETObject(n)","APCometObject.COMETObject(n)")
		return APCometObject.Get(n)
	end function
  
	function AppleScript(script as string, ParamArray params as string) as string
		//- Mac OS ONLY. Not available on Windows.
		//- Call an AppleScript (either as a string or from a text file), with optional parameters. 
		//- If the AppleScript returns results, they will be returned from the function as a string.
		#if TargetMacOS
		return APC_AppleScript(script,params)
		#endif
	end function

	function AppleScript(file as APTextFile, ParamArray params as string) as string
		//- Mac OS ONLY. Not available on Windows.
		//- Call an AppleScript (either as a string or from a text file), with optional parameters. 
		//- If the AppleScript returns results, they will be returned from the function as a string.
		#if TargetMacOS
		return APC_AppleScript(file.ReadAll,params)
		#endif
	end function
  
	function PlanObjects() as APPlanObject()
		Deprecate("PlanObjects","Plan().Objects")
		return Plan().Objects
	end function

	sub Delay(seconds as double, optional caption as string = "")
		//- Delay for the specified number of seconds (can be fractional). 
		//- This is a "hard" delay (all activity is stopped for the specified time). 
		//- If the delay is for more than a second or two, you can supply a caption parameter. 
		//- This will put up a progress bar that shows the progress of the delay.
		dim startTime as double
		dim elapsed as double

		startTime=Microseconds
		if caption<>"" then StartProgress(caption,false,seconds)
		do
			elapsed=(MicroSeconds-StartTime)*1E-6
			if elapsed>=seconds then exit
			if caption<>"" then call UpdateProgress(elapsed)
			Yield
		loop until false
		if caption<>"" then StopProgress
	end sub

	function DelayCancellable(seconds as double, optional caption as string = "") as boolean
		//- Delay for the specified number of seconds (can be fractional). 
		//- This is a "hard" delay (all activity is stopped for the specified time). 
		//- A progress bar that shows the progress of the delay will be displayed. 
		//- You can supply a caption parameter that will be displayed in the progress window (otherwise “nn.n second delay” will be used”).
		//- A Cancel button is displayed. Clicking Cancel will immediately end the delay and return false. 
		//- If the delay is not cancelled, true is returned.
		
		dim startTime as double
		dim elapsed as double
		dim cap as string
		
		startTime=Microseconds
		cap=caption
		if cap="" then cap=format(seconds,"0.0")+" second delay"
		StartProgress(cap,true,seconds)
		do
			elapsed=(MicroSeconds-StartTime)*1E-6
			if elapsed>=seconds then exit
			if UpdateProgress(elapsed) then return false
			Yield
		loop until false
		StopProgress
		return true
	end function
	
	function Plan(optional n as integer = -1) as APPlan
		//- Return the plan with the given plan number. If n = -1 or is omitted, return the current plan.
		//Deprecate("Plan(number)","APPlan.Plan(number)")
		return APPlan.Plan(n)
	end function

end module

//------------------------------------------------------------------------------------
class Canvas
	// Documented 10/9/2012
	//- A Canvas object represents a blank page, or a number of pages, upon which you can draw various items. 
	//- Those pages are then displayed either on the screen in a window, or on a printer as printed pages.
	//- Canvas is an object. You create it, draw to it, and then close it.
	//- When you close it, it is either displayed or printed.
	
	public dim cIdx as integer // private
	private dim closed as boolean
	
	// FoVOptions constants, as of 8/2/2012

	const FoVopt_Constellations_Borders = 6   // Constellations -> Borders
	const FoVopt_Constellations_ColourConstellationStars = 32   // Constellations -> Colour constellation stars
	const FoVopt_Constellations_Figures = 22   // Constellations -> Figures
	const FoVopt_Constellations_Names = 23   // Constellations -> Names
	const FoVopt_Display_Aperture = 27   // Display -> Aperture
	const FoVopt_Display_CardinalPoints = 20   // Display -> Cardinal points
	const FoVopt_Display_CrossHairs = 16   // Display -> Cross hairs
	const FoVopt_Display_CurrentTelescopePosition = 36   // Display -> Current telescope position
	const FoVopt_Display_HighlightedPlanObjectsOnly = 12   // Display -> Highlighted plan objects only
	const FoVopt_Display_Images = 28   // Display -> Images
	const FoVopt_Display_MultipleStars = 3   // Display -> Multiple stars
	const FoVopt_Display_NumberOfObservations = 13   // Display -> Number of observations
	const FoVopt_Display_ObjectsWithMagnitudeOnly = 29   // Display -> Objects with magnitude only
	const FoVopt_Display_PlanObjectAtChartCentreOnly = 35   // Display -> Plan object at chart centre only
	const FoVopt_Display_ProperMotion = 2   // Display -> Proper motion
	const FoVopt_Display_ShowConstellationSubChart = 38   // Display -> Show constellation sub-chart
	const FoVopt_Display_ShowDateTimeIfDateFixed = 37   // Display -> Show Date/Time if date fixed
	const FoVopt_Display_SpectralColours = 5   // Display -> Spectral colours
	const FoVopt_Display_StellarMagnitudeScale = 26   // Display -> Stellar magnitude scale
	const FoVopt_Display_VariableStars = 4   // Display -> Variable stars
	const FoVopt_Labels_Magnitude = 0   // Labels -> Magnitude
	const FoVopt_Labels_PositionAngle = 15   // Labels -> Position angle
	const FoVopt_Labels_Separation = 1   // Labels -> Separation
	const FoVopt_Orientation_AltAzRotation = 24   // Orientation -> Alt/Az rotation
	const FoVopt_Orientation_FlipHorizontal = 18   // Orientation -> Flip horizontal
	const FoVopt_Orientation_FlipVertical = 19   // Orientation -> Flip vertical
	const FoVopt_Other_IgnoreImagerGuideSensor = 10   // Other -> Ignore imager guide sensor
	const FoVopt_Other_Legend = 9   // Other -> Legend
	const FoVopt_Other_ShowObjectNotes = 14   // Other -> Show object notes
	const FoVopt_Reticles_AllBinocularFoVs = 33   // Reticles/FoVs -> All binocular FoVs
	const FoVopt_Reticles_AllEyepieceFoVs = 17   // Reticles/FoVs -> All eyepiece FoVs
	const FoVopt_Reticles_BinocularFoV = 34   // Reticles/FoVs -> Binocular FoV
	const FoVopt_Reticles_CustomReticles = 25   // Reticles/FoVs -> Custom reticles
	const FoVopt_Reticles_EyepieceFoV = 21   // Reticles/FoVs -> Eyepiece FoV
	const FoVopt_Reticles_FitImagerToFoVAperture = 31   // Reticles/FoVs -> Fit imager to FoV aperture
	const FoVopt_Reticles_HideEyepieceReticle = 11   // Reticles/FoVs -> Hide eyepiece reticle
	const FoVopt_Reticles_ImagerFoV = 30   // Reticles/FoVs -> Imager FoV
	const FoVopt_Reticles_RigelQF = 8   // Reticles/FoVs -> Rigel QuickFinder
	const FoVopt_Reticles_Telrad = 7   // Reticles/FoVs -> Telrad
	const FoVopt_SolarSystem_ShowComets = 42   // Solar System -> Show Comets
	const FoVopt_SolarSystem_ShowMinorPlanets = 43   // Solar System -> Show Minor Planets
	const FoVopt_SolarSystem_ShowMoon = 40   // Solar System -> Show Moon
	const FoVopt_SolarSystem_ShowPlanets = 41   // Solar System -> Show Planets
	const FoVopt_SolarSystem_ShowSun = 39   // Solar System -> Show Sun


	// SkyOptions constants, as of 8/2/2012

	const skyopt_Constellations_Borders = 11   // Constellations -> Borders
	const skyopt_Constellations_Figures = 10   // Constellations -> Figures
	const skyopt_Constellations_Names = 24   // Constellations -> Names
	const skyopt_Lines_AirMass = 31   // Lines -> Air Mass
	const skyopt_Lines_AltAzimuthGrid = 1   // Lines -> Alt-Azimuth grid
	const skyopt_Lines_Ecliptic = 2   // Lines -> Ecliptic
	const skyopt_Lines_EquatorialGrid = 0   // Lines -> Equatorial grid
	const skyopt_Lines_FixedAltitude = 14   // Lines -> Fixed Altitude
	const skyopt_Lines_GalacticEquator = 3   // Lines -> Galactic equator
	const skyopt_Lines_MilkyWayOutline = 9   // Lines -> Milky Way outline
	const skyopt_Lines_TelescopeRADec = 13   // Lines -> Telescope RA/Dec
	const skyopt_Objects_AlignmentStars = 5   // Objects -> Alignment stars
	const skyopt_Objects_BolideShowerRadiants = 20   // Objects -> Bolide shower radiants
	const skyopt_Objects_CatalogueObjects = 23   // Objects -> Catalogue objects
	const skyopt_Objects_FieldOfView = 12   // Objects -> Field of view (FoV)
	const skyopt_Objects_MeteorShowerRadiants = 19   // Objects -> Meteor shower radiants
	const skyopt_Objects_Stars = 17   // Objects -> Stars
	const skyopt_Objects_SunMoonPlanets = 6   // Objects -> Sun/Moon/Planets
	const skyopt_Orientation_FlipEastWest = 21   // Orientation -> Flip East/West
	const skyopt_Orientation_FlipNorthSouth = 22   // Orientation -> Flip North/South
	const skyopt_PlanObjects_NumberOfObservations = 25   // Plan Objects -> Number of observations
	const skyopt_PlanObjects_Objects = 15   // Plan Objects -> Objects
	const skyopt_PlanObjects_ObjectSequence = 16   // Plan Objects -> Object sequence
	const skyopt_PlanObjects_ShowID = 26   // Plan Objects -> Show ID
	const skyopt_PlanObjects_ShowName = 27   // Plan Objects -> Show Name
	const skyopt_Visibility_Contours = 18   // Visibility -> Contours
	const skyopt_Visibility_FixedHorizon = 28   // Visibility -> Fixed Horizon
	const skyopt_Visibility_LightDome = 29   // Visibility -> Light dome
	const skyopt_Visibility_Limits = 8   // Visibility -> Limits
	const skyopt_Visibility_SiteHorizon = 7   // Visibility -> Site Horizon
	const skyopt_Visibility_TwilightDaylightColours = 30   // Visibility -> Twilight/daylight colours
	const skyopt_Visibility_UseNELMForStarVisibility = 4   // Visibility -> Use NELM for star visibility

	const grid_None=0
	const grid_Thin=1
	const grid_Thick=2
	

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(width as integer, height as integer, optional plan as APPlan = nil, optional windowTitle as string = "", optional allowPrinting as boolean = true, optional extra as string = "")
		//- This creates an on-screen Canvas in a window, with each page being of the specified width and height (in pixels). 
		//- The plan is the plan document upon which to base the Canvas (for such things as field of view chart options, etc.). 
		//- The default (nil) represents the frontmost plan document.
		//- If a windowTitle is specified, it is displayed as the window title bar caption. 
		//- The allowPrinting parameter (default = true) specifies whether File > Print... is enabled for the on-screen Canvas window. 
		cIdx=APC_CanvasCreate(APPlan.PlanNumber(plan),width,height,windowTitle,allowPrinting,extra)
	end sub

	sub Constructor(dummy as integer, width as integer, height as integer, optional plan as APPlan = nil) // private
		cIdx=APC_CanvasCreate(APPlan.PlanNumber(plan),width,height)
	end sub

	sub Constructor(nType as integer, canCancel as boolean, extra as string) // private
		cIdx=APC_CanvasCreate(APPlan.PlanNumber(nil),nType,canCancel,extra)
	end sub

	sub Constructor(doPageSetup as boolean, optional plan as APPlan = nil, optional extra as string = "")
		//- This creates a printer Canvas. 
		//- Each page will have the size specified by the chosen printer paper size and orientation. 
		//- If doPageSetup is true, then the page setup dialog will be called before creating the Canvas in order to set orientation, etc. 
		//- If you are using the printer Canvas, you should check the Cancelled property immediately 
		//- after the constructor call, to determine if the user clicked the Cancel button in either 
		//- the Page Setup or Print dialogs. If Cancelled is true, call Close immediately.
		cIdx=APC_CanvasCreate(APPlan.PlanNumber(plan),doPageSetup,extra)
	end sub

	sub Destructor() // private
		if not closed then Close
	end sub

	function Cancelled() as boolean
		//- True if the user clicked Cancel in either the Page Setup or Print dialogs, after instantiating a printer Canvas.
		return APC_CanvasCancelled(cIdx)
	end function

	sub Close(optional abandon as boolean = false)
		//- In order to display/print the current contents of the Canvas, you need to call this method,
		//- after all pages have been generated.
		//- If abandon is true, then do not display the window or print the pages.
		APC_CanvasClose(cIdx,abandon)
		closed=true
	end sub

	sub NewPage(optional extra as string = "")
		//- Start a new page. The extra parameter can be used to add a short line of text to the 
		//- progress dialog to let the user know what's being processed.
		APC_CanvasNewPage(cIdx,extra)
	end sub
	
	sub ProgressText(extra as string)
		//- When the canvas is being built (particularly multi-page canvases), a progress window is displayed. 
		//- This method will append the specified text (extra) to the end of that progress dialog. 
		//- This can be used to inform the user of stages of a long process, or for debugging.
		APC_CanvasProgressText(cIdx,extra)
  end sub

	function PageNumber() as integer
		//- Returns the current physical page number (starting with 1).
		return APC_CanvasPageNumber(cIdx)
	end function

	function Width() as integer
		//- The width of the Canvas in pixels.
		return APC_CanvasWidth(cIdx)
	end function

	function Height() as integer
		//- The height of the Canvas in pixels.
		return APC_CanvasHeight(cIdx)
	end function

	function TextWidth(s as string) as integer
		//- Return the width of the given string in pixels.
		return APC_CanvasTextWidth(cIdx,s)
	end function

	function TextHeight(optional s as string = "", optional wrapwidth as integer = -1) as integer
		//- Return the height of the given string, s, in pixels. 
		//- If s is omitted then the height of one line of text is returned. 
		//- If the text is to be wrapped if it is longer than a given width, then specify the width in wrapwidth. 
		//- The default is to assume the wrap width is the width of the Canvas.
		//- If wrapping will occur, the returned value will be the total height of the wrapped text.
		if wrapwidth>0 then
			return APC_CanvasTextHeight(cIdx,s,wrapwidth)
		else
			return APC_CanvasTextHeight(cIdx,s,APC_CanvasWidth(cIdx))
		end if
	end function

	sub TextFont(fontname as string, fontsize as integer)
		//- Specify the text font name and size to use.
		APC_CanvasTextFont(cIdx,fontname,fontsize)
	end sub

	sub TextBold(assigns v as boolean)
		//- Set to true for bold-face text.
		APC_CanvasSetBold(cIdx,v)
	end sub

	sub TextItalic(assigns v as boolean)
		//- Set to true for italic text.
		APC_CanvasSetItalic(cIdx,v)
	end sub

	sub DrawText(s as string, x as integer, y as integer, optional width as integer = 0)
		//- Draw the specified text s at the given x,y coordinates of the Canvas. 
		//- If the text is to be limited to a particular wrapping width, then specify that as width.
		APC_CanvasDrawText(cIdx,s,x,y,width)
	end sub

	sub DrawLine(x1 as integer, y1 as integer, x2 as integer, y2 as integer)
		//- Draw a line from x1,y1 to x2,y2 on the Canvas.
		APC_CanvasDrawLine(cIdx,x1,y1,x2,y2)
	end sub

	sub DrawRectangle(left as integer, top as integer, width as integer, height as integer)
		//- Draw a rectangle at left, top with size width, height on the Canvas.
		APC_CanvasDrawRect(cIdx,left,top,width,height)
	end sub

	sub DrawRectangle(r as Rect)
		//- Draw the given rectangle on the Canvas.
		APC_CanvasDrawRect(cIdx,r.left,r.top,r.width,r.height)
	end sub

	sub FillRectangle(left as integer, top as integer, width as integer, height as integer)
		//- Draw a filled rectangle at left, top with size width, height on the Canvas.
		APC_CanvasFillRect(cIdx,left,top,width,height)
	end sub

	sub FillRectangle(r as Rect)
		//- Draw and fill the given rectangle on the Canvas.
		APC_CanvasFillRect(cIdx,r.left,r.top,r.width,r.height)
	end sub

	sub DrawOval(left as integer, top as integer, width as integer, height as integer)
		//- Draw an oval to fit the rectangle at left, top with size width, height on the Canvas.
		APC_CanvasDrawOval(cIdx,left,top,width,height)
	end sub

	sub DrawOval(r as Rect)
		//- Draw an oval to fit the given rectangle on the Canvas.
		APC_CanvasDrawOval(cIdx,r.left,r.top,r.width,r.height)
	end sub

	sub FillOval(left as integer, top as integer, width as integer, height as integer)
		//- Draw and fill an oval to fit the rectangle at left, top with size width, height on the Canvas.
		APC_CanvasFillOval(cIdx,left,top,width,height)
	end sub

	sub FillOval(r as Rect)
		//- Draw and fill an oval to fit the given rectangle on the Canvas.
		APC_CanvasFillOval(cIdx,r.left,r.top,r.width,r.height)
	end sub

	sub DrawSky(left as integer, top as integer, size as integer, optional bonw as boolean = false, optional title as string = "", optional fontfactor as double = 1.0)
		//- The DrawSky method draws a Sky chart in a square region (at location left, top and of size x size pixels) 
		//- of the Canvas, suitably scaled.
		//- The bonw parameter specifies whether the chart should be as in the plan document (default, false), 
		//- or as a black-on-white-sky picture (true). 
		//- If a title is specified it is displayed just above the left/top corner (so take that into 
		//- account when supplying coordinates). 
		//- If the font used in the chart is too small or too large, the fontfactor can be used to fine-tune 
		//- the size (e.g. fontfactor = 0.5 will halve the size). 
		//- Note that after drawing the Canvas, all Sky-related parameters are reset back to their original values in the plan document.
		APC_CanvasDrawSky(cIdx,left,top,size,bonw,title,fontfactor)
	end sub

	sub DrawFoV(left as integer, top as integer, size as integer, optional bonw as boolean = false, optional title as string = "", optional fontfactor as double = 1.0, optional starfactor as double = 1.0)
		//- The DrawFoV method draws a Field of View chart in a square region (at location 
		//- left, top and of size x size pixels) of the Canvas, suitably scaled.
		//- The bonw parameter specifies whether the chart should be as in the plan document (default, false), 
		//- or as a black-on-white-sky picture (true). 
		//- If a title is specified it is displayed just above the left/top corner (so take that into account when supplying coordinates). 
		//- If the font used in the chart is too small or too large, 
		//- the fontfactor can be used to fine-tune the size (e.g. fontfactor = 0.5 will halve the size). 
		//- If the stars plotted in the chart are too small or too large, 
		//- the starfactor can be used to fine-tune the size (e.g. starfactor = 1.5 will make the stars 50% larger). 
		//- Note that after drawing the Canvas, all FoV-related parameters are reset back to their original values in the plan document.
		APC_CanvasDrawFoV(cIdx,left,top,size,bonw,title,fontfactor,starfactor)
	end sub

	function Target(constellation as string, optional UseRA as double = -999.0, optional UseDec as double = -999.0) as double
		//- This specifies the coordinates of the centre of the FoV chart (RA/Dec) to be 
		//- the centre of the specified constellation (e.g. "UMa"). 
		//- If the UseRA/UseDec coordinates are specified, they should be within the constellation, 
		//- and are used to only to determine what part of the constellation to use in the case of 
		//- ambiguity (i.e. only with Serpens, since the constellation is in two parts: Serpens Caput and Serpens Cauda).
		return APC_CanvasTargetConstellation(cIdx,constellation,UseRA,UseDec)
	end function

	sub Target(ra as double, dec as double)
		//- This specifies the coordinates of the centre of the FoV chart (RA/Dec).
		APC_CanvasTarget(cIdx,"","",ra,dec)
	end sub

	sub Target(obj as APPlanObject)
		//- This specifies the coordinates of the centre of the FoV chart (RA/Dec) as the coordinates of the specified plan object.
		APC_CanvasTarget(cIdx,obj.ID,obj.Type,obj.RA,obj.Dec)
	end sub

	sub Target(obj as APCatalogObject)
		//- This specifies the coordinates of the centre of the FoV chart (RA/Dec) as the coordinates of the specified catalogue object.
		APC_CanvasTarget(cIdx,obj.ID,obj.Type,obj.RA,obj.Dec)
	end sub

	sub Target(obs as APObservation)
		//- This specifies the coordinates of the centre of the FoV chart (RA/Dec) as the coordinates of the object 
		//- associated with the specified observation.
		APC_CanvasTarget(cIdx,obs.ID,obs.Type,obs.RA,obs.Dec)
	end sub
	
	sub FoVSize(diam as double)
		//- Specify the diameter of the FoV chart in degrees (from 0.1 to 60.0).
		APC_CanvasFoVSize(cIdx,diam)
	end sub

	function ImageCount(doSatellites as boolean) as integer
		//- Counts images associated with the target object. 
		//- If doSatellites is TRUE then an additional image showing 
		//- planetary satellites will be added (currently for Jupiter and Saturn). 
		//- Note that for this case, the same value of doSatellites should be used for IsUserImage(), etc.
		return APC_CanvasImageCount(cIdx,doSatellites)
	end function

	function IsUserImage(n as integer, doSatellites as boolean) as boolean
		//- Returns true if the n-th image associated with the target object is a User image. 
		//- If doSatellites is TRUE then an additional image showing 
		//- planetary satellites will be added (currently for Jupiter and Saturn). 
		//- Note that for this case, the same value of doSatellites should be used for ImageCount(), etc.
		return APC_CanvasIsUserImage(cIdx,n,doSatellites)
	end function

	function ImageDescription(n as integer, doSatellites as boolean) as string
		//- Returns the description for the n-th image associated with the target object. 
		//- If doSatellites is TRUE then an additional image showing 
		//- planetary satellites will be added (currently for Jupiter and Saturn). 
		//- Note that for this case, the same value of doSatellites should be used for ImageCount(), etc.
		return APC_CanvasImageDescription(cIdx,n,doSatellites)
	end function

	sub DrawImage(n as integer, doSatellites as boolean, left as integer, top as integer, size as integer, optional bonw as boolean = false, optional greyscale as boolean = false, optional title as boolean = true, optional flipew as boolean = false, optional flipns as boolean = false)
		//- Draw the n-th image associated with the target object. 
		//- If doSatellites is TRUE then an additional image showing 
		//- planetary satellites will be added (currently for Jupiter and Saturn). 
		//- Note that for this case, the same value of doSatellites should be used for ImageCount(), etc.
		APC_CanvasDrawImage(cIdx,n,doSatellites,left,top,size,bonw,greyscale,title,flipew,flipns)
	end sub

	sub DrawImage(img as Image, left as integer, top as integer, size as integer, optional bonw as boolean = false, optional greyscale as boolean = false, optional title as boolean = true, optional flipew as boolean = false, optional flipns as boolean = false)
		//- Draw the specified image object on the Canvas at left/top with width and height = size. 
		//- If bonw is true, invert the grey scaling of the image. 
		//- If greyscale is true then convert the image from colour to shades of grey. 
		//- If title is true, display the image's title. 
		//- If flipew is true, flip the image horizontally. 
		//- If flipns is true, flip the image vertically.
		APC_CanvasDrawImage(cIdx,img.APC_Img_Index,left,top,size,bonw,greyscale,title,flipew,flipns)
	end sub

	sub DrawImageFromClipboard(left as integer, top as integer, optional width as integer = -1, optional height as integer = -1)
		//- Display the image on the clipboard (where applicable) on the Canvas at left/top. 
		//- If specified, adjust the width and/or height.
		APC_CanvasDrawImageFromClipboard(cIdx,left,top,width,height)
	end sub

	sub DrawImage(path as string, left as integer, top as integer, width as integer, height as integer, optional invert as boolean = false, optional greyscale as boolean = false, optional scaled as boolean = true, optional title as string = "", optional flipew as boolean = false, optional flipns as boolean = false)
		//- Draw the image in the file specified by path on the Canvas in the rectangle specified by left/top/width/height. 
		//- If invert is true, invert the grey scaling of the image. 
		//- If greyscale is true then convert the image from colour to shades of grey. 
		//- If scaled is true then scale the image to the rectangle, otherwise clip the image to the rectangle. 
		//- If title is true, display the image's title. 
		//- If flipew is true, flip the image horizontally. 
		//- If flipns is true, flip the image vertically.
		APC_CanvasDrawImage(cIdx,path,left,top,width,height,invert,greyscale,scaled,title,flipew,flipns)
	end sub
	
	sub DrawImage(path as string, r as Rect, optional invert as boolean = false, optional greyscale as boolean = false, optional scaled as boolean = true, optional title as string = "", optional flipew as boolean = false, optional flipns as boolean = false)
		//- Draw the image in the file specified by path on the Canvas in the rectangle specified by r. 
		//- If invert is true, invert the grey scaling of the image. 
		//- If greyscale is true then convert the image from colour to shades of grey. 
		//- If scaled is true then scale the image to the rectangle, otherwise clip the image to the rectangle. 
		//- If title is true, display the image's title. 
		//- If flipew is true, flip the image horizontally. 
		//- If flipns is true, flip the image vertically.
		APC_CanvasDrawImage(cIdx,path,r.left,r.top,r.width,r.height,invert,greyscale,scaled,title,flipew,flipns)
	end sub
	
	sub DrawConstellation(left as integer, top as integer, width as integer, height as integer, optional constellation as string = "", optional ra as double = -999.0, optional dec as double = -999.0, optional bonw as boolean = false)
		//- Draw a constellation chart at the given coordinates, with the given size (width and height).
		//- Show the specified constellation, or if blank, the constellation of the Target.
		//- Mark the object at the given RA/Dec coodinates, or if ra<0.0, use the Target.
		//- If bonw is TRUE then the chart will have a white background, otherwise a black background.
		APC_CanvasDrawConstellation(cIdx,left,top,width,height,constellation,ra,dec,bonw)
	end sub

	sub DrawConstellation(r as Rect, optional constellation as string = "", optional ra as double = -999.0, optional dec as double = -999.0, optional bonw as boolean = false)
		//- Draw a constellation chart in the given Rectangle.
		//- Show the specified constellation, or if blank, the constellation of the Target.
		//- Mark the object at the given RA/Dec coodinates, or if ra<0.0, use the Target.
		//- If bonw is TRUE then the chart will have a white background, otherwise a black background.
		APC_CanvasDrawConstellation(cIdx,r.left,r.top,r.width,r.height,constellation,ra,dec,bonw)
	end sub

	sub FoVOption(id as integer, state as boolean)
		//- Use the fovopt_ constants for id.
		APC_CanvasFoVOption(cIdx,id,state)
	end sub

	sub FoVRotationAngle(assigns v as integer)
		//- Angle to which to rotate the field of view chart, in degrees.
		APC_CanvasFoVRotationAngle(cIdx,v)
	end sub

	function FoVRotationAngle() as integer
		return APC_CanvasFoVRotationAngle(cIdx)
	end function

	sub FoVReticleAngle(assigns v as integer)
		//- Angle to which to rotate any reticles displayed on then field of view chart, in degrees.
		APC_CanvasFoVReticleAngle(cIdx,v)
	end sub

	function FoVReticleAngle() as integer
		return APC_CanvasFoVReticleAngle(cIdx)
	end function

	sub SkyOption(id as integer, state as boolean)
		//- Set the specified Sky Display Option (checkbox) to the given state.
		//- Use the skyopt_ constants for id.
		APC_CanvasSkyOption(cIdx,id,state)
	end sub

	sub SkyOptionChoice(id as integer, v as integer)
		//- If the specified Sky Display Option has an additional parameter, use this method to set the value to v.
		//- Use the skyopt_ constants for id.
		APC_CanvasSkyOptionChoice(cIdx,id,v)
	end sub

	sub FoVCatalog(title as string, use as boolean, label as boolean)
		//- Use the specified catalogue (use = true), where title is the catalogue name in the list on the Field of View tab. 
		//- e.g. “Bright”, “All-Sky”, etc. An empty title string will cause all catalogues to be set as directed 
		//- (e.g. FOVCatalog(“”,false,false) will turn all catalogues off.
		//- The label parameter is used to turn labeling on or off for the specified catalogue.
		APC_CanvasFoVCatalog(cIdx,title,use,label)
	end sub

	sub FoVMagnitudeLimits(stars as double, starLabels as double, DSOs as double, DSOLabels as double)
		//- Set the field of view chart magnitude limit sliders to the specified values (in magnitudes).
		APC_CanvasFoVMagLimits(cIdx,stars,starlabels,dsos,dsolabels)
	end sub

	sub FoVStarLimits(minmag as double, maxmag as double)
		//- You can set the star scaling limits with this method. e.g. FoVStarLimits(0.0,5.0) for naked eye stars, etc.
		APC_CanvasFoVStarLimits(cIdx,minmag,maxmag)
	end sub

	sub SkyStarMagnitudeLimit(assigns m as double)
		//- Sets the magnitude limit of the dimmest star in the Sky chart drawn by DrawSky
		APC_CanvasSkyStarMagnitudeLimit(cIdx,m)
	end sub

	sub FoVAperture(assigns b as boolean)
		Deprecate("FoVAperture=b","FoVOption(Canvas.fovopt_Display_Aperture,b)")
		FoVOption(fovopt_Display_Aperture,b)
	end sub

	sub FoVCircle(title as string, diameter as double, optional ra as double = -999.0, optional dec as double = -999.0)
		//- Draw a centred circle in the field of view chart of the given diameter (in degrees), 
		//- with an optional title attached. 
		//- Specify the actual RA/Dec if you don’t want the circle centred.
		APC_CanvasFoVCircle(cIdx,title,diameter,ra,dec)
	end sub

	sub FoVCircleOffset(title as string, diameter as double, optional offsetX as double = -999.0, optional offsetY as double = -999.0, optional dotted as boolean = false)
		//- Draw a centred circle in the field of view chart of the given diameter (in degrees), 
		//- with an optional title attached. 
		//- Specify the the offsetX and/or offsetY (in degrees) if you don’t want the circle centred.
		//- Specify the actual RA/Dec if you don’t want the circle centred.
		//- Specify dotted = TRUE if you want the circle dotted rather than solid.
		APC_CanvasFoVCircleOffset(cIdx,title,diameter,offsetX,offsetY,dotted)
	end sub

	sub FoVRectangle(title as string, width as double, height as double, optional angle as double = 0.0, optional ra as double = -999.0, optional dec as double = -999.0)
		//- Draw a centred rectangle in the field of view chart of the given width and height (in degrees), 
		//- with an optional title attached. 
		//- Specify the actual RA/Dec if you don’t want the circle centred. 
		//- Specify an angle (in degrees) if the rectangle should be rotated from a N-S/E-W orientation.
		APC_CanvasFoVRectangle(cIdx,title,width,height,angle,ra,dec)
	end sub

	sub FoVRectangleOffset(title as string, width as double, height as double, optional angle as double = 0.0, optional offsetX as double = -999.0, optional offsetY as double = -999.0, optional dotted as boolean = false)
		//- Draw a rectangle in the field of view chart of the given width and height (in degrees), 
		//- with an optional title attached. 
		//- Specify the the offsetX and/or offsetY (in degrees) if you don’t want the rectangle centred. 
		//- Specify an angle (in degrees) if the rectangle should be rotated from a N-S/E-W orientation.
		//- Specify dotted = TRUE if you want the rectangle dotted rather than solid.
		APC_CanvasFoVRectangleOffset(cIdx,title,width,height,angle,offsetX,offsetY,dotted)
	end sub

	sub ForeColor(r as integer, g as integer, b as integer)
		//- Specify the foreground colour for drawing text, lines, etc. 
		//- r/g/b are the red/green/blue components of the colour and range from 0 to 255. 
		//- e.g. ForeColor(0,0,0) is black, ForeColor(255,255,255) is white, ForeColour(127,0,0) is dark red, etc.
		APC_CanvasForeColor(cIdx,r,g,b)
	end sub

	sub ForeColor(assigns c as Color)
		//- Specify the foreground colour for drawing text, lines, etc.
		APC_CanvasForeColor(cIdx,c)
	end sub

	function ForeColor() as Color
		return APC_CanvasForeColor(cIdx)
	end function

	function DrawTable(t as Table, left as integer, top as integer, width as integer, height as integer, optional grid as integer = 0) as integer
		//- Draws a table, t, on the Canvas at left/top with width and height. 
		//- grid specifies the type of gridlines used by the table (using the grid_ constants): 
		//- grid_None (no grid), grid_Thin (grid using thin lines), grid_Thick (grid using thicker lines).
		//- Returns the vertical (y) coordinate of the bottom/left of the table.
		if t<>nil then
			return APC_CanvasDrawTable(cIdx,t.Get_Idx,left,top,width,height,grid)
		else
			return top
		end if
	end function

	function DrawTable(t as Table, r as Rect, optional grid as integer = 0) as integer
		//- Draws a table, t, on the Canvas in the given rectangle, r. 
		//- grid specifies the type of gridlines used by the table (using the grid_ constants): 
		//- grid_None (no grid), grid_Thin (grid using thin lines), grid_Thick (grid using thicker lines).
		//- Returns the vertical (y) coordinate of the bottom/left of the table.
		return DrawTable(t,r.left,r.top,r.width,r.Height,grid)
	end function

	function TableHeight(t as Table, width as integer, optional grid as integer = 0) as integer
		//- Returns the height of a table, t, when drawn on the Canvas with the given width, and using the specified grid (grid_ constants). 
		//- This can be used to determine if a table will fit on the remaining space on a page, for example.
		if t=nil or width<=0 then return -1 else return APC_CanvasTableHeight(cIdx,t.Get_Idx,width,grid)
	end function

	sub TablePadding(grid as integer, byref h as integer, byref v as integer)
		//- Returns the horizontal (h) and vertical (v) table padding, when the given grid (grid_ constants) is used.
		dim hh,vv as integer
		APC_CanvasTablePadding(cIdx,grid,hh,vv)
		h=hh
		v=vv
	end sub

	function SaveAsImageFile(optional path as string = "", optional UsePNG as boolean = false) as boolean
		//- Save the current page as a graphics file (defaults to JPEG at high-quality, 
		//- or if UsePNG is true then as a PNG file). 
		//- If path is empty (default) then the user is asked for a file name to save. 
		//- If path is a folder then the image will be saved as “pagen.jpg” (or “pagen.png”), 
		//- where n is the current page number. Otherwise, the file is saved as path. 
		//- Returns true if successful.
		return APC_CanvasSaveAsImageFile(cIdx,path,UsePNG)
	end function

end class

//------------------------------------------------------------------------------------
class Table
	// Documented 10/9/2012
	//- Create a table (multiple rows and columns) to embed in a Canvas.
	//- Rows are numbered from 1 (at the top) to RowCount (at the bottom).
	//- Columns are numbered from 1 (at the left) to ColumnCount (at the right).
	//- Use the Canvas.DrawTable method to draw the table into a Canvas object.
	private dim tIdx as integer

	const grid_None=0
	const grid_Thin=1
	const grid_Thick=2

	const style_None = 0
	const style_Bold = 1
	const style_Italic = 2
	const style_Underline = 4
	const style_Inverted = 8
	const style_Gray = 16

	const justify_Left = 1
	const justify_Center = 2
	const justify_HCenter = 2
	const justify_Right = 3

	const justify_Top = 100
	const justify_VCenter = 200
	const justify_Bottom = 300

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(rows as integer, columns as integer, optional title as string = "")
		//- Create a Table object with the specified number of rows and columns. 
		//- You can optionally supply a title for the table that will be displayed at the top.
		tIdx=APC_TableCreate(rows,columns,title)
	end sub

	sub Destructor() // private
		Close
	end sub

	function Get_Idx() as integer // private
		return tidx
	end function

	sub Close()
		//- Destroy the Table object. 
		//- Note that is not necessary if the Table objects goes out of scope, when it will be called automatically.
		APC_TableClose(tIdx)
	end sub

	function Cell(row as integer, column as integer) as string
		//- Get the text in the table cell at row, column.
		return APC_TableGetCell(tIdx,row,column)
	end function

	sub Cell(row as integer, column as integer, assigns s as string)
		//- Set the text in the table cell at row, column.
		APC_TableSetCell(tIdx,row,column,s)
	end sub
	
	sub Cell(row as integer, column as integer, assigns img as Image)
		//- Assign an Image to the table cell at row, column. 
		//- The image will be scaled to fit in the cell where necessary.
		if img<>nil then APC_TableSetCell(tIdx,row,column,"..image..="+format(img.APC_Img_Index,"-0"))
	end sub

	sub SaveAsText(optional path as string = "", optional delimiter as string = "", optional hasTitles as boolean = false)
		//- Save the table to a text file specified by path. 
		//- If path is not specified, you’ll be prompted to select a file, 
		//- otherwise a path to a file is expected. 
		//- The delimiter for separating items in a text line (table row) defaults to a tab character. 
		//- If hasTitles is true (default=false), then the first line of the file will hold column titles, 
		//- if a heading row exists in the table.
		APC_TableSaveAsText(tIdx, path, delimiter, hasTitles)
	end sub

	sub LoadFromText(optional path as string = "", optional delimiter as string = "", optional hasTitles as boolean = false)
		//- Load the table from a text file, specified by path. 
		//- The number of rows and columns will be determined from the file’s content. 
		//- If path is not specified, you’ll be prompted to select a file, 
		//- otherwise a path to an existing file is expected. 
		//- The delimiter for separating items in a text line (table row) defaults to a tab character. 
		//- If hasTitles is true (default=false), then the first line of the file is expected to hold column titles, 
		//- and a heading row will be created.
		APC_TableLoadFromText(tIdx, path, delimiter, hasTitles)
	end sub

	sub AddRow()
		//- Adds a new row to the bottom of the table.
		APC_TableAddRow(tIdx)
	end sub

	sub AddColumn()
		//- Adds a new column to the right of the table.
		APC_TableAddColumn(tIdx)
	end sub

	function RowCount() as integer
		//- Number of rows in the table.
		return APC_TableRowCount(tIdx)
	end function

	function ColumnCount() as integer
		//- Number of columns in the table.
		return APC_TableColumnCount(tIdx)
	end function

	sub DeleteRow(row as integer)
		//- Deletes the specified row of the table.
		APC_TableDeleteRow(tIdx,row)
	end sub

	sub DeleteColumn(column as integer)
		//- Deletes the specified column of the table.
		APC_TableDeleteColumn(tIdx,column)
	end sub

	sub ColumnTitle(column as integer, assigns s as string)
		//- Assign a title to the specified column. The titles are also accessible as row 0.
		APC_TableSetColumnTitle(tIdx,column,s)
	end sub

	function ColumnTitle(column as integer) as string
		//- Get the title of the specified column. The titles are also accessible as row 0.
		return APC_TableGetColumnTitle(tIdx,column)
	end function

	sub ColumnWidth(column as integer, assigns w as double)
		//- Set the column width of the specified column as a percentage of the table width. 
		//- Setting a negative number (default) will cause the column to be assigned an arbitrary 
		//- width depending on the widths of other columns. e.g. if a four column table has column 1 
		//- set to 20 (%), and column 4 set to 30 (%), then columns 2 and 3 will be assigned equal widths of 25 (%).
		APC_TableSetColumnWidth(tIdx,column,w)
	end sub

	sub RowHeight(row as integer, assigns h as double)
		//- The height of a row defaults to the height of a line of text (plus a small gap before and after). 
		//- RowHeight sets the height of a row to a percentage of one line of text. 
		//- e.g. RowHeight(3)=200.0 will make row 3 deep enough to include two lines of text. 
		//- Setting the height to a negative number will make that row fill the rest of the allotted 
		//- table height (so only do that for the last row).
		APC_TableSetRowHeight(tIdx,row,h)
	end sub

	sub ColumnJustify(column as integer, assigns j as integer)
		//- Set the justification of text in a column. 
		//- The value is a combination of one value from the text horizontal justification justify_ constants 
		//- together with one from the text horizontal justification justify_ constants. e.g. 
		//-   ColumnJustify(4) = Table.justify_Left + Table.justify_Vcenter
		//- will justify all text in column 4 to be left-justified and centred vertically.
		APC_TableSetColumnJustify(tIdx,column,j)
	end sub

	sub CellStyle(row as integer, column as integer, assigns style as integer)
		//- Specify the style of text in a cell. Can be a combination of zero or more of the style_ constants. e.g.
		//-    CellStyle(3,i) = Table.style_Bold + Table.style_Inverted + Table.style_Gray
		//- will colour the background grey, and make the text white and bold.
		APC_TableSetCellStyle(tIdx,row,column,style)
	end sub

	sub RowStyle(row as integer, assigns style as integer)
		//- Specify the style of all text in the specified row. Can be a combination of zero or more of the style_ constants. e.g.
		//-    CellStyle(3,i) = Table.style_Bold + Table.style_Inverted + Table.style_Gray
		//- will colour the background grey, and make the text white and bold.
		APC_TableSetRowStyle(tIdx,row,style)
	end sub

	sub CellFontName(row as integer, column as integer, assigns name as string)
		//- Specify the font name to use for text in the specified cell at row/column.
		APC_TableSetCellFontName(tIdx,row,column,name)
	end sub

	sub CellFontSize(row as integer, column as integer, assigns size as integer)
		//- Specify the font size to use for text in the specified cell at row/column.
		APC_TableSetCellFontSize(tIdx,row,column,size)
	end sub

	sub RowFontName(row as integer, assigns name as string)
		//- Specify the font name to use for all text in the specified row.
		APC_TableSetRowFontName(tIdx,row,name)
	end sub

	sub RowFontSize(row as integer, assigns size as integer)
		//- Specify the font size to use for all text in the specified row.
		APC_TableSetRowFontSize(tIdx,row,size)
	end sub

end class

//------------------------------------------------------------------------------------
class APResource
	// Documented 7/8/2012
	//- Base class for Resource objects (e.g. Site, Telescope, etc.). 
	//- All objects will be instances of a subclass of this class.
	//- Note: Do not construct new instances of this object.
	implements NamedObject
	
	public const rsrc_Site = 0
	public const rsrc_Telescope = 1
	public const rsrc_Eyepiece = 2
	public const rsrc_OpticalAid = 3
	public const rsrc_VisualAid = 3
	public const rsrc_Filter = 4
	public const rsrc_Observer = 5
	public const rsrc_Imager = 6

	private const rsrc_Last = 6
	
	public const rtype_active = 0
	public const rtype_inactive = 1
	public const rtype_both = 2
	
	private dim Res_name(-1) as string
	private dim Res_value(-1) as string
	private dim Res_type as integer
	private dim Res_n as integer

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(rtype as integer, n as integer, all as boolean) // private
		dim ar(-1) as string
		dim i as integer
		Res_n = n
		Res_type=rtype
		ar=APC_ResourceGet(Res_type,Res_n,all)
		for i=0 to ubound(ar)
			Res_name.Append NthField(ar(i),chr(9),1)
			Res_value.Append NthField(ar(i),chr(9),2)
		next
	end sub

	protected function StringValue(name as string) as string
		dim i as integer
		i=Res_name.IndexOf(name)
		if i<0 then return "" else return Res_Value(i)
	end function

	protected sub StringValue(name as string, assigns value as string)
		dim i as integer
		dim j as integer
		j=Res_name.IndexOf("Name")
		i=Res_name.IndexOf(name)
		if i>=0 and Res_Value(i)<>value then
			if APC_ResourceSet(Res_Type,Res_Value(j),name,value) then
				Res_Value(i)=value
				if name="Name" then APCReset(Res_type)
			end if
		end if
	end sub

	protected function BooleanValue(name as string) as boolean
		return StringValue(name)="1"
	end function

	protected sub BooleanValue(name as string, assigns value as boolean)
		if value then StringValue(name)="1" else StringValue(name)="0"
	end sub

	protected function DoubleValue(name as string) as double
		return CDbl(StringValue(name))
	end function

	protected sub DoubleValue(name as string, assigns value as double)
		StringValue(name)=DoubleToStr(value)
	end sub

	protected function IntegerValue(name as string) as integer
		return val(StringValue(name))
	end function

	protected sub IntegerValue(name as string, assigns value as integer)
		StringValue(name)=format(value,"-0")
	end sub

	function Name() as string
		return StringValue("Name")
	end function

	sub Name(assigns value as string)
		if value<>"" then StringValue("Name")=value
	end sub

	function ObjectName() as string // private
		return Name
	end function

	function Comment() as string
		return StringValue("Comment")
	end function

	sub Comment(assigns value as string)
		StringValue("Comment")=value
	end sub

	function URL() as string
		return StringValue("URL")
	end function

	sub URL(assigns value as string)
		StringValue("URL")=value
	end sub

	function AtSite() as string
		return StringValue("AtSite")
	end function

	sub AtSite(assigns value as string)
		StringValue("AtSite")=value
	end sub

	function IsDefault() as boolean
		return BooleanValue("IsDefault")
	end function

	sub IsDefault(assigns value as boolean)
		BooleanValue("IsDefault")=value
	end sub

	function Active() as boolean
		//- Get/Set the Active property
		return BooleanValue("Active")
	end function

	sub Active(assigns value as boolean)
		BooleanValue("Active")=value
	end sub
	
	function IndexOf(optional activetype as integer = APResource.rtype_Active) as integer
		//- Return the 1-based index of the resource r in the appropriate resource type list. 
		//- For example, if the calling resource is a TelescopeResource returned by TelescopeResource.Get(5,APResource.rtype_Both),
		//- then IndexOf(APResource.rtype_Both) will return 5.
		//- If the resource is not present in the list, -1 is returned.
		//- Warning: If you are indexing the array returned by XXXXResource.All(), then remember that arrays are 0-based, 
		//- and subtract 1 where necessary.
		return GetIndexOf(me,activetype)
	end function

	function nUserFields() as integer
		//- Returns the number of user fields associated with this resource.
		return APUserField.nUserFields(-1,Res_n,-1,APUserField.ufnit_Resource+Res_type)
	end function

	function UserField(n as integer) as APUserField
		//- Return the n-th user field, where n = 1, ..., nUserFields.
		return APUserField.UserField(-1,Res_n,-1,APUserField.ufnit_Resource+Res_type,n)
	end function

	function UserField(title as string, optional createIfMissing as boolean = true) as APUserField
		//- Return the user field with the given title. 
		//- If createIfMissing is true, and no such user field exists, one with that title will be created for you. If not, nil will be returned.
		return APUserField.UserField(-1,Res_n,-1,APUserField.ufnit_Resource+Res_type,title,createIfMissing)
	end function

	function AddUserField(title as string) as APUserField
		//- Add a new user-field entry to the resource, and return its APUserField object
		//- Note: This only inserts a new item with the given title. You will need to change
		//- The value of the returned APUserField. Also, it does not create a definition for
		//- 'title' - for that you will need to use the corresponding NewUserFieldDefinition() 
		//- method.
		return APUserField.AddField(-1,Res_n,-1,APUserField.ufnit_Resource+Res_type,title)
	end function

	function DeleteUserField(title as string) as boolean
		//- Delete an existing user-field entry of the resource.
		//- Note: This only deletes an existing item with the given title, not the definition
		//- (if one exists). Use the corresponding DeleteUserFieldDefinition() method to
		//- delete the underlying definition.
		//- Return TRUE if found and deleted.
		return APUserField.DeleteField(-1,Res_n,-1,APUserField.ufnit_Resource+Res_type,title)
	end function

  // Shared stuff
  
  private shared dim APRsrc_Init(rsrc_Last) as boolean
  private shared dim APRsrc_Active(rsrc_Last) as Variant
  private shared dim APRsrc_Inactive(rsrc_Last) as Variant
  private shared dim APRsrc_Both(rsrc_Last) as Variant
  
  private shared sub APCReset(rtype as integer)
  	APRsrc_Init(rtype)=false
		call Count(rtype,rtype_Active)
	end sub

	shared function Count(rtype as integer, activetype as integer) as integer
		//- Return count of existing resources of type rtype (where rtype = rsrc_Site, etc.)
		//- If activetype=rtype_active (default) then the number of Active resources is returned. 
		//- If activetype=rtype_inactive then the number of inactive resources is returned.
		//- If activetype=rtype_both then the number of active and inactive resources is returned.
		dim n as integer
		dim i as integer
		dim tactive(-1),tinactive(-1),tboth(-1) as APResource
		
		if rtype<0 or rtype>rsrc_Last then return 0
		
		if not APRsrc_Init(rtype) then
			APRsrc_Init(rtype)=true
			n=APC_ResourceCount(rtype,true)
			for i=0 to n-1
				dim r as APResource
				select case rtype
				case rsrc_Site
					r = new SiteResource(i,true)
				case rsrc_Telescope
					r = new TelescopeResource(i,true)
				case rsrc_Eyepiece
					r = new EyepieceResource(i,true)
				case rsrc_OpticalAid
					r = new OpticalAidResource(i,true)
				case rsrc_Filter
					r = new FilterResource(i,true)
				case rsrc_Observer
					r = new ObserverResource(i,true)
				case rsrc_Imager
					r = new ImagerResource(i,true)
				end select
				if r.Active then tactive.Append r else tinactive.Append r
				tboth.Append r
			next
			APRsrc_Active(rtype)=tactive
			APRsrc_InActive(rtype)=tinactive
			APRsrc_Both(rtype)=tboth
		end if
		dim ta() as APResource = APRsrc_Active(rtype)
		dim ti() as APResource = APRsrc_InActive(rtype)
		dim tb() as APResource = APRsrc_Both(rtype)
		select case activetype
		case rtype_active
			return ubound(ta)+1
		case rtype_inactive
			return ubound(ti)+1
		else
			return ubound(tb)+1
		end select
	end function

	shared function Get(rtype as integer, n as integer, activetype as integer) as APResource
    //- Return n-th existing resource of type rtype (where rtype = rsrc_Site, etc.)
		//- If activetype=rtype_active (default) then the n-th Active resource is returned. 
		//- If activetype=rtype_inactive then the n-th Inactive resource is returned.
		//- If activetype=rtype_both then the n-th resource is returned, regardless of its Active status.
	  
	  if rtype<0 or rtype>rsrc_Last then return nil
		if n>=1 and n<=Count(rtype,activetype) then
			dim t() as APResource
			select case activetype
			case rtype_active
				t = APRsrc_Active(rtype)
			case rtype_inactive
				t = APRsrc_InActive(rtype)
			case rtype_both
				t = APRsrc_Both(rtype)
			end select
			return t(n-1)
		else
			return nil
		end if
	end function

	shared function Get(rtype as integer, name as string) as APResource
	  //- Return existing resource with given name of type rtype (where rtype = rsrc_Site, etc.)
	  //- Return nil if not found
		dim t(-1) as APResource = APRsrc_Both(rtype)
	  for i as integer = 0 to ubound(t)
	  	if t(i).Name=name then return t(i)
	  next
	  
	  return nil
	end function

	shared function Create(rtype as integer, name as string) as APResource
	  //- Create an active resource with given name of type rtype (where rtype = rsrc_Site, etc.)
	  //- If a resource already exists with that name, then return nil
	  if Get(rtype,name)<>nil then return nil
		APC_ResourceCreate(rtype,name)
		APCReset(rtype)
		return Get(rtype,name)
	end function

	shared function Delete(rtype as integer, name as string) as boolean
	  //- Delete resource with given name of type rtype (where rtype = rsrc_Site, etc.)
	  //- Return true if resource found and deleted
	  if Get(rtype,name)=nil then return false
	  APC_ResourceDelete(rtype,name)
		APCReset(rtype)
		return Get(rtype,name)=nil
	end function

	shared function Default(rtype as integer) as APResource
	  //- Return existing Default resource of type rtype (where rtype = rsrc_Site, etc.)
	  //- Return nil if no Default resource.
		dim i as integer

		for i=1 to Count(rtype,rtype_Active)
			dim r as APResource = Get(rtype,i,rtype_Active)
			if r.IsDefault then return r
		next
		return nil
	end function

	shared function All(rtype as integer, optional activetype as integer = APResource.rtype_Active) as APResource()
	  //- Return an array of all resources of type rtype (where rtype = rsrc_Site, etc.)
		//- If activetype=rtype_active (default) then all Active resources are returned. 
		//- If activetype=rtype_inactive then all Inactive resources are returned.
		//- If activetype=rtype_both then all resources are returned, regardless of their Active status.
	  
		dim i as integer
		dim r(-1) as APResource
		for i=1 to Count(rtype,activetype)
			r.Append Get(rtype,i,activetype)
		next
		return r
	end function
	
	shared function Type(rtype as integer) as string
		//- Return a string with the type of the specified resource type,
		//- where rtype = rsrc_Site, etc.
		//- e.g. if rtype = rsrc_Eyepiece, then "Eyepiece" is returned.
		select case rtype
		case rsrc_Site
			return "Site"
		case rsrc_Telescope
			return "Telescope"
		case rsrc_Eyepiece
			return "Eyepiece"
		case rsrc_OpticalAid
			return "Optical Aid"
		case rsrc_Filter
			return "Filter"
		case rsrc_Observer
			return "Observer"
		case rsrc_Imager
			return "Imager"
		else
			return "???"
		end select
	end function
		
	shared function Choose(rtype as integer, optional multiple as boolean = false) as APResource()
		//- Use a dialog to select one or more resources from a list of all (active) resources.
		//- rtype is the type of resource to select, where rtype = rsrc_Site, etc.
		//- If multiple is true, allow selecting zero or more resources.
		//- If multiple is false, allow selection of a single resource.
		//- If the Cancel button is used (or the dialog closed), or no resource is selected, 
		//- then an empty array is returned.
	
		dim rlist() as NamedObject = APResource.All(rtype)
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,APResource.Type(rtype))
		dim result() as APResource
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = APResource(r(i))
		next
		return result
	end function

	private shared function GetIndexOf(r as APResource, optional activetype as integer = APResource.rtype_Active) as integer
		//- Return the 1-based index of the resource r in the appropriate resource type list. 
		//- For example, if r is a Telescope resource returned by TelescopeResource.Get(5,APResource.rtype_Both),
		//- then TelescopeResource.GetIndexOf(r,APResource.rtype_Both) will return 5.
		//- If the resource is not present in the list, -1 is returned.
		//- Warning: If you are indexing the array returned by XXXXResource.All(), then remember that arrays are 0-based, 
		//- and subtract 1 where necessary.
		
		if r=nil or not r isa APResource then return -1
		dim t() as APResource
		select case activetype
		case APResource.rtype_Active
			t = APRsrc_Active(r.Res_type)
		case APResource.rtype_InActive
			t = APRsrc_InActive(r.Res_type)
		case APResource.rtype_Both
			t = APRsrc_Both(r.Res_type)
		end select
		for i as integer = 0 to ubound(t)
			if t(i).Name=r.Name then return i+1
		next
		return -1
	end function

	shared function Magnification(t as TelescopeResource, e as EyepieceResource, optional a as OpticalAidResource = nil) as double
		//- Return the magnification of a given Telescope resource paired with a given Eyepiece resource (and optionally with a given OpticalAid resource.
		if t=nil or e=nil then return 1.0
		if not t.IsTelescope then return t.Magnification
		if a=nil then
			return t.FocalLength/e.FocalLength
		else
			return (t.FocalLength+a.FocalLength)/e.FocalLength*a.Magnification
		end if
	end function

	shared function BestEyepieceForMagnification(t as TelescopeResource, magn as double, byref bestmagn as double) as EyepieceResource
		//- Find the best eyepiece to use with the given telescope to match the given magnification (magn).
		//- Also returns the magnification of that combination (bestmagn).
		//- Returns nil if no active eyepieces present, or if t=nil.
		if t=nil then return nil
		
		bestmagn = -1E30
		dim beste as EyepieceResource = nil
		for i as integer = 1 to EyepieceResource.Count
			dim e as EyepieceResource = EyepieceResource.Get(i)
			dim m as double = e.Magnification(t)
			if abs(magn - m)<abs(magn - bestmagn) then
				bestmagn = m
				beste = e
			end if
		next
		return beste
	end function

	shared function BestEyepieceAndOpticalAidForMagnification(t as TelescopeResource, magn as double, byref bestmagn as double, byref aid as OpticalAidResource) as EyepieceResource
		//- Find the best eyepiece and optical aid combination to use with the given telescope to match the given magnification (magn).
		//- Also returns the magnification of that combination (bestmagn).
		//- Returns nil if no active eyepieces present, or if t=nil.
		//- If aid is returned as nil then the eyepiece alone is the best combination.
		if t=nil then return nil
		
		bestmagn = -1E30
		dim beste as EyepieceResource = nil
		aid = nil
		for j as integer = 0 to OpticalAidResource.Count
			for i as integer = 1 to EyepieceResource.Count
				dim e as EyepieceResource = EyepieceResource.Get(i)
				dim a as OpticalAidResource
				if j = 0 then
					a = nil
				else
					a = OpticalAidResource.Get(j)
				end if
				dim m as double = e.Magnification(t,a)
				if abs(magn - m)<abs(magn - bestmagn) then
					bestmagn = m
					beste = e
					aid = a
				end if
			next
		next
		return beste
	end function

	shared function ActualFoV(t as TelescopeResource, e as EyepieceResource, optional a as OpticalAidResource = nil) as double
		//- Return the actual field of view (in degrees) of a given Telescope resource paired with a given Eyepiece resource (and optionally with a given OpticalAid resource.
		if t=nil then return 0.0
		if not t.IsTelescope then return t.FoV
		if e=nil then return 0.0
		return e.ApparentFoV/Magnification(t,e,a)
	end function
	
	shared function ActualFoV(t as TelescopeResource, im as ImagerResource, optional a as OpticalAidResource = nil, optional includeGuider as boolean = false) as Pair
		//- Return the actual field of view (in degrees) of a given Telescope resource paired with a given Imager resource (and optionally with a given OpticalAid resource.
		//- The result is a Pair object, p, with p.Left = the FoV of the width of the main imager sensor, and p.Right = the FoV of the height of the main imager sensor.
		//- If includeGuider is TRUE, and the imager also has a guider sensor, then the field of view is expanded to encapsulate both the main and guider sensors.
		dim p as new Pair(0.0,0.0)
		if t=nil then return p
		if not t.IsTelescope then
			p.Left = t.FoV
			return p
		end if
		if im=nil then return p
		dim fl as double 
		if a=nil then
			fl = t.FocalLength
		else
			fl = (t.FocalLength+a.FocalLength)*a.Magnification
		end if
		p.Left=im.SensorWidth/fl*180.0/pi
		p.Right=im.SensorHeight/fl*180.0/pi
		if includeGuider and im.HasGuider then
			dim w,h as double
			if im.GuiderOffsetX=0 then
				w = max(im.SensorWidth,im.GuiderWidth)
				h = max(im.SensorHeight,2*im.GuiderOffsetY+im.GuiderHeight)
			else
				w = max(im.SensorWidth,2*im.GuiderOffsetX+im.GuiderWidth)
				h = max(im.SensorHeight,im.GuiderHeight)
			end if
			p.Left=w/fl*180.0/pi
			p.Right=h/fl*180.0/pi
		end if
		return p
	end function
	
	shared sub APResourcesInitialise() // private
		call SiteResource.Count
		call TelescopeResource.Count
		call EyepieceResource.Count
		call OpticalAidResource.Count
		call FilterResource.Count
		call ObserverResource.Count
		call ImagerResource.Count
	end sub

end class

//------------------------------------------------------------------------------------
class SiteResource
	Inherits APResource
	//- Documented 7/8/2012
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. SiteResource.Get(n))

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer, all as boolean) // private
		super.Constructor(rsrc_Site,n,all)
	end sub

	function Latitude() as double
		//- Geographical latitude of site (-90 to +90 degrees).
		return DoubleValue("Latitude")
	end function

	sub Latitude(assigns value as double)
		if value>=-90.0 and value<=90.0 then DoubleValue("Latitude")=value
	end sub

	function Longitude() as double
		//- Geographical longitude of site (-180 to +180 degrees).
		return DoubleValue("Longitude")
	end function

	sub Longitude(assigns value as double)
		 if value>=-180.0 and value<=180.0 then DoubleValue("Longitude")=value
	end sub

	function Altitude() as integer
		//- Altitude above sea level, in metres.
		return IntegerValue("Altitude")
	end function

	sub Altitude(assigns value as integer)
		 if value>-1000 and value<10000 then IntegerValue("Altitude")=value
	end sub

	function GMTOffset(optional d as double = 0.0) as double
		//- if d=0, return Standard-time GMT offset in hours (-ve = West of 0°, +ve = East of 0°)
		//- if d>0, then return the GMT offset for the given date/time.
		if d<>0.0 and APC_IsDaylightSaving(d,IntegerValue("ObeysDST")) then
			return DoubleValue("GMTOffset")+1.0
		else
			return DoubleValue("GMTOffset")
		end if
	end function

	sub GMTOffset(assigns value as double)
		//- Standard-time GMT offset in hours (-ve = West of 0°, +ve = East of 0°)
		if value>=-13.0 and value<=13.0 then DoubleValue("GMTOffset")=value
	end sub

	function ClockOffset() as double
		//- Clock offset in hours.
		return DoubleValue("ClockOffset")
	end function

	sub ClockOffset(assigns value as double)
		if value>=-24.0 and value<=24.0 then DoubleValue("ClockOffset")=value
	end sub

	function SkyBrightness() as double
		//- Sky brightness in magnitudes per square arcsec.
		return DoubleValue("SkyBrightness")
	end function

	sub SkyBrightness(assigns value as double)
		if value>=0.0 and value<=30.0 then DoubleValue("SkyBrightness")=value
	end sub

	function USDST() as boolean
		//- True if the site obeys U.S. daylight saving rules.
		return IntegerValue("ObeysDST")=1
	end function

	sub USDST(assigns value as boolean)
		IntegerValue("ObeysDST")=1
	end sub

	function EUDST() as boolean
		//- True if the site obeys E.U. daylight saving rules.
		return IntegerValue("ObeysDST")=2
	end function

	sub EUDST(assigns value as boolean)
		IntegerValue("ObeysDST")=2
	end sub

	function Rating() as integer
		// Site rating.
		return IntegerValue("Rating")
	end function

	sub Rating(assigns value as integer)
		if value>=0 and value<=10 then IntegerValue("Rating")=value
	end sub
	
	function Darkness(localdatetime as double) as integer
		//- Return, for the specified local date/time, an indication of the level of darkness
		//- at the site. Returned values are one of the following:
		//-  0 - Daylight (i.e. between sunrise and sunset)
		//-  1 - Civil twilight
		//-  2 - Nautical twilight
		//-  3 - Astronomical twilight
		//-  4 - Complete darkness
  
		return APC_Darkness(localdatetime,Latitude,Longitude,GMTOffset(localdatetime))
	end function

// Shared methods

	shared function nUserFieldDefinitions() as integer
		//- Return number of Site user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Resource+rsrc_Site)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Site user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Site,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Site user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Site,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Site,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Site,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Site,title,deleteValues)
  end function
  
	shared function Count(optional activetype as integer = APResource.rtype_Active) as integer
		//- Return count of existing Site resources
		//- If activetype=rtype_active (default) then the number of Active resources is returned. 
		//- If activetype=rtype_inactive then the number of inactive resources is returned.
		//- If activetype=rtype_both then the number of active and inactive resources is returned.
		return APResource.Count(rsrc_Site,activetype)
	end function

	shared function Get(n as integer, optional activetype as integer = APResource.rtype_Active) as SiteResource
    //- Return n-th existing Site resource
		//- If activetype=rtype_active (default) then the n-th Active resource is returned. 
		//- If activetype=rtype_inactive then the n-th Inactive resource is returned.
		//- If activetype=rtype_both then the n-th resource is returned, regardless of its Active status.
	  return SiteResource(APResource.Get(rsrc_Site,n,activetype))
	end function

	shared function Get(name as string) as SiteResource
	  //- Return Site resource with given name
	  //- Return nil if not found
		return SiteResource(APResource.Get(rsrc_Site,name))
	end function

	shared function Create(name as string) as SiteResource
	  //- Create Site resource with given name
	  //- If a resource already exists with that name, then return nil
	  return SiteResource(APResource.Create(rsrc_Site,name))
	end function

	shared function Delete(name as string) as boolean
	  //- Delete Site resource with given name
	  //- Return true if resource found and deleted
	  return APResource.Delete(rsrc_Site,name)
	end function

	shared function Default() as SiteResource
	  //- Return Default Site resource
	  //- Return nil if no Default resource
		return SiteResource(APResource.Default(rsrc_Site))
	end function

	shared function All(optional activetype as integer = APResource.rtype_Active) as SiteResource()
	  //- Return an array of all Site resources.
		//- If activetype=rtype_active (default) then all Active resources are returned. 
		//- If activetype=rtype_inactive then all Inactive resources are returned.
		//- If activetype=rtype_both then all resources are returned, regardless of their Active status.
	  dim t(-1) as SiteResource
	  for i as integer = 1 to Count(activetype)
	  	t.Append Get(i,activetype)
	  next
	  return t
	end function
	
	shared function Current(optional p as APPlan = nil) as SiteResource
		//- Return the specified plan's current Site resource. If p is nil, then return the current plan's Site resource.
		dim s as SiteResource
		if p=nil then
			s=Plan().CurrentSite
		else
			s=p.CurrentSite
		end if
		if s=nil then return nil else return Get(s.Name)
	end function

end class

//------------------------------------------------------------------------------------
class TelescopeResource
	Inherits APResource
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. TelescopeResource.Get(n))

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer, all as boolean) // private
		super.Constructor(rsrc_Telescope,n,all)
	end sub

	function Aperture() as double
		//- Aperture in mm.
		if IsTelescope then
			return DoubleValue("Aperture")
		else
			return DoubleValue("BinocularAperture")
		end if
	end function

	sub Aperture(assigns value as double)
		if value<=0.0 or value>5000.0 then return
		if IsTelescope then
			DoubleValue("Aperture")=value
		else
			DoubleValue("BinocularAperture")=value
		end if
	end sub

	function FRatio() as double
		//- Focal ratio.
		if IsTelescope then
			return DoubleValue("FRatio")
		else
			return 5.0
		end if
	end function

	sub FRatio(assigns value as double)
		if value<=0.1 or value>500.0 then return
		if IsTelescope then
			DoubleValue("FRatio")=value
		end if
	end sub

	function FinderFoV() as double
		//- Finder field of view, in degrees.
		return DoubleValue("FinderFoV")
	end function

	sub FinderFoV(assigns value as double)
		if value<0.0 or value>100.0 then return
		DoubleValue("FinderFoV")=value
	end sub

	function Obstruction() as double
		//- Central obstruction, as a percentage of the Aperture.
		return DoubleValue("Obstruction")
	end function

	sub Obstruction(assigns value as double)
		if value<0.0 or value>=100.0 then return
		DoubleValue("Obstruction")=value
	end sub

	function FocalLength() as double
		//- Focal length in mm.
		return Aperture*FRatio
	end function

	function IsTelescope() as boolean
		//- True if this is a telescope, false if it is a binocular.
		return IntegerValue("ScopeType")=0
	end function

	sub IsTelescope(assigns value as boolean)
		if value then IntegerValue("ScopeType")=0 else IntegerValue("ScopeType")=1
	end sub

	function IsBinocular() as boolean
		//- False if this is a telescope, true if it is a binocular.
		return IntegerValue("ScopeType")=1
	end function

	sub IsBinocular(assigns value as boolean)
		if value then IntegerValue("ScopeType")=1 else IntegerValue("ScopeType")=0
	end sub

  const optics_Refractor = 1
  const optics_Newtonian = 2
  const optics_Cassegrain = 3
  const optics_Schmidt = 4
  const optics_SchmidtCassegrain = 5
  const optics_MaksutovCassegrain = 6
  const optics_MaksutovNewtonian = 7
  const optics_RitcheyChretien = 8
  const optics_DallKirkham = 9
  const optics_SchmidtNewtonian = 10
  
  function OpticsConfiguration() as integer
  	//- Optical configuration/type. Use optics_ constants.
  	return IntegerValue("OpticsType")
  end function
  
  sub OpticsConfiguration(assigns value as integer)
  	IntegerValue("OpticsType")=value
  end sub
  
  function Cleanliness() as integer
  	//- Cleanliness of the telescope optics. 0 = Unknown, 1 = Filthy ... 9 = Spotless.
  	return IntegerValue("Cleanliness")
  end function
  
  sub Cleanliness(assigns value as integer)
  	IntegerValue("Cleanliness")=value
  end sub
  
  function Mount() as string
  	//- Returns Computerised Mount type, as seen in the Resources editor,
  	//- or "" if no mount has been defined.
  	return StringValue("Mount")
  end function
  
	function Magnification() as double
		//- Binocular magnification. Only if IsBinocular=true (or IsTelescope=false).
		if IsTelescope then
			return 1.0
		else
			return DoubleValue("BinocularMag")
		end if
	end function

	sub Magnification(assigns value as double)
		if value<1.0 or value>1000.0 then return
		if IsBinocular then
			DoubleValue("BinocularMag")=value
		end if
	end sub
	
	function Magnification(e as EyepieceResource, optional v as OpticalAidResource = nil) as double
		//- Return the magnification of the telescope when paired with the specified eyepiece and (optional) optical aid.
		return APResource.Magnification(me,e,v)
	end function

	function ActualFoV(e as EyepieceResource, optional v as OpticalAidResource = nil) as double
		//- Return the actual field of view (in degrees) of the telescope when paired with the specified eyepiece and (optional) optical aid.
		return APResource.ActualFoV(me,e,v)
	end function
	
	function ActualFoV(im as ImagerResource, optional v as OpticalAidResource = nil, optional includeGuider as boolean = false) as Pair
		//- Return the actual field of view (in degrees) of the telescope when paired with the specified imager and (optional) optical aid. 
		//- The result is a Pair object, p, with p.Left = the actual field of view along the width of the imager's main sensor, and p.Right = the actual field of view along the height of the imager's main sensor.
		//- If includeGuider is TRUE, and the imager also has a guider sensor, then the field of view is expanded to encapsulate both the main and guider sensors.
		return APResource.ActualFoV(me,im,v,includeGuider)
	end function
	
	function MountOptionSelected(optionTitle as string) as boolean
		//- If the telescope resource has a computerised mount defined, then TRUE is returned if
		//-  the mount option does not have an associated checkbox in the first column, or if
		//-  it does have a checkbox and the checkbox is checked.
		//- If the telescope resource does not have a computerised mount defined, then FALSE is returned
		//- The optionTitle parameter must match the option description. The parameter can start and/or end
		//-  with '*', in which case the '*' will be taken as a wildcard character. e.g. '*IP Address' will
		//-  match the first option that ends with 'IP Address'.
		dim v as string
		return APC_MountOption(Name,optionTitle,v)
	end function
	
	function MountOptionValue(optionTitle as string) as string
		//- If the telescope resource has a computerised mount defined, then the value of the
		//-  associated option is returned. This is the value displayed in the second column.
		//- If the telescope resource does not have a computerised mount defined, then "" is returned
		//- The optionTitle parameter must match the option description. The parameter can start and/or end
		//-  with '*', in which case the '*' will be taken as a wildcard character. e.g. '*IP Address' will
		//-  match the first option that ends with 'IP Address'.
		dim v as string
		call APC_MountOption(Name,optionTitle,v)
		return v
	end function

	function FoV() as double
		//- Binocular field of view. Only if IsBinocular=true (or IsTelescope=false).
		if IsTelescope then
			return 50.0
		else
			return DoubleValue("BinocularFoV")
		end if
	end function

	sub FoV(assigns value as double)
		if value<=0.0 or value>100.0 then return
		if IsBinocular then
			DoubleValue("BinocularFoV")=value
		end if
	end sub

	function MagnitudeLimit() as double
		//- The specified magnitude limit of the telescope.
		if BooleanValue("DoOtherMagLimit") then
			return DoubleValue("OtherMagLimit")
		else
			return APC_MagLimit(Aperture)
		end if
	end function

	sub MagnitudeLimit(assigns value as double)
		if value<0.0 or value>100.0 then return
		BooleanValue("DoOtherMagLimit")=true
		DoubleValue("OtherMagLimit")=value
	end sub

	function FinderFlipHorizontal() as boolean
		//- The finder flips the image in the horizontal direction.
		return BooleanValue("FinderFlipHor")
	end function

	sub FinderFlipHorizontal(assigns value as boolean)
		BooleanValue("FinderFlipHor")=value
	end sub

	function FinderFlipVertical() as boolean
		//- The finder flips the image in the vertical direction.
		return BooleanValue("FinderFlipVer")
	end function

	sub FinderFlipVertical(assigns value as boolean)
		BooleanValue("FinderFlipVer")=value
	end sub

// Shared methods

	shared function nUserFieldDefinitions() as integer
		//- Return number of Telescope user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Resource+rsrc_Telescope)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Telescope user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Telescope,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Telescope user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Telescope,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Telescope,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Telescope,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Telescope,title,deleteValues)
  end function

	shared function Count(optional activetype as integer = APResource.rtype_Active) as integer
		//- Return count of existing Telescope resources
		//- If activetype=rtype_active (default) then the number of Active resources is returned. 
		//- If activetype=rtype_inactive then the number of inactive resources is returned.
		//- If activetype=rtype_both then the number of active and inactive resources is returned.
		return APResource.Count(rsrc_Telescope,activetype)
	end function

	shared function Get(n as integer, optional activetype as integer = APResource.rtype_Active) as TelescopeResource
    //- Return n-th existing Telescope resource
		//- If activetype=rtype_active (default) then the n-th Active resource is returned. 
		//- If activetype=rtype_inactive then the n-th Inactive resource is returned.
		//- If activetype=rtype_both then the n-th resource is returned, regardless of its Active status.
	  return TelescopeResource(APResource.Get(rsrc_Telescope,n,activetype))
	end function

	shared function Get(name as string) as TelescopeResource
	  //- Return Telescope resource with given name
	  //- Return nil if not found
		return TelescopeResource(APResource.Get(rsrc_Telescope,name))
	end function

	shared function Create(name as string) as TelescopeResource
	  //- Create Telescope resource with given name
	  //- If a resource already exists with that name, then return nil
	  return TelescopeResource(APResource.Create(rsrc_Telescope,name))
	end function

	shared function Delete(name as string) as boolean
	  //- Delete Telescope resource with given name
	  //- Return true if resource found and deleted
	  return APResource.Delete(rsrc_Telescope,name)
	end function

	shared function Default() as TelescopeResource
	  //- Return Default Telescope resource
	  //- Return nil if no Default resource
		return TelescopeResource(APResource.Default(rsrc_Telescope))
	end function

	shared function All(optional activetype as integer = APResource.rtype_Active) as TelescopeResource()
	  //- Return an array of all Telescope resources.
		//- If activetype=rtype_active (default) then all Active resources are returned. 
		//- If activetype=rtype_inactive then all Inactive resources are returned.
		//- If activetype=rtype_both then all resources are returned, regardless of their Active status.
	  dim t(-1) as TelescopeResource
	  for i as integer = 1 to Count(activetype)
	  	t.Append Get(i,activetype)
	  next
	  return t
	end function

	shared function Current(optional p as APPlan = nil) as TelescopeResource
	  //- Return current Telescope resource being used by plan p
	  //- If p is missing or nil, then the current plan document is assumed
	  dim ct as TelescopeResource = nil
		if p=nil then
			ct = Plan().CurrentTelescope
		else
			ct = p.CurrentTelescope
		end if
		if ct=nil then return nil else return Get(ct.Name)
	end function
	
	shared function MagnitudeLimit(aperture as double) as double
		//- Return theoretical magnitude limit for a given telescope aperture.
		//- Note: does not take into account magnification, etc.
		return 2.7+5.0*log(aperture)/log(10.0)
	end function

end class

//------------------------------------------------------------------------------------
class EyepieceResource
	// Documented 7/9/2012
	Inherits APResource
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. Eyepiece(n))

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer, all as boolean) // private
		super.Constructor(rsrc_Eyepiece,n,all)
	end sub

	function FocalLength() as double
		//- Focal length in mm.
		return DoubleValue("FocalLength")
	end function

	sub FocalLength(assigns value as double)
		if value<1.0 or value>200.0 then return
		DoubleValue("FocalLength")=value
	end sub

	function ApparentFoV() as double
		//- Apparent field of view in degrees.
		return DoubleValue("ApparentFoV")
	end function

	sub ApparentFoV(assigns value as double)
		if value<1.0 or value>180.0 then return
		DoubleValue("ApparentFoV")=value
	end sub

  public const barrel_125 = 0  // 1.25"
  public const barrel_2 = 1  // 2"
  public const barrel_125_2 = 2  // 1.25"/2"
  public const barrel_0965 = 3  // 0.965"
  
	function Barrel() as integer
		//: Chg 2.1 Now uses barrel_ constants rather than string
		//- Eyepiece barrel size. Use barrel_ constants.
		return IntegerValue("Barrel")
	end function

	sub Barrel(assigns value as integer)
			IntegerValue("Barrel")=value
	end sub
	
	function Magnification(t as TelescopeResource, optional v as OpticalAidResource = nil) as double
		//- Effective magnification of the eyepiece when paired with the specified Telescope resource (and optionally, an OpticalAid resource)
		return Magnification(t,me,v)
	end function

	function ActualFoV(t as TelescopeResource, optional v as OpticalAidResource = nil) as double
		//- Effective field of view in degrees of the eyepiece when paired with the specified Telescope resource (and optionally, an OpticalAid resource)
		return ActualFoV(t,me,v)
	end function

	function HasReticle() as boolean
		//- True if the eyepiece has a reticle.
		return IntegerValue("HasReticle")<>0
	end function

// Shared methods

	shared function nUserFieldDefinitions() as integer
		//- Return number of Eyepiece user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Resource+rsrc_Eyepiece)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Eyepiece user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Eyepiece,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Eyepiece user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Eyepiece,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Eyepiece,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Eyepiece,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Eyepiece,title,deleteValues)
  end function

	shared function Count(optional activetype as integer = APResource.rtype_Active) as integer
		//- Return count of existing Eyepiece resources
		//- If activetype=rtype_active (default) then the number of Active resources is returned. 
		//- If activetype=rtype_inactive then the number of inactive resources is returned.
		//- If activetype=rtype_both then the number of active and inactive resources is returned.
		return APResource.Count(rsrc_Eyepiece,activetype)
	end function

	shared function Get(n as integer, optional activetype as integer = APResource.rtype_Active) as EyepieceResource
    //- Return n-th existing Eyepiece resource
		//- If activetype=rtype_active (default) then the n-th Active resource is returned. 
		//- If activetype=rtype_inactive then the n-th Inactive resource is returned.
		//- If activetype=rtype_both then the n-th resource is returned, regardless of its Active status.
	  return EyepieceResource(APResource.Get(rsrc_Eyepiece,n,activetype))
	end function

	shared function Get(name as string) as EyepieceResource
	  //- Return Eyepiece resource with given name
	  //- Return nil if not found
		return EyepieceResource(APResource.Get(rsrc_Eyepiece,name))
	end function

	shared function Create(name as string) as EyepieceResource
	  //- Create Eyepiece resource with given name
	  //- If a resource already exists with that name, then return nil
	  return EyepieceResource(APResource.Create(rsrc_Eyepiece,name))
	end function

	shared function Delete(name as string) as boolean
	  //- Delete Eyepiece resource with given name
	  //- Return true if resource found and deleted
	  return APResource.Delete(rsrc_Eyepiece,name)
	end function

	shared function Default() as EyepieceResource
	  //- Return Default Eyepiece resource
	  //- Return nil if no Default resource
		return EyepieceResource(APResource.Default(rsrc_Eyepiece))
	end function

	shared function All(optional activetype as integer = APResource.rtype_Active) as EyepieceResource()
	  //- Return an array of all Eyepiece resources.
		//- If activetype=rtype_active (default) then all Active resources are returned. 
		//- If activetype=rtype_inactive then all Inactive resources are returned.
		//- If activetype=rtype_both then all resources are returned, regardless of their Active status.
	  dim t(-1) as EyepieceResource
	  for i as integer = 1 to Count(activetype)
	  	t.Append Get(i,activetype)
	  next
	  return t
	end function

end class

//------------------------------------------------------------------------------------
class OpticalAidResource
	// Documented 7/9/2012
	Inherits APResource
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. OpticalAid(n))

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer, all as boolean) // private
		super.Constructor(rsrc_OpticalAid,n,all)
	end sub

	function Magnification() as double
		//- Magnification change caused by the optical aid (default = 1, i.e. no magnification change)
		return DoubleValue("Magnification")
	end function

	sub Magnification(assigns value as double)
		if value<=0.0 or value>1000.0 then return
		DoubleValue("Magnification")=value
	end sub

	function IsBinocular() as boolean
		//- True if the optical aid is a binocular device.
		return IntegerValue("Binocular")=1
	end function

	sub IsBinocular(assigns value as boolean)
		if value then IntegerValue("Binocular")=1 else IntegerValue("Binocular")=0
	end sub

  function FocalLength() as double
  	//- Focal length change caused by the optical aid (default = 0, i.e. no focal length change)
		return DoubleValue("FocalLength")
	end function

	sub FocalLength(assigns value as double)
		if value<0.0 or value>10000.0 then return
		DoubleValue("FocalLength")=value
	end sub

	function InvertsHorizontally() as boolean
		//- True if the optical aid inverts the view horizontally.
		return BitwiseAND(IntegerValue("Orientation"),3)=3
	end function

	sub InvertsHorizontally(assigns value as boolean)
		if value then
			IntegerValue("Orientation")=BitWiseOR(IntegerValue("Orientation"),3)
		else
			if BitwiseAND(IntegerValue("Orientation"),5)=5 then
				IntegerValue("Orientation")=7
			else
				IntegerValue("Orientation")=0
			end if
		end if
	end sub

	function InvertsVertically() as boolean
		//- True if the optical aid inverts the view vertically.
		return BitwiseAND(IntegerValue("Orientation"),5)=5
	end function

	sub InvertsVertically(assigns value as boolean)
		if value then
			IntegerValue("Orientation")=BitWiseOR(IntegerValue("Orientation"),5)
		else
			if BitwiseAND(IntegerValue("Orientation"),3)=3 then
				IntegerValue("Orientation")=7
			else
				IntegerValue("Orientation")=0
			end if
		end if
	end sub

// Shared methods

	shared function nUserFieldDefinitions() as integer
		//- Return number of Optical Aid user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Resource+rsrc_OpticalAid)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Optical Aid user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_OpticalAid,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Optical Aid user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_OpticalAid,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_OpticalAid,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_OpticalAid,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_OpticalAid,title,deleteValues)
  end function

	shared function Count(optional activetype as integer = APResource.rtype_Active) as integer
		//- Return count of existing OpticalAid resources
		//- If activetype=rtype_active (default) then the number of Active resources is returned. 
		//- If activetype=rtype_inactive then the number of inactive resources is returned.
		//- If activetype=rtype_both then the number of active and inactive resources is returned.
		return APResource.Count(rsrc_OpticalAid,activetype)
	end function

	shared function Get(n as integer, optional activetype as integer = APResource.rtype_Active) as OpticalAidResource
    //- Return n-th existing OpticalAid resource
		//- If activetype=rtype_active (default) then the n-th Active resource is returned. 
		//- If activetype=rtype_inactive then the n-th Inactive resource is returned.
		//- If activetype=rtype_both then the n-th resource is returned, regardless of its Active status.
	  return OpticalAidResource(APResource.Get(rsrc_OpticalAid,n,activetype))
	end function

	shared function Get(name as string) as OpticalAidResource
	  //- Return OpticalAid resource with given name
	  //- Return nil if not found
		return OpticalAidResource(APResource.Get(rsrc_OpticalAid,name))
	end function

	shared function Create(name as string) as OpticalAidResource
	  //- Create OpticalAid resource with given name
	  //- If a resource already exists with that name, then return nil
	  return OpticalAidResource(APResource.Create(rsrc_OpticalAid,name))
	end function

	shared function Delete(name as string) as boolean
	  //- Delete OpticalAid resource with given name
	  //- Return true if resource found and deleted
	  return APResource.Delete(rsrc_OpticalAid,name)
	end function

	shared function Default() as OpticalAidResource
	  //- Return Default OpticalAid resource
	  //- Return nil if no Default resource
		return OpticalAidResource(APResource.Default(rsrc_OpticalAid))
	end function

	shared function All(optional activetype as integer = APResource.rtype_Active) as OpticalAidResource()
	  //- Return an array of all OpticalAid resources.
		//- If activetype=rtype_active (default) then all Active resources are returned. 
		//- If activetype=rtype_inactive then all Inactive resources are returned.
		//- If activetype=rtype_both then all resources are returned, regardless of their Active status.
	  dim t(-1) as OpticalAidResource
	  for i as integer = 1 to Count(activetype)
	  	t.Append Get(i,activetype)
	  next
	  return t
	end function

end class

//------------------------------------------------------------------------------------
class FilterResource
	// Documented 7/9/2012
	Inherits APResource
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. Filter(n))

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer, all as boolean) // private
		super.Constructor(rsrc_Filter,n,all)
	end sub

	function MinimumExitPupil() as double
		//- Minimum exit pupil requirement in mm.
		return DoubleValue("MinimumExitPupil")
	end function

	sub MinimumExitPupil(assigns value as double)
		if value<=0.0 or value>100.0 then return
		DoubleValue("MinimumExitPupil")=value
	end sub

  function nBandpass() as integer
  	//- Returns number of Bandpass entries
  	return IntegerValue("nBandpass")
  end function
  
	function Bandpass(n as integer) as Pair
		//- Returns bandpass entry n, where n = 1, 2, ... nBandpass
		//- Returned as a Pair object with Left = from frequency and Right = to frequency
		return new Pair(DoubleValue("BandpassFrom"+str(n-1)),DoubleValue("BandpassTo"+str(n-1)))
	end function

	sub Bandpass(n as integer, assigns value as Pair)
		//- Replace bandpass entry n,  where n = 1, 2, ... nBandpass
		//- Accepts a Pair object with Left = from frequency and Right = to frequency
		//- e.g. Bandpass(n) = new Pair(345.0,405.0)
		if value=nil then return
		DoubleValue("BandpassFrom"+str(n-1))=value.Left.DoubleValue
		DoubleValue("BandpassTo"+str(n-1))=value.Right.DoubleValue
	end sub

// Shared methods

	shared function nUserFieldDefinitions() as integer
		//- Return number of Filter user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Resource+rsrc_Filter)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Filter user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Filter,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Filter user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Filter,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Filter,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Filter,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Filter,title,deleteValues)
  end function

	shared function Count(optional activetype as integer = APResource.rtype_Active) as integer
		//- Return count of existing Filter resources
		//- If activetype=rtype_active (default) then the number of Active resources is returned. 
		//- If activetype=rtype_inactive then the number of inactive resources is returned.
		//- If activetype=rtype_both then the number of active and inactive resources is returned.
		return APResource.Count(rsrc_Filter,activetype)
	end function

	shared function Get(n as integer, optional activetype as integer = APResource.rtype_Active) as FilterResource
    //- Return n-th existing Filter resource
		//- If activetype=rtype_active (default) then the n-th Active resource is returned. 
		//- If activetype=rtype_inactive then the n-th Inactive resource is returned.
		//- If activetype=rtype_both then the n-th resource is returned, regardless of its Active status.
	  return FilterResource(APResource.Get(rsrc_Filter,n,activetype))
	end function

	shared function Get(name as string) as FilterResource
	  //- Return Filter resource with given name
	  //- Return nil if not found
		return FilterResource(APResource.Get(rsrc_Filter,name))
	end function

	shared function Create(name as string) as FilterResource
	  //- Create Filter resource with given name
	  //- If a resource already exists with that name, then return nil
	  return FilterResource(APResource.Create(rsrc_Filter,name))
	end function

	shared function Delete(name as string) as boolean
	  //- Delete Filter resource with given name
	  //- Return true if resource found and deleted
	  return APResource.Delete(rsrc_Filter,name)
	end function

	shared function Default() as FilterResource
	  //- Return Default Filter resource
	  //- Return nil if no Default resource
		return FilterResource(APResource.Default(rsrc_Filter))
	end function

	shared function All(optional activetype as integer = APResource.rtype_Active) as FilterResource()
	  //- Return an array of all Filter resources.
		//- If activetype=rtype_active (default) then all Active resources are returned. 
		//- If activetype=rtype_inactive then all Inactive resources are returned.
		//- If activetype=rtype_both then all resources are returned, regardless of their Active status.
	  dim t(-1) as FilterResource
	  for i as integer = 1 to Count(activetype)
	  	t.Append Get(i,activetype)
	  next
	  return t
	end function

end class

//------------------------------------------------------------------------------------
class ObserverResource
	// Documented 7/9/2012
	Inherits APResource
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. Observer(n))

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer, all as boolean) // private
		super.Constructor(rsrc_Observer,n,all)
	end sub

	function ObserverName() as String
		//- Full name of observer.
		return StringValue("ObserverName")
	end function

	sub ObserverName(assigns value as String)
		StringValue("ObserverName")=trim(value)
	end sub

	function Age() as integer
		//- Age of observer in years. Note: setting this might affect the YearOfBirth property value.
		return IntegerValue("Age")
	end function

	sub Age(assigns value as integer)
		if value<10 or value>90 then return
		IntegerValue("Age")=value
	end sub

	function YearOfBirth() as integer
		//- Year of birth of observer. Note: setting this might affect the Age property value.
		return IntegerValue("YearOfBirth")
	end function

	sub YearOfBirth(assigns value as integer)
		if value<1900 or value>2012 then return
		IntegerValue("YearOfBirth")=value
	end sub

	function EMail() as String
		//- Observer's e-mail address.
		return StringValue("EMail")
	end function

	sub EMail(assigns value as String)
		StringValue("EMail")=value
	end sub

	function Experience() as integer
		//- Observer's experience, from 1 (no experience) to 9 (expert).
		return IntegerValue("Experience")
	end function

	sub Experience(assigns value as integer)
		if value<1 or value>9 then return
		IntegerValue("Experience")=value
	end sub

	function Latitude() as double
		//- Observer's home latitude (-90° to +90°).
		return DoubleValue("Latitude")
	end function

	sub Latitude(assigns value as double)
		if value<=-90.0 or value>=90.0 then return
		DoubleValue("Latitude")=value
	end sub

	function Longitude() as double
		//- Observer's home longitude (-180° (west) to +180° (east)).
		return DoubleValue("Longitude")
	end function

	sub Longitude(assigns value as double)
		if value<-180.0 or value>180.0 then return
		DoubleValue("Longitude")=value
	end sub

	const vision_20_40 = 1   // 20/40 vision
	const vision_20_20 = 2   // 20/20 vision
	const vision_20_10 = 3   // 20/10 vision

	function Vision() as integer
		//- Observer's vision. Use vision_ constants.
		return IntegerValue("Vision")
	end function

	sub Vision(assigns value as integer)
		if value<1 or value>3 then return
		IntegerValue("Vision")=value
	end sub

// Shared methods

	shared function nUserFieldDefinitions() as integer
		//- Return number of Observer user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Resource+rsrc_Observer)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Observer user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Observer,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Observer user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Observer,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Observer,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Observer,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Observer,title,deleteValues)
  end function

	shared function Count(optional activetype as integer = APResource.rtype_Active) as integer
		//- Return count of existing Observer resources
		//- If activetype=rtype_active (default) then the number of Active resources is returned. 
		//- If activetype=rtype_inactive then the number of inactive resources is returned.
		//- If activetype=rtype_both then the number of active and inactive resources is returned.
		return APResource.Count(rsrc_Observer,activetype)
	end function

	shared function Get(n as integer, optional activetype as integer = APResource.rtype_Active) as ObserverResource
    //- Return n-th existing Observer resource
		//- If activetype=rtype_active (default) then the n-th Active resource is returned. 
		//- If activetype=rtype_inactive then the n-th Inactive resource is returned.
		//- If activetype=rtype_both then the n-th resource is returned, regardless of its Active status.
	  return ObserverResource(APResource.Get(rsrc_Observer,n,activetype))
	end function

	shared function Get(name as string) as ObserverResource
	  //- Return Observer resource with given name
	  //- Return nil if not found
		return ObserverResource(APResource.Get(rsrc_Observer,name))
	end function

	shared function Create(name as string) as ObserverResource
	  //- Create Observer resource with given name
	  //- If a resource already exists with that name, then return nil
	  return ObserverResource(APResource.Create(rsrc_Observer,name))
	end function

	shared function Delete(name as string) as boolean
	  //- Delete Observer resource with given name
	  //- Return true if resource found and deleted
	  return APResource.Delete(rsrc_Observer,name)
	end function

	shared function Default() as ObserverResource
	  //- Return Default Observer resource
	  //- Return nil if no Default resource
		return ObserverResource(APResource.Default(rsrc_Observer))
	end function

	shared function All(optional activetype as integer = APResource.rtype_Active) as ObserverResource()
	  //- Return an array of all Observer resources.
		//- If activetype=rtype_active (default) then all Active resources are returned. 
		//- If activetype=rtype_inactive then all Inactive resources are returned.
		//- If activetype=rtype_both then all resources are returned, regardless of their Active status.
	  dim t(-1) as ObserverResource
	  for i as integer = 1 to Count(activetype)
	  	t.Append Get(i,activetype)
	  next
	  return t
	end function

end class

//------------------------------------------------------------------------------------
class ImagerResource
	// Documented 7/9/2012
	Inherits APResource
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. Imager(n))

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(n as integer, all as boolean) // private
		super.Constructor(rsrc_Imager,n,all)
	end sub

	function Sensor() as String
		//- Main sensor name.
		return StringValue("Sensor")
	end function

	sub Sensor(assigns value as String)
		StringValue("Sensor")=trim(value)
	end sub

	function PixelWidth() as double
		//- Main sensor pixel width in µm (microns).
		return DoubleValue("PixelWidth")
	end function

	sub PixelWidth(assigns value as double)
		if value<0.1 or value>1000.0 then return
		DoubleValue("PixelWidth")=value
	end sub

	function PixelHeight() as double
		//- Main sensor pixel height in µm (microns).
		return DoubleValue("PixelHeight")
	end function

	sub PixelHeight(assigns value as double)
		if value<0.1 or value>1000.0 then return
		DoubleValue("PixelHeight")=value
	end sub

	function PixelsX() as integer
		//- Number of pixels across the width (x-direction) of the main sensor.
		return IntegerValue("PixelsX")
	end function

	sub PixelsX(assigns value as integer)
		if value<10 or value>50000 then return
		IntegerValue("PixelsX")=value
	end sub

	function PixelsY() as integer
		//- Number of pixels across the height (y-direction) of the main sensor.
		return IntegerValue("PixelsY")
	end function

	sub PixelsY(assigns value as integer)
		if value<10 or value>50000 then return
		IntegerValue("PixelsY")=value
	end sub
	
	function SensorWidth() as double
		//- Main sensor width in mm.
		return PixelsX*PixelWidth*0.001
	end function

	function SensorHeight() as double
		//- Main sensor height in mm.
		return PixelsY*PixelHeight*0.001
	end function

	function HasGuider() as boolean
		//- True if imager includes a separate guide sensor.
		return BooleanValue("HasGuider")
	end function

	function Guider() as String
		//- Guide sensor name.
		return StringValue("Guider")
	end function

	sub Guider(assigns value as String)
		StringValue("Guider")=trim(value)
	end sub

	function GuiderPixelWidth() as double
		//- Guide sensor pixel width in µm (microns).
		return DoubleValue("GuiderPixelWidth")
	end function

	sub GuiderPixelWidth(assigns value as double)
		if value<0.1 or value>1000.0 then return
		DoubleValue("GuiderPixelWidth")=value
	end sub

	function GuiderPixelHeight() as double
		//- Guide sensor pixel height in µm (microns).
		return DoubleValue("GuiderPixelHeight")
	end function

	sub GuiderPixelHeight(assigns value as double)
		if value<0.1 or value>1000.0 then return
		DoubleValue("GuiderPixelHeight")=value
	end sub

	function GuiderPixelsX() as integer
		//- Number of pixels across the width (x-direction) of the guide sensor.
		return IntegerValue("GuiderPixelsX")
	end function

	sub GuiderPixelsX(assigns value as integer)
		if value<10 or value>50000 then return
		IntegerValue("GuiderPixelsX")=value
	end sub

	function GuiderPixelsY() as integer
		//- Number of pixels across the height (y-direction) of the guide sensor.
		return IntegerValue("GuiderPixelsY")
	end function

	sub GuiderPixelsY(assigns value as integer)
		if value<10 or value>50000 then return
		IntegerValue("GuiderPixelsY")=value
	end sub

	function GuiderWidth() as double
		//- Guide sensor width in mm.
		return GuiderPixelsX*GuiderPixelWidth*0.001
	end function

	function GuiderHeight() as double
		//- Guide sensor height in mm.
		return GuiderPixelsY*GuiderPixelHeight*0.001
	end function

	function GuiderOffsetX() as double
		//- X-offset, in mm, of the centre of the guide sensor with respect to the centre of the main sensor (typically 0).
		return DoubleValue("GuiderOffsetX")
	end function

	sub GuiderOffsetX(assigns value as double)
		
		if value<-1000 or value>1000.0 then return
		DoubleValue("GuiderOffsetX")=value
	end sub

	function GuiderOffsetY() as double
		//- Y-offset, in mm, of the centre of the guide sensor with respect to the centre of the main sensor (typically > 0).
		return DoubleValue("GuiderOffsetY")
	end function

	sub GuiderOffsetY(assigns value as double)
		if abs(value)>1000.0 then return
		DoubleValue("GuiderOffsetY")=abs(value)
	end sub


// Shared methods

	shared function nUserFieldDefinitions() as integer
		//- Return number of Imager user-field definitions.
		return APUserField.nDefinedUserFields(-1,APUserField.ufnit_Resource+rsrc_Imager)
	end function

	shared function UserFieldDefinition(n as integer) as APUserField
		//- Return the n-th Imager user-field definition, n = 1, ..., nUserDefinitions.
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Imager,n)
	end function

	shared function UserFieldDefinition(title as string) as APUserField
		//- Return the Imager user-field definition with the given title (or nil if it does not exist).
		return APUserField.DefinedUserField(-1,APUserField.ufnit_Resource+rsrc_Imager,title)
	end function

  shared function NewUserFieldDefinition(uf as APUserField) as boolean
  	//- Create a new user-defined field definition based on the given user field definition. Return TRUE if successful.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Imager,uf)
  end function
  
  shared function NewUserFieldDefinition(title as string, ufType as integer, optional rangeFrom as double = -999.0, optional rangeTo as double = 999.0, optional units as string = "", optional decimals as integer = -6, optional scriptName as string = "", optional scriptParameter as string = "", optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false) as boolean
  	//- Create a new user-defined field definition with the given title, uftype, etc. Return TRUE if successful.
  	//- ufType takes one of the APUserField.uftype_ constants.
  	return APUserField.NewUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Imager,title,ufType,rangeFrom,rangeTo,units,decimals,scriptName,scriptParameter,bold,italic,underline)
  end function
  
  shared function DeleteUserFieldDefinition(title as string, optional deleteValues as boolean = true) as boolean
  	//- Delete an existing user-defined field definition. Return TRUE if successful.
  	//- If deleteValues is TRUE (default) then any corresponding user-defined field values will
  	//- also be deleted. If deleteValues is FALSE then any corresponding values will be retained,
  	//- but will be "orphaned".
  	return APUserField.DeleteUserFieldDefinition(-1,APUserField.ufnit_Resource+rsrc_Imager,title,deleteValues)
  end function


	shared function Count(optional activetype as integer = APResource.rtype_Active) as integer
		//- Return count of existing Imager resources
		//- If activetype=rtype_active (default) then the number of Active resources is returned. 
		//- If activetype=rtype_inactive then the number of inactive resources is returned.
		//- If activetype=rtype_both then the number of active and inactive resources is returned.
		return APResource.Count(rsrc_Imager,activetype)
	end function

	shared function Get(n as integer, optional activetype as integer = APResource.rtype_Active) as ImagerResource
    //- Return n-th existing Imager resource
		//- If activetype=rtype_active (default) then the n-th Active resource is returned. 
		//- If activetype=rtype_inactive then the n-th Inactive resource is returned.
		//- If activetype=rtype_both then the n-th resource is returned, regardless of its Active status.
	  return ImagerResource(APResource.Get(rsrc_Imager,n,activetype))
	end function

	shared function Get(name as string) as ImagerResource
	  //- Return Imager resource with given name
	  //- Return nil if not found
		return ImagerResource(APResource.Get(rsrc_Imager,name))
	end function

	shared function Create(name as string) as ImagerResource
	  //- Create Imager resource with given name
	  //- If a resource already exists with that name, then return nil
	  return ImagerResource(APResource.Create(rsrc_Imager,name))
	end function

	shared function Delete(name as string) as boolean
	  //- Delete Imager resource with given name
	  //- Return true if resource found and deleted
	  return APResource.Delete(rsrc_Imager,name)
	end function

	shared function Default() as ImagerResource
	  //- Return Default Imager resource
	  //- Return nil if no Default resource
		return ImagerResource(APResource.Default(rsrc_Imager))
	end function

	shared function All(optional activetype as integer = APResource.rtype_Active) as ImagerResource()
	  //- Return an array of all Imager resources.
		//- If activetype=rtype_active (default) then all Active resources are returned. 
		//- If activetype=rtype_inactive then all Inactive resources are returned.
		//- If activetype=rtype_both then all resources are returned, regardless of their Active status.
	  dim t(-1) as ImagerResource
	  for i as integer = 1 to Count(activetype)
	  	t.Append Get(i,activetype)
	  next
	  return t
	end function

	function ActualFoV(t as TelescopeResource, optional v as OpticalAidResource = nil, optional includeGuider as boolean = false) as Pair
		//- Returns actual field of view of the imager, in degrees, when it is paired with the specified Telescope and (optional) Optical Aid. 
		//- The result is a Pair object, p, where p.Left is the actual field of view of the width of the Imager's main sensor, and p.Right is 
		//- the actual field of view of the height of the Imager's main sensor.
		//- If includeGuider is TRUE, and the imager also has a guider sensor, then the field of view is expanded to encapsulate both the main and guider sensors.
		return ActualFoV(t,me,v,includeGuider)
	end function
	
	function GuiderCenter(t as TelescopeResource, optional a as OpticalAidResource = nil) as Pair
		//- Return the X/Y offset (in degrees) of the centre of the guider sensor, w.r.t. the centre of the main sensor.
		//- The result is a Pair object, p, with p.Left = the X offset, and p.Right = the Y offset.
		dim p as new Pair(0.0,0.0)
		if t=nil or not t.IsTelescope or not me.HasGuider then return p
		dim fl as double 
		if a=nil then
			fl = t.FocalLength
		else
			fl = (t.FocalLength+a.FocalLength)*a.Magnification
		end if
		p.Left=me.GuiderOffsetX/fl*180.0/pi
		p.Right=me.GuiderOffsetY/fl*180.0/pi
		return p
	end function
	
	function GuiderSize(t as TelescopeResource, optional a as OpticalAidResource = nil) as Pair
		//- Return the width and height (in degrees) of the guider sensor.
		//- The result is a Pair object, p, with p.Left = the width, and p.Right = the height.
		dim p as new Pair(0.0,0.0)
		if t=nil or not t.IsTelescope or not me.HasGuider then return p
		dim fl as double 
		if a=nil then
			fl = t.FocalLength
		else
			fl = (t.FocalLength+a.FocalLength)*a.Magnification
		end if
		p.Left=me.GuiderWidth/fl*180.0/pi
		p.Right=me.GuiderHeight/fl*180.0/pi
		return p
	end function
	


end class

//------------------------------------------------------------------------------------
module APResources // Deprecate

	//................................................

	function nSites() as integer
		Deprecate("nSites","SiteResource.Count")
		return SiteResource.Count
	end function

	function Site(n as integer) as SiteResource
		Deprecate("Site(n)","SiteResource.Get(n)")
		return SiteResource.Get(n)
	end function

	function Site(name as string) as SiteResource
		Deprecate("Site(name)","SiteResource.Get(name)")
		return SiteResource.Get(name)
	end function

	function NewSite(name as string) as SiteResource
		Deprecate("NewSite(name)","SiteResource.Create(name)")
		return SiteResource.Create(name)
	end function

	function DeleteSite(name as string) as boolean
		Deprecate("DeleteSite(name)","SiteResource.Delete(name)")
		return SiteResource.Delete(name)
	end function

	function CurrentSite(optional p as APPlan = nil) as SiteResource
		Deprecate("CurrentSite","SiteResource.Current")
		return SiteResource.Current(p)
	end function

	function DefaultSite() as SiteResource
		Deprecate("DefaultSite","SiteResource.Default")
		return SiteResource.Default
	end function

	function Sites() as SiteResource()
		Deprecate("Sites","SiteResource.All")
		return SiteResource.All
	end function

	//................................................

	function nTelescopes() as integer
		Deprecate("nTelescopes","TelescopeResource.Count")
		return TelescopeResource.Count
	end function

	function Telescope(n as integer) as TelescopeResource
		Deprecate("Telescope(n)","TelescopeResource.Get(n)")
		return TelescopeResource.Get(n)
	end function

	function Telescope(name as string) as TelescopeResource
		Deprecate("Telescope(name)","TelescopeResource.Get(name)")
		return TelescopeResource.Get(name)
	end function

	function NewTelescope(name as string) as TelescopeResource
		Deprecate("NewTelescope(name)","TelescopeResource.Create(name)")
		return TelescopeResource.Create(name)
	end function

	function DeleteTelescope(name as string) as boolean
		Deprecate("DeleteTelescope(name)","TelescopeResource.Delete(name)")
		return TelescopeResource.Delete(name)
	end function

	function CurrentTelescope(optional p as APPlan = nil) as TelescopeResource
		Deprecate("CurrentTelescope","TelescopeResource.Current")
		return TelescopeResource.Current(p)
	end function

	function DefaultTelescope() as TelescopeResource
		Deprecate("DefaultTelescope","TelescopeResource.Default")
		return TelescopeResource.Default
	end function

	function Telescopes() as TelescopeResource()
		Deprecate("Telescopes","TelescopeResource.All")
		return TelescopeResource.All
	end function

	//................................................

	function nEyepieces() as integer
		Deprecate("nEyepieces","EyepieceResource.Count")
		return EyepieceResource.Count
	end function

	function Eyepiece(n as integer) as EyepieceResource
		Deprecate("Eyepiece(n)","EyepieceResource.Get(n)")
		return EyepieceResource.Get(n)
	end function

	function Eyepiece(name as string) as EyepieceResource
		Deprecate("Eyepiece(name)","EyepieceResource.Get(name)")
		return EyepieceResource.Get(name)
	end function

	function NewEyepiece(name as string) as EyepieceResource
		Deprecate("NewEyepiece(name)","EyepieceResource.Create(name)")
		return EyepieceResource.Create(name)
	end function

	function DeleteEyepiece(name as string) as boolean
		Deprecate("DeleteEyepiece(name)","EyepieceResource.Delete(name)")
		return EyepieceResource.Delete(name)
	end function

	function DefaultEyepiece() as EyepieceResource
		Deprecate("DefaultEyepiece","EyepieceResource.Default")
		return EyepieceResource.Default
	end function

	function Eyepieces() as EyepieceResource()
		Deprecate("Eyepieces","EyepieceResource.All")
		return EyepieceResource.All
	end function

	//................................................

	function nVisualAids() as integer
		Deprecate("nVisualAids","OpticalAidResource.Count")
		return OpticalAidResource.Count
	end function

	function VisualAid(n as integer) as OpticalAidResource
		Deprecate("VisualAid(n)","OpticalAidResource.Get(n)")
		return OpticalAidResource.Get(n)
	end function

	function VisualAid(name as string) as OpticalAidResource
		Deprecate("VisualAid(name)","OpticalAidResource.Get(name)")
		return OpticalAidResource.Get(name)
	end function

	function NewVisualAid(name as string) as OpticalAidResource
		Deprecate("NewVisualAid(name)","OpticalAidResource.Create(name)")
		return OpticalAidResource.Create(name)
	end function

	function DeleteVisualAid(name as string) as boolean
		Deprecate("DeleteVisualAid(name)","OpticalAidResource.Delete(name)")
		return OpticalAidResource.Delete(name)
	end function

	function DefaultVisualAid() as OpticalAidResource
		Deprecate("DefaultVisualAid","OpticalAidResource.Default")
		return OpticalAidResource.Default
	end function

	function VisualAids() as OpticalAidResource()
		Deprecate("VisualAids","OpticalAidResource.All")
		return OpticalAidResource.All
	end function

	//................................................

	function nFilters() as integer
		Deprecate("nFilters","FilterResource.Count")
		return FilterResource.Count
	end function

	function Filter(n as integer) as FilterResource
		Deprecate("Filter(n)","FilterResource.Get(n)")
		return FilterResource.Get(n)
	end function

	function Filter(name as string) as FilterResource
		Deprecate("Filter(name)","FilterResource.Get(name)")
		return FilterResource.Get(name)
	end function

	function NewFilter(name as string) as FilterResource
		Deprecate("NewFilter(name)","FilterResource.Create(name)")
		return FilterResource.Create(name)
	end function

	function DeleteFilter(name as string) as boolean
		Deprecate("DeleteFilter(name)","FilterResource.Delete(name)")
		return FilterResource.Delete(name)
	end function

	function DefaultFilter() as FilterResource
		Deprecate("DefaultFilter","FilterResource.Default")
		return FilterResource.Default
	end function

	function Filters() as FilterResource()
		Deprecate("Filters","FilterResource.All")
		return FilterResource.All
	end function

	//................................................

	function nObservers() as integer
		Deprecate("nObservers","ObserverResource.Count")
		return ObserverResource.Count
	end function

	function Observer(n as integer) as ObserverResource
		Deprecate("Observer(n)","ObserverResource.Get(n)")
		return ObserverResource.Get(n)
	end function

	function Observer(name as string) as ObserverResource
		Deprecate("Observer(name)","ObserverResource.Get(name)")
		return ObserverResource.Get(name)
	end function

	function NewObserver(name as string) as ObserverResource
		Deprecate("NewObserver(name)","ObserverResource.Create(name)")
		return ObserverResource.Create(name)
	end function

	function DeleteObserver(name as string) as boolean
		Deprecate("DeleteObserver(name)","ObserverResource.Delete(name)")
		return ObserverResource.Delete(name)
	end function

	function DefaultObserver() as ObserverResource
		Deprecate("DefaultObserver","ObserverResource.Default")
		return ObserverResource.Default
	end function

	function Observers() as ObserverResource()
		Deprecate("Observers","ObserverResource.All")
		return ObserverResource.All
	end function

	//................................................

	function nImagers() as integer
		Deprecate("nImagers","ImagerResource.Count")
		return ImagerResource.Count
	end function

	function Imager(n as integer) as ImagerResource
		Deprecate("Imager(n)","ImagerResource.Get(n)")
		return ImagerResource.Get(n)
	end function

	function Imager(name as string) as ImagerResource
		Deprecate("Imager(name)","ImagerResource.Get(name)")
		return ImagerResource.Get(name)
	end function

	function NewImager(name as string) as ImagerResource
		Deprecate("NewImager(name)","ImagerResource.Create(name)")
		return ImagerResource.Create(name)
	end function

	function DeleteImager(name as string) as boolean
		Deprecate("DeleteImager(name)","ImagerResource.Delete(name)")
		return ImagerResource.Delete(name)
	end function

	function DefaultImager() as ImagerResource
		Deprecate("DefaultImager","ImagerResource.Default")
		return ImagerResource.Default
	end function

	function Imagers() as ImagerResource()
		Deprecate("Imagers","ImagerResource.All")
		return ImagerResource.All
	end function

	//................................................

	function Magnification(t as TelescopeResource, e as EyepieceResource, optional a as OpticalAidResource = nil) as double
		Deprecate("Magnification(t,e,a)","APResource.Magnification(t,e,a)")
		return APResource.Magnification(t,e,a)
	end function

	function ActualFoV(t as TelescopeResource, e as EyepieceResource, optional a as OpticalAidResource = nil) as double
		Deprecate("ActualFoV(t,e,a)","APResource.ActualFoV(t,e,a)")
		return APResource.ActualFoV(t,e,a)
	end function

end module

//------------------------------------------------------------------------------------
class TCPSocket
	// Documented 7/7/2012
	//- Create and use a TCP/IP socket to send/receive data via your LAN or WAN (Internet).

	private nSocket as integer

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(nIP as string, nPort as integer)
		//- Create a new TCP/IP connection for the given IP number and port number
		nSocket=APC_TCPCreate(nIP,nPort)
	end sub

	sub Destructor() // private
		if IsConnected() then Disconnect()
		APC_TCPDestroy(nSocket)
	end sub

	sub Connect()
		//- Connect to the TCP/IP port
		APC_TCPConnect(nSocket)
	end sub

	function IsConnected() as boolean
		//- True if Connect was successful
		return APC_TCPIsConnected(nSocket)
	end function

	sub Disconnect()
		//- Disconnect the TCP/IP port
		APC_TCPDisconnect(nSocket)
	end sub

	function Read(optional bytes as integer = 0) as string
		//- Read and return the specified number of bytes from the port. If bytes=0 then read all bytes in the buffer.
		return APC_TCPRead(nSocket,bytes)
	end function

	sub Write(s as string)
		//- Write the specified string to the TCP/IP port
		APC_TCPWrite(nSocket,s)
	end sub
end class

//------------------------------------------------------------------------------------
class APSerialPort
	// Documented 7/7/2012
	//- Access the serial ports on your computer
	//- Note: Do not construct new instances of this object.
	//- Use the shared methods of the class to retrieve
	//- instances (i.e. APSerialPort.SerialPort(n))
	
	implements NamedObject
	
	private nSP as integer
	
	const baud_300 = 0
	const baud_600 = 1
	const baud_1200 = 2
	const baud_1800 = 3
	const baud_2400 = 4
	const baud_3600 = 5
	const baud_4800 = 6
	const baud_7200 = 7
	const baud_9600 = 8
	const baud_14400 = 9
	const baud_19200 = 10
	const baud_28800 = 11
	const baud_38400 = 12
	const baud_57600 = 13
	const baud_115200 = 14
	const baud_230400 = 15
	
	const databits_5 = 0
	const databits_6 = 1
	const databits_7 = 2
	const databits_8 = 3
	
	const stopbits_1 = 0
	const stopbits_1_5 = 1  // 1.5 stop bits
	const stopbits_2 = 2
	
	const parity_None = 0
	const parity_Odd = 1
	const parity_Even = 2
	
	const flowcontrol_None = 0
	
	const flowcontrol_XON = 1
	const flowcontrol_CTS = 2
	const flowcontrol_DTR = 4
	
	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(i as integer) // private
		nSP=i
		BitRate=baud_9600
		DataBits=databits_8
		Parity=parity_None
		StopBits=stopbits_1
		FlowControl=flowcontrol_None
	end sub

	sub Destructor() // private
		APC_SP_Close(nSP)
	end sub
	
	sub Close()
		//- Close the serial port.
		APC_SP_Close(nSP)
	end sub
	
	sub Open()
		//- Open the serial port for communication.
		APC_SP_Open(nSP)
	end sub
	
	function Name() as string
		//- Return the name of the serial port (e.g. COM2, Keyspan1, etc.)
		Return APC_SP_Name(nSP)
	end function

	function ObjectName() as string // private
		Return Name
	end function

	function RatedSpeed() as integer
		//- The rated speed of the serial port (baud).
		Return APC_SP_RatedSpeed(nSP)
	end function

	function MaximumSpeed() as integer
		//- The maximum speed of the serial port (baud).
		Return APC_SP_MaximumSpeed(nSP)
	end function

	sub BitRate(assigns rate as integer)
		//: Chg 2.1 Now uses special constants
		//- Set the bit rate (in bits per second) of the serial port. Use the baud_ constants.
		//- Default is 9600 bps.
		APC_SP_BitRate(nSP,rate)
	end sub
	
	sub DataBits(assigns bits as integer)
		//: Chg 2.1 Now uses special constants
		//- Set the number of data bits per character. Use the databits_ constants.
		//- Default is 8 bits.
		APC_SP_DataBits(nSP,bits)
	end sub
	
	sub StopBits(assigns bits as integer)
		//: Chg 2.1 Now uses special constants
		//- Set the number of stop bits per character. Use the stopbits_ constants.
		//- Default is 1 bit.
		APC_SP_StopBits(nSP,bits)
	end sub
	
	sub Parity(assigns p as integer)
		//: Chg 2.1 Now uses special constants
		//- Set the parity bit. Use the parity_ constants.
		//- Default is no parity.
		APC_SP_Parity(nSP,p)
	end sub
	
	sub FlowControl(assigns fc as integer)
		//: Chg 2.1 Now uses special constants
		//- Set the flow control. Use a combination of the flowcontrol_ constants.
		//- Default = no flow control
		APC_SP_FlowControl(nSP,fc)
	end sub

	sub Send(s as string)
		//- Send the specified string to the serial port.
		APC_SP_Send(nSP,s)
	end sub

	function Receive(optional terminator as string = "", optional timeout as double = 5.0) as string
		//- Poll the serial port for incoming data, until either the terminator string is received,
		//- or the timeout time (seconds) is exceeded. If terminator = "" then do not look for
		//- the terminator string, just the timeout. The received data is returned (including the
		//- terminator, if specified).
		return APC_SP_Receive(nSP,terminator,timeout)
	end function

	function ClearToSend() as boolean
		//- Check the CTS line
		return APC_SP_CTS(nSP)
	end function

	function DataCarrierDetect() as boolean
		//- Check the DCD line
		return APC_SP_DCD(nSP)
	end function

	function DataSetReady() as boolean
		//- Check the DSR line
		return APC_SP_DSR(nSP)
	end function

	function RingIndicator() as boolean
		//- Check the RI line
		return APC_SP_RI(nSP)
	end function

	sub DataTerminalReady(assigns b as boolean)
		//- Set the DTR line
		APC_SP_DTR(nSP,b)
	end sub

	sub RequestToSend(assigns b as boolean)
		//- Set the RTS line
		APC_SP_RTS(nSP,b)
	end sub

  // Shared methods
  
  private shared dim SP(-1) as APSerialPort

	private shared sub AssembleSerialPortArray()
		dim i as integer

		redim SP(-1)
		APC_InitialiseSerialPorts
		for i=0 to nSerialPorts-1
			SP.Append new APSerialPort(i)
		next
	end sub

  shared function Count() as integer
  	//- Return the number of serial ports
  	return nSerialPorts
  end function
 
	shared function SerialPort(n as integer) as APSerialPort
		//- Return the APSerialPort object for the n-th serial port (n = 1,...,APSerialPort.Count)
		if ubound(SP)<>nSerialPorts-1 then AssembleSerialPortArray
		if n<1 or n>ubound(SP)+1 then return nil
		return SP(n-1)
	end function
	
	shared function SerialPorts() as APSerialPort()
		//- Return an array of all serial ports
		dim sp(-1) as APSerialPort
		for i as integer = 1 to Count
			sp.Append SerialPort(i)
		next
		return sp
	end function
	
	shared function Choose() as APSerialPort
		//- Use a dialog to select a serial port from a list of all available serial ports.
		//- If the Cancel button is used (or the dialog closed), or no serial port is selected, 
		//- then nil is returned.
	
	  dim splist() as APSerialPort = APSerialPort.SerialPorts
		dim r() as NamedObject = Dialog.Choose(false,splist,"Serial Port")
		if r.Ubound<0 then return nil else return APSerialPort(r(0))
	end function

end class

//------------------------------------------------------------------------------------
module SearchStuff // Deprecate
//- All functionality is now in the form of Shared methods of APSearch

	function TypeName(n as integer) as string
		Deprecate("TypeName","APSearch.TypeName")
		return APSearch.TypeName(n)
	end function

	function TypeNumber(s as string) as integer
		Deprecate("TypeNumber","APSearch.TypeNumber")
		return APSearch.TypeNumber(s)
	end function

	function AllTypeNumbers() as integer()
		Deprecate("AllTypeNumbers","APSearch.AllTypeNumbers")
		return APSearch.AllTypeNumbers
	end function

	function StellarTypeNumbers() as integer()
		Deprecate("StellarTypeNumbers","APSearch.StellarTypeNumbers")
		return APSearch.StellarTypeNumbers
	end function

	function DSOTypeNumbers() as integer()
		Deprecate("DSOTypeNumbers","APSearch.DSOTypeNumbers")
		return APSearch.DSOTypeNumbers
	end function

	function AllTypeNames() as string()
		Deprecate("AllTypeNames","APSearch.AllTypeNames")
		return APSearch.AllTypeNames
	end function

	function StellarTypeNames() as string()
		Deprecate("StellarTypeNames","APSearch.StellarTypeNames")
		return APSearch.StellarTypeNames
	end function

	function DSOTypeNames() as string()
		Deprecate("DSOTypeNames","APSearch.DSOTypeNames")
		return APSearch.DSOTypeNames
	end function

end module

//------------------------------------------------------------------------------------
class APSearch
	// Documented 7/6/2012
	//- The APSearch class is used for general-purpose searching of catalogues. Typically it is used like this:
	//- dim s as new APSearch
	//- // set up search bounds and parameters here
	//- if s.Search then
	//-   for i as integer = 1 to s.nObjects
  //-     // Do something with s.GetObject(i)
	//-   next
	//- else
	//-    Print "Error: "+s.Error
	//- end if

	const item_RA = 1
	const item_Dec = 2
	const item_Magnitude = 3
	const item_Magnitude2 = 4
	const item_MagnitudeDifference = 5
	const item_DifficultyIndex = 6
	const item_Separation = 7
	const item_Size = 8
	const item_SurfaceBrightness = 9
	const item_Spectral = 10
	const item_Name = 11
	const item_Description = 12

	const rel_GT = 1
	const rel_LT = 2
	const rel_EQ = 3
	const rel_GE = -2
	const rel_LE = -1
	const rel_NE = -3
	const rel_Contains = 4
	const rel_DoesNotContain = -4
	const rel_StartsWith = 5
	const rel_DoesNotStartWith = -5
	const rel_EndsWith = 6
	const rel_DoesNotEndWith = -6

	const type_Star = 1
	const type_Double = 2
	const type_Triple = 3
	const type_Multiple = 4
	const type_Open = 5
	const type_Globular = 6
	const type_Asterism = 7
	const type_StarCloud = 8
	const type_Variable = 9
	
	const type_Pulsar = 10
	const type_XrayBinary = 11
	const type_RadioSource = 12
	const type_Quasar = 13
	const type_BLLac = 14
	const type_WhiteDwarf = 15
	const type_CataclysmicBinary = 16
	const type_RedDwarf = 17
	const type_HerbigHaro = 18
	const type_Supernova = 19

	const type_SNR = 20
	const type_PlanetaryNeb = 21
	const type_DiffuseNeb = 22
	const type_EmissionNeb = 23
	const type_Nebula = 24
	const type_Knot = 25
	const type_Nebulosity = 26
	const type_ReflectionNeb = 27
	const type_BrightNeb = 28
	const type_DarkNeb = 29

	const type_Galaxy = 30
	const type_InteractingGal = 31
	const type_LMC = 32
	const type_SMC = 33
	const type_SpiralGal = 34
	const type_EllipticalGal = 35
	const type_IrregularGal = 36
	const type_ActiveGal = 37
	const type_SeyfertGal = 38
	const type_BarredSpiralGal = 39
	
	const type_GalaxyCluster = 40

	const type_WolfRayetStar = 50
	const type_HIIRegion = 51
  const type_IRSource = 52
  const type_UVSource = 53
  const type_BeStar = 54
  const type_EclipsingBinary = 55
  const type_SpectroscopicBinary = 56
  const type_CepheidVariable = 57
  const type_MolecularCloud = 58
  const type_RedObject = 59
  
  const type_BlueObject = 60
  const type_GammaRaySource = 61
  const type_GravitationalLens = 62
  const type_TTauStar = 63
  const type_CarbonStar = 64
  const type_BrownDwarf = 65
  const type_Region = 66
  const type_CometaryGlobule = 67
  const type_Exoplanet = 68
  const type_Blazar = 69

	const type_NonExist = 90
	const type_PlateDefect = 91
	const type_USO = 92

	private nSrch as integer
	private shared dim APC_nextAPSNumber as integer


	sub Constructor()
		//- Create a new search instance.
		APC_nextAPSNumber= APC_nextAPSNumber+1
		nSrch=APC_nextAPSNumber
		APC_Srch_New(nSrch)
	end sub

	sub Destructor() // private
		APC_Srch_Kill(nSrch)
	end sub

	sub AddBound(item as integer, relation as integer, value as double)
		//- This method adds bounds to various numeric items in a catalogue object (e.g. RA, Dec, Magnitude, etc.).
		//- item is one of the following constants (see above):
		//- item_RA, item_Dec, item_Magnitude, item_Magnitude2, item_MagnitudeDifference, item_DifficultyIndex, item_Separation, item_Size, item_SurfaceBrightness.
		//- relation is one of the relation constants (see above):
		//- rel_GT, rel_LT, rel_EQ, rel_GE, rel_LE, rel_NE.

		APC_Srch_AddBound(nSrch,item,relation,value)
	end sub

	sub AddBound(item as integer, relation as integer, value as string, optional regex as boolean = false)
		//- This method adds bounds to various text items in a catalogue object (e.g. Name, etc.).
		//- item is one of the following constants (see above):
		//- item_ID, item_Name, item_Description.
		//- relation is one of the relation constants (see above):
		//- rel_EQ, rel_NE, rel_Contains, rel_DoesNotContain, rel_StartsWith, rel_DoesNotStartWith, rel_EndsWith, rel_DoesNotEndWith.
		//- If the regex parameter is true (default false), then the value parameter is assumed to be a regular expression. In this case, only the rel_Contains relation is allowed.
		APC_Srch_AddBound(nSrch,item,relation,value,regex)
	end sub

	sub AddType(n as integer)
		//- Use this to specify particular object types to search for. 
		//- n can take on any of the type_ constant values. 
		//- All types are initially included in the search. 
		//- The first AddType call resets that to include a single type. 
		//- Subsequent AddType calls append other types to the list.
		APC_Srch_AddType(nSrch,n)
	end sub

	sub AllTypes()
		//- Select to search for all object types. 
		//- Since this is the default, this is only useful to cancel any AddType calls.
		APC_Srch_AddType(nSrch,-1)
	end sub

	sub AddConstellation(cabbr as string)
		//- Add a constellation to search in (using the three-letter abbreviation, e.g. “CMa”, “Ori”). 
		//- All constellations are initially included in the search. 
		//- The first AddConstellation call resets that to include a single constellation. 
		//- Subsequent AddConstellation calls append other constellations to the list.
		APC_Srch_AddConst(nSrch,cabbr)
	end sub

	sub AllConstellations()
		//- Select to search for all constellations. 
		//- Since this is the default, this is only useful to cancel any AddConstellation calls.
		APC_Srch_AddConst(nSrch,"*")
	end sub

	sub SetCatalog(catname as string)
		//- Set a specific catalogue to search (the default is to search all catalogues). 
		//- Specify the catalogue by name (e.g. “Bright Star”) or the full description (with or without “Catalogue”), 
		//- or the file name (with or without “.apcat”). 
		//- Only one catalogue can be specified by this method.
		APC_Srch_SetCat(nSrch,catname)
	end sub

	sub SetCatalog(catidx as integer)
		//- Set a specific catalogue to search (the default is to search all catalogues). 
		//- Specify the catalogue by number (cat = 1 to APCatalog.Count).
		//- Only one catalogue can be specified by this method.
		APC_Srch_SetCat(nSrch,catidx)
	end sub

	sub SetCatalog(cat as APCatalog)
		//- Set a specific catalogue to search (the default is to search all catalogues). 
		//- Specify the catalogue by its APCatalog object.
		//- Only one catalogue can be specified by this method.
		if cat<>nil then SetCatalog(cat.Name)
	end sub

	sub SetCatalogs(catname() as string)
		//- Select multiple catalogues to search (the default is to search all catalogues). 
		//- Specify the catalogues by name (e.g. “Bright Star”) or the full description (with or without “Catalogue”), 
		//- or the file name (with or without “.apcat”).
		APC_Srch_SetCats(nSrch,catname)
	end sub

	sub SetCatalogs(catidx() as integer)
		//- Select multiple catalogues to search (the default is to search all catalogues). 
		//- Specify the catalogues by number (cat = 1 to APCatalog.Count).
		APC_Srch_SetCats(nSrch,catidx)
	end sub

	sub SetCatalogs(cat() as APCatalog)
		//- Select multiple catalogues to search (the default is to search all catalogues). 
		//- Specify each catalogue by its APCatalog object.
		dim catname(-1) as string
		for i as integer=0 to ubound(cat)
			if cat(i)<>nil then catname.Append cat(i).Name
		next
		SetCatalogs(catname)
	end sub

	sub AllCatalogs()
		//- Select to search in all catalogues. Since this is the default, this is only useful to cancel any SetCatalog calls.
		APC_Srch_SetCat(nSrch,-1)
	end sub

	sub FindMinimum(item as integer)
		//- Rather than finding all objects that match the search parameters, 
		//- find the one with the minimum value of the given item. Item can be one of:
		//- item_Magnitude, item_Magnitude2, item_MagnitudeDifference, item_DifficultyIndex, item_Separation, item_Size, item_SurfaceBrightness.
		APC_Srch_FindMin(nSrch,item)
	end sub

	sub FindMaximum(item as integer)
		//- Rather than finding all objects that match the search parameters, 
		//- find the one with the maximum value of the given item. Item can be one of:
		//- item_Magnitude, item_Magnitude2, item_MagnitudeDifference, item_DifficultyIndex, item_Separation, item_Size, item_SurfaceBrightness.
		APC_Srch_FindMax(nSrch,item)
	end sub

	sub FindFirst()
		//- Rather than finding all objects that match the search parameters, find the first one that matches the parameters.
		APC_Srch_FindFirst(nSrch)
	end sub

	sub FindAll()
		//- Select to find all objects that match the search parameters. 
		//- Since this is the default, this is only useful to cancel any FindMaximum, FindMinimum, or FindFirst calls.
		APC_Srch_FindAll(nSrch)
	end sub

	sub WithinDistance(angle as double, ra as double, dec as double)
		//- Restrict found objects to within a given radius (in degrees) of the given RA/Dec coordinates. 
		//- Cannot be used if RA/Dec were specified in any AddBound calls.
		APC_Srch_Radius(nSrch,angle,ra,dec)
	end sub

	sub MaxResults(assigns n as integer)
		//- Maximum number of objects to return (default 100). E.g. to restrict the number of objects returned to 10, do this:
    //-   s.MaxResults=10
		APC_Srch_MaxResults(nSrch,n)
	end sub

	function Search(id as string, optional progress as boolean = true) as boolean
		//- The search function performs the search. 
		//- If any parameter errors were detected, then false is returned, and the user should examine the Error function to find out why. 
		//- A search in progress can be cancelled with the Esc key.
		//- If an ID is supplied as a parameter, then no bounds can be set (apart from catalogues) 
		//- and the search is for objects having the given ID (e.g. “SAO12345”)
		//- If the progress parameter is false (default = true), then the progress information window will not be displayed.
		return APC_Srch_Search(nSrch,id,progress)
	end function

	function SIMBADSearch(id as string) as boolean
		//- Search SIMBAD for the specified ID
		//- Returns TRUE if successful
		//- Returns FALSE if no Internet connection, not a registered user, 
		//- or if SIMBAD did not find the object ID
		return APC_Srch_SIMBAD(nSrch,id)
	end function

	function Search(optional progress as boolean = true) as boolean
		//- The search function performs the search. 
		//- If any parameter errors were detected, then false is returned, and the user should examine the Error function to find out why. 
		//- A search in progress can be cancelled with the Esc key.
		//- If the progress parameter is false (default = true), then the progress information window will not be displayed.
		return APC_Srch_Search(nSrch,"",progress)
	end function

	function Error() as string
		//- Return an error message. This can be examined at any time. 
		//- If it returns a non-empty string, then that error happened prior to the call.
		return APC_Srch_Error(nSrch)
	end function

	function nObjects() as integer
		//- At the end of the search, this returns the number of objects found.
		return APC_Srch_nCatalogFind(nSrch)
	end function

	function GetObject(n as integer) as APCatalogObject
		return new APCatalogObject(-1,n,nSrch)
	end function
	
	sub SearchLinear(assigns linear as boolean)
		//- If linear is true, then any bounds on Size will assume you which to search on the linear size 
		//- in arcmin of the longest dimension (e.g. for a 15' x 10' object, 15), 
		//- as opposed to the areal size in arcmin^2 (e.g. for a 15' x 10' object, 150).
		APC_Srch_Linear(nSrch,linear)
	end sub
	
	// Shared methods
	
	shared function TypeName(n as integer) as string
		//- Long name for the given type number (type_ constants).
		//- e.g. TypeName(type_WolfRayetStar)="Wolf-Rayet Star"
		return APC_TypeName(n,false)
	end function

	shared function ShortTypeName(n as integer) as string
		//- Short name for the given type number (type_ constants).
		//- e.g. TypeName(type_WolfRayetStar)="WRStar"
		return APC_TypeName(n,true)
	end function

	shared function TypeNumber(s as string) as integer
		//- Type number for either the long or short type name.
		return APC_TypeNumber(s)
	end function

	shared function AllTypeNumbers() as integer()
		//- Return an array of all possible type numbers
		dim i as integer
		dim n(-1) as integer
		for i=type_Star to type_GalaxyCluster
			n.Append i
		next
		for i=type_WolfRayetStar to type_Blazar
			n.Append i
		next
		n.Append 90
		n.Append 91
		n.Append 92
		return n
	end function

	shared function StellarTypeNumbers() as integer()
		//- Return an array of all possible type numbers of stellar objects (stars, double stars, variable stars, etc.)
		dim n(-1) as integer
		n.Append type_Star
		n.Append type_Double
		n.Append type_Triple
		n.Append type_Multiple
		n.Append type_Asterism
		n.Append type_StarCloud
		n.Append type_Variable
		n.Append type_WhiteDwarf
		n.Append type_RedDwarf
		n.Append type_TTauStar
		n.Append type_CarbonStar
		n.Append type_BrownDwarf
		return n
	end function

	shared function DSOTypeNumbers() as integer()
		//- Return an array of all possible type numbers of deep-sky objects (i.e. not stars).
		dim i as integer
		dim n(-1) as integer
		n.Append Type_Open
		n.Append type_Globular
		for i=type_Pulsar to type_GalaxyCluster
			if i<>type_RedDwarf and i<>type_WhiteDwarf then n.Append i
		next
		n.Append type_WolfRayetStar
		n.Append type_GammaRaySource
		n.Append type_GravitationalLens
		n.Append type_CometaryGlobule
		n.Append type_ExoPlanet
		n.Append type_Blazar
		return n
	end function

  shared function APC_AllTypeNames(shortnames as boolean) as string() // private
  	dim i as integer
		dim n(-1) as integer
		dim s(-1) as string
		n=AllTypeNumbers
		redim s(ubound(n))
		for i=0 to ubound(n)
			s(i)=APC_TypeName(n(i),shortnames)
		next
		return s
  end function

	shared function AllTypeNames() as string()
		//- Return an array of all possible type names.
		return APC_AllTypeNames(false)
	end function

	shared function AllShortTypeNames() as string()
		//- Return an array of all possible short type names.
		return APC_AllTypeNames(true)
	end function

	shared function StellarTypeNames() as string()
		//- Return an array of all possible stellar type names.
		dim i as integer
		dim n(-1) as integer
		dim s(-1) as string
		n=StellarTypeNumbers
		redim s(ubound(n))
		for i=0 to ubound(n)
			s(i)=TypeName(n(i))
		next
		return s
	end function

	shared function DSOTypeNames() as string()
		//- Return an array of all possible deep-sky object type names.
		dim i as integer
		dim n(-1) as integer
		dim s(-1) as string
		n=DSOTypeNumbers
		redim s(ubound(n))
		for i=0 to ubound(n)
			s(i)=TypeName(n(i))
		next
		return s
	end function

end class

//------------------------------------------------------------------------------------
module Astronomical // deprecate
	const ss_Moon = 99
	const ss_Mercury = 1
	const ss_Venus = 2
	const ss_Sun = 3
	const ss_Mars = 4
	const ss_Jupiter = 5
	const ss_Saturn = 6
	const ss_Uranus = 7
	const ss_Neptune = 8
	const ss_Pluto = 9

	function Sunrise(optional dt as double = 0.0, optional site as SiteResource = nil) as double()
		Deprecate("Sunrise","SolarSystem.Sunrise")
	  return SolarSystem.Sunrise(dt,site)
	end function

	function Sunset(optional dt as double = 0.0, optional site as SiteResource = nil) as double()
		Deprecate("Sunset","SolarSystem.Sunset")
		return SolarSystem.Sunset(dt,site)
	end function

	function Moonrise(optional dt as double = 0.0, optional site as SiteResource = nil) as double
		Deprecate("Moonrise","SolarSystem.Moonrise")
		return SolarSystem.Moonrise(dt,site)
	end function

	function Moonset(optional dt as double = 0.0, optional site as SiteResource = nil) as double
		Deprecate("Moonset","SolarSystem.Moonset")
		return SolarSystem.Moonset(dt,site)
	end function

	function MoonPhase(optional dt as double = 0.0, optional site as SiteResource = nil) as double
		Deprecate("MoonPhase","SolarSystem.MoonPhase")
		return SolarSystem.MoonPhase(dt,site)
	end function

	function MoonIllumination(optional dt as double = 0.0, optional site as SiteResource = nil) as double
		Deprecate("MoonIllumination","SolarSystem.MoonIllumination")
		return SolarSystem.MoonIllumination(dt,site)
	end function

	sub SolarSystemPosition(which as integer, byref ra as double, byref dec as double, optional dt as double = 0.0, optional site as SiteResource = nil)
		Deprecate("SolarSystemPosition","SolarSystem.Position")
		SolarSystem.Position(which,ra,dec,dt,site)
	end sub

	function AddSolarSystemObject(what as integer) as APPlanObject
		Deprecate("AddSolarSystemObject","SolarSystem.AddObject")
		return SolarSystem.AddObject(what)
	end function
	
	sub CometPosition(jdate as double, Eccentricity as double, PerihelionDistance as double, OrbitalInclination as double, LongOfAscendingNode as double, ArgumentOfPerhelion as double, theepoch as double, AbsMag as double, MagConst as double, DateOfPerihelion as double, byref RA as double, byref Dec as double, byref Mag as double)
		Deprecate("CometPosition","SolarSystem.CometPosition")
		SolarSystem.CometPosition(jdate,Eccentricity,PerihelionDistance,OrbitalInclination,LongOfAscendingNode,ArgumentOfPerhelion,theepoch,AbsMag,MagConst,DateOfPerihelion,RA,Dec,Mag)
	end sub
	
	sub MinorPlanetPosition(jdate as double,Eccentricity as double,SemimajorAxis as double,OrbitalInclination as double,LongOfAscendingNode as double,ArgumentOfPerhelion as double,DateOfEpoch as double,VisualMag as double,SlopeParam as double,MeanAnomalyAtEpoch as double, byref RA as double,byref Dec as double,byref Mag as double)
		Deprecate("MinorPlanetPosition","SolarSystem.MinorPlanetPosition")
		SolarSystem.MinorPlanetPosition(jdate,Eccentricity,SemimajorAxis,OrbitalInclination,LongOfAscendingNode,ArgumentOfPerhelion,DateOfEpoch,VisualMag,SlopeParam,MeanAnomalyAtEpoch,RA,Dec,Mag)
	end sub

end module

//------------------------------------------------------------------------------------
class SolarSystem
	// Documented 7/5/2012
	//- Solar system body computations.
	//- Instantiation: Do not instantiate objects of this class. Use the shared methods.
	
	const ss_Moon = 99
	const ss_Mercury = 1
	const ss_Venus = 2
	const ss_Sun = 3
	const ss_Mars = 4
	const ss_Jupiter = 5
	const ss_Saturn = 6
	const ss_Uranus = 7
	const ss_Neptune = 8
	const ss_Pluto = 9

	shared function Sunrise(optional dt as double = 0.0, optional site as SiteResource = nil) as double()
		//- Return the times of Sunrise and start times of astronomical, nautical, and civil twilight.
		//- The result array has four elements:
		//- 0 = rise time (-1 if sun doesn't rise)
		//- 1 = start of civil twilight (<0 if never occurs)
		//- 2 = start of nautical twilight (<0 if never occurs)
		//- 3 = start of astronomical twilight (<0 if never occurs)
		//- If dt = 0 then return the times for the current computer date/time, 
		//- otherwise use the given local date/time in seconds. 
		//- Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		//- If site = nil then use the plan document's current site, otherwise use the specified site resource.

		if site=nil then
			return Plan().SunRise(dt)
		else
			return APC_SunRiseSet(dt,true,site.Latitude,site.Longitude,site.GMTOffset(dt))
		end if
	end function

	shared function Sunset(optional dt as double = 0.0, optional site as SiteResource = nil) as double()
		//- Return the times of Sunset and end times of astronomical, nautical, and civil twilight.
		//- The result array has four elements:
		//- 0 = set time (-2 if sun doesn't set)
		//- 1 = end of civil twilight (<0 if never occurs)
		//- 2 = end of nautical twilight (<0 if never occurs)
		//- 3 = end of astronomical twilight (<0 if never occurs)
		//- If dt = 0 then return the times for the current computer date/time, 
		//- otherwise use the given local date/time in seconds. 
		//- Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		//- If site = nil then use the plan document's current site, otherwise use the specified site resource.

		if site=nil then
			return Plan().SunSet(dt)
		else
			return APC_SunRiseSet(dt,false,site.Latitude,site.Longitude,site.GMTOffset(dt))
		end if
	end function

	shared function Moonrise(optional dt as double = 0.0, optional site as SiteResource = nil) as double
		//- Return the time of Moonrise (<0 if it does not rise).
		//- If dt = 0 then return the time for the current computer date/time, otherwise use the given local date/time in seconds. Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		//- If site = nil then use the plan document's current site, otherwise use the specified site resource.	

		if site=nil then
			return Plan().MoonRise(dt)
		else
			return APC_MoonRiseSet(dt,true,site.Name)
		end if
	end function

	shared function Moonset(optional dt as double = 0.0, optional site as SiteResource = nil) as double
		//- Return the time of Moonset (<0 if it does not set).
		//- If dt = 0 then return the time for the current computer date/time, otherwise use the given local date/time in seconds. Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		//- If site = nil then use the plan document's current site, otherwise use the specified site resource.	
		
		if site=nil then
			return Plan().MoonSet(dt)
		else
			return APC_MoonRiseSet(dt,false,site.Name)
		end if
	end function

	shared function MoonPhase(optional dt as double = 0.0, optional site as SiteResource = nil) as double
		//- Return the moon phase angle (+/-180 = new, 0=full, 90=first quarter, -90 last quarter).
		//- If dt = 0 then return the phase for the current computer date/time, otherwise use the given local date/time in seconds. Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		//- If site = nil then use the plan document's current site, otherwise use the specified site resource.

		if site=nil then
			return Plan().MoonPhase(dt)
		else
			return APC_MoonPhase(dt,site.Latitude,site.Longitude,site.GMTOffset(dt))
		end if
	end function

	shared function MoonIllumination(optional dt as double = 0.0, optional site as SiteResource = nil) as double
		//- Return the illuminated fraction of the moon's disk (0 - 1).
		//- If dt = 0 then return the illumination for the current computer date/time, otherwise use the given local date/time in seconds. Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		//- If site = nil then use the plan document's current site, otherwise use the specified site resource.

		if site=nil then
			return Plan().MoonIllumination(dt)
		else
			return APC_MoonIllum(dt,site.Latitude,site.Longitude,site.GMTOffset(dt))
		end if
	end function

	shared sub Position(which as integer, byref ra as double, byref dec as double, optional dt as double = 0.0, optional site as SiteResource = nil)
		//- Return the RA/Dec position of the given object (which). Use the ss_ constants to specify which object you want the coordinates for.
		//- If dt = 0 then return the position for the current computer date/time, otherwise use the given local date/time in seconds. Note that you can use a Date object for this parameter (since it will be automatically converted to a date/time value)
		//- If site = nil then use the plan document's current site, otherwise use the specified site resource

		if site=nil then
			APC_SolarSystemPosition(which,ra,dec,dt,"")
		else
			APC_SolarSystemPosition(which,ra,dec,dt,site.Name)
		end if
	end sub

	shared function AddObject(what as integer) as APPlanObject
		//- Add the given object (what) to the current plan. Use the ss_ constants to specify which object you want to add.
		return Plan().AddSolarSystemObject(what)
	end function
	
	shared sub CometPosition(jdate as double, Eccentricity as double, PerihelionDistance as double, OrbitalInclination as double, LongOfAscendingNode as double, ArgumentOfPerhelion as double, theepoch as double, AbsMag as double, MagConst as double, DateOfPerihelion as double, byref RA as double, byref Dec as double, byref Mag as double)
		//- Return the RA/Dec position and estimated magnitude of the specified comet, for the given Julian date.
		APC_CometPosition(jdate,Eccentricity,PerihelionDistance,OrbitalInclination,LongOfAscendingNode,ArgumentOfPerhelion,theepoch,AbsMag,MagConst,DateOfPerihelion,RA,Dec,Mag)
	end sub
	
	shared sub MinorPlanetPosition(jdate as double,Eccentricity as double,SemimajorAxis as double,OrbitalInclination as double,LongOfAscendingNode as double,ArgumentOfPerhelion as double,DateOfEpoch as double,VisualMag as double,SlopeParam as double,MeanAnomalyAtEpoch as double, byref RA as double,byref Dec as double,byref Mag as double)
		//- Return the RA/Dec position and estimated magnitude of the specified minor planet, for the given Julian date.
		APC_MinorPlanetPosition(jdate,Eccentricity,SemimajorAxis,OrbitalInclination,LongOfAscendingNode,ArgumentOfPerhelion,DateOfEpoch,VisualMag,SlopeParam,MeanAnomalyAtEpoch,RA,Dec,Mag)
	end sub
	
end class

//------------------------------------------------------------------------------------
module ListWindowStuff // deprecate

	function ListWindows( ) as ListWindow()
		Deprecate("ListWindows()","ListWindow.ListWindows()")
		return ListWindow.ListWindows
	end function
end module

//------------------------------------------------------------------------------------
class ListWindow
	// Documented 7/5/2012
	//- Create a window containing a multi-column list.
	private dim nlist as integer
	
	sub Constructor()
		//- Create an untitled list window
		nlist=APC_LW_New("")
	end sub
	
	sub Constructor(title as string)
		//- Create a list window with the given title.
		nlist=APC_LW_New(title)
	end sub

	sub Constructor(n as integer) // private
		nlist=n
	end sub

	function Title() as string
		//- Get or set the window title.
		return APC_LW_GetTitle(nlist)
	end function

	sub Title(assigns s as string)
		APC_LW_SetTitle(nlist,s)
	end sub

	sub Cell(row as integer, column as integer, optional fmat as string = "", assigns v as string)
		//- Assigns the string v to the given row and column of the list.
		//- If fmat is specified, it should be "String", "ID", or one of the fmat specifiers for numeric fields. 
		//- This is used to determine how that column will be sorted.
		APC_LW_Add(nlist,row,column,v,fmat)
	end sub
	
	sub Cell(row as integer, column as integer, assigns v as integer)
		//- Assigns the integer v to the given row and column of the list.
		APC_LW_Add(nlist,row,column,v)
	end sub
	
	sub Cell(row as integer, column as integer, assigns v as boolean)
		//- Assigns the boolean v to the given row and column of the list.
		APC_LW_Add(nlist,row,column,v)
	end sub
	
	sub Cell(row as integer, column as integer, optional fmat as string = "", assigns v as double)
		//- Assigns the double v to the given row and column of the list.
		//- If fmat is specified, it should be one of the fmat specifiers for numeric fields.
		APC_LW_Add(nlist,row,column,v,fmat)
	end sub

	function Cell(row as integer, column as integer) as string
		//- Get the value of the given row and column of the list, as a string.
		return APC_LW_Get(nlist,row,column)
	end function

	sub CellFormat(row as integer, column as integer, optional bold as boolean = false, optional italic as boolean = false, optional underline as boolean = false)
		//- Set the text format of the given row/column of the list.
		APC_LW_CellFormat(nlist,row,column,bold,italic,underline)
	end sub

	sub CellColor(row as integer, column as integer, optional text as Color = &c000000, optional bg as Color = &c654321)
		//- Set the text and background colour of the given row/column of the list. 
		//- Note that the default background colour (&c654321) signals that the colour should not be changed.
		APC_LW_CellColour(nlist,row,column,text,bg)
	end sub

	sub Heading(column as integer, optional alignment as integer = 0, assigns title as string)
		//- Set the heading and alignment of the given column.
		APC_LW_SetHeading(nlist,column,title,alignment)
	end sub

	function Heading(column as integer) as string
		//- Get the heading of the specified column.
		return APC_LW_GetHeading(nlist,column)
	end function

	sub Sort(column as integer, optional ascending as boolean = true, optional num as boolean = false)
		//- Sort the list by the specified column, in the given order. 
		//- If num is true, assume the column contains numeric data.
		APC_LW_Sort(nlist,column,ascending,num)
	end sub

	sub Refresh()
		//- Refresh the list.
		APC_LW_Refresh(nlist)
	end sub

	sub Append(paramarray s as string)
		//- Append a row of data (an array of strings) to the list
		APC_LW_Append(nlist,s)
	end sub

	sub Hide()
		//- Hide the list window.
		APC_LW_Show(nlist,false)
	end sub

	sub Show(optional s as boolean = true)
		//- Show the list window (or hide it if s = false)
		APC_LW_Show(nlist,s)
	end sub

	sub Clear()
		//- Clear all data from the list.
		APC_LW_Clear(nlist)
	end sub
	
	sub Size(width as integer, height as integer)
		//- Change the size of the window the given dimensions
		//- If width=0 then set width to fit table
		//- If width=-1 then set width to fill screen
		//- If height=-1 then set height to fill screen
		
		APC_LW_Size(nlist,width,height)
	end sub
	
	sub Position(left as integer, top as integer)
		//- Change the coordinates of the window's top/left corner to the given values
		//- If left=-1 then set to the left-most position on the screen
		//- If top=-1 then set to the top-most position on the screen
		APC_LW_Position(nlist,left,top)
	end sub
	
	sub Close()
		//- Close the list window. 
		//- NOTE: After doing this, do not refer to the ListWindow object again.
		APC_LW_Close(nlist)
	end sub

	function Columns() as integer
		//- Get or set the number of columns in the list.
		return APC_LW_GetColumns(nlist)
	end function

	sub Columns(assigns n as integer)
		APC_LW_SetColumns(nlist,n)
	end sub
	
	function Rows() as integer
		//- Get or set the number of rows in the list.
		return APC_LW_GetRows(nlist)
	end function

	sub Rows(assigns n as integer)
		APC_LW_SetRows(nlist,n)
	end sub
	
	sub Font(fontName as string, fontSize as integer, optional rowHeight as integer = 0)
		//- Change the font for the entire list. You can also specify the row height in pixels, or 
		//- use the default of 0 to let the system decide.
		APC_LW_SetFont(nlist,fontName,fontSize,rowHeight)
	end sub

	sub Read(optional f as APTextFile = nil, optional separator as string = "", optional headings as boolean = false)
		//- Read a text file into the list from the given file.
		//- If f is nil, then ask the user to select the file.
		//- Columns in the text are separated by the separator parameter. The default is tab-separated.
		//- If headings is true then the first line of the file is assumed to contain heading information.

		dim r as integer
		dim c as integer
		dim cols(-1) as string
		dim sep as string
		if f=nil then
			f=ReadTextFile("")
			if f=nil then return
		end if
		if separator="" then sep=chr(9) else sep=separator
		if headings then
			cols=Split(f.ReadLine,sep)
			Columns=ubound(cols)+1
			for c=0 to ubound(cols)
				Heading(c+1)=cols(c)
			next
		end if
		r=Rows+1
		while not f.EOF
			cols=Split(f.ReadLine,sep)
			for c=0 to ubound(cols)
				Cell(r,c+1)=cols(c)
			next
			r=r+1
		wend
		f.Close
	end sub
	
	sub Write(optional f as APTextFile = nil, optional separator as string = "", optional headings as boolean = false)
		//- Write the contents of the list to a text file.
		//- If f is nil then ask the user to specify a file.
		//- The separator parameter specifies the separator between columns. The default is tab-separated.
		//- If headings is true, then put the list headings into the first line of the file.
		dim r as integer
		dim c as integer
		dim cols(-1) as string
		dim sep as string
		dim s as string
		if f=nil then
			Yield
			f=WriteTextFile("",Title+".txt")
			if f=nil then return
		end if
		if separator="" then sep=chr(9) else sep=separator
		redim cols(Columns-1)
		if headings then
			for c=1 to Columns
				cols(c-1)=Heading(c)
			next
			f.WriteLine(Join(cols,sep))
		end if
		for r=1 to Rows
			for c=1 to Columns
				cols(c-1)=Cell(r,c)
			next
			f.WriteLine(Join(cols,sep))
		next
		f.Close
	end sub
	
	// Shared
	
	shared function ListWindows() as ListWindow()
		//- Return an array of all open (but not necessarily visible) ListWindows.
		dim lw(-1) as ListWindow
		dim i,n(-1) as integer
		n=APC_LW_GetWindows
		for i=0 to ubound(n)
			lw.Append new ListWindow(n(i))
		next
		return lw
	end function
	
end class

//------------------------------------------------------------------------------------
class OLEObject
	private dim APC_ole_Instance as integer

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(programID as string, optional newInstance as boolean = true)
		APC_ole_Instance = APC_OLECreate(programID,newInstance)
	end sub

	private sub Constructor(instance as integer)
		APC_ole_Instance = instance
	end sub

	sub Destructor() // private
		APC_OLEDestroy(APC_ole_Instance)
	end sub

	function OLE_Encode(v as Variant) as string
		select case v.Type
		case vtype_Integer, vtype_Long
			return "i"+format(v.IntegerValue,"-0")
		case vtype_Single, vtype_Double
			return "d"+format(v.DoubleValue,"-0.0000000000")
		case vtype_Boolean
			if v.BooleanValue then return "b1" else return "b0"
		case vtype_Object
			return "o"+format(OLEObject(v.ObjectValue).APC_ole_Instance,"0")
		else
			return "s"+v.StringValue
		end select
	end function

	function OLE_Decode(s as string) as Variant
		select case left(s,1)
		case "i"
			return val(s.mid(2))
		case "d","t"
			return CDbl(s.mid(2))
		case "b"
			return s="b1"
		case "s"
			return s.mid(2)
		case "o"
			return new OLEObject(val(mid(s,2)))
		else
			return s
		end select
	end function

	sub Value(PropertyName as string, assigns v as Variant)
		APC_OLEProperty(APC_ole_Instance,PropertyName,OLE_Encode(v))
	end sub

	function Value(PropertyName as string) as Variant
		return OLE_Decode(APC_OLEProperty(APC_ole_Instance,PropertyName))
	end function

	function Invoke(NameOfFunction as string, paramarray v as Variant) as Variant
		dim s(-1) as string, i as integer
		for i=0 to ubound(v)
			s.Append OLE_Encode(v(i))
		next
		return OLE_Decode(APC_OLEInvoke(APC_ole_Instance,NameOfFunction,s))
	end function

	function LastErrorMessage() as string
		if lastErrorCode=0 then return "" else return APC_OLELastErrorMessage()
	end function

	function LastErrorCode() as integer
		return APC_OLELastErrorCode()
	end function

	function LastError() as string
		if LastErrorCode=0 then return "" else return format(LastErrorCode,"-0")+": "+LastErrorMessage
	end function
end class

//------------------------------------------------------------------------------------
class APReticle
	// Documented 7/4/2012
	//- Retrieve information about custom reticles.
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. APReticle.Reticle(n))
	implements NamedObject
	
	const shape_Round = 0
	const shape_Rectangle = 1
	const shape_Imager = 2

	private dim vShape as integer
	private dim vDiameter as double
	private dim vWidth as double
	private dim vHeight as double
	private dim vOffset as double
	private dim vEnabled as boolean
	private dim vName as string
	private dim vAbbreviation as string

	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	private sub Constructor(n as integer)
		APC_GetReticle(n,vShape,vDiameter,vWidth,vHeight,vOffset,vEnabled,vName,vAbbreviation)
	end sub
	
	function Shape() as integer
		//- See APReticle.shape_ constants
		return vShape
	end function
	
	function Diameter() as double
		return vDiameter
	end function
	
	function Width() as double
		return vWidth
	end function
	
	function Height() as double
		return vHeight
	end function
	
	function Offset() as double
		return vOffset
	end function
	
	function Enabled() as boolean
		return vEnabled
	end function
	
	function ObjectName() as string // private
		return Name
	end function

	function Name() as string
		return vName
	end function
	
	function Abbreviation() as string
		return vAbbreviation
	end function
	
	// Shared methods

	shared function Reticle(index as integer) as APReticle
	  //- Retrieve custom reticle by index, idx = 1...Count
		if index<1 or index>Count then
			return nil
		else
			return new APReticle(index)
		end if
	end function

	shared function Reticle(name as string) as APReticle
	  //- Retrieve custom reticle by name, or nil if not found.
	  dim n as integer = Count
		for i as integer = 1 to n
			dim r as APReticle = new APReticle(i)
			if r<>nil and r.Name=name then return r
		next
		return nil
	end function

	shared function Reticles() as APReticle()
	  //- Retrieve all custom reticles
	  dim r(-1) as APReticle
	  dim n as integer = Count
		for i as integer = 1 to n
			r.Append Reticle(i)
		next
		return r
	end function

	shared function Count() as integer
	  //- Get count of custom reticles
		return APC_GetReticleCount
	end function
	
	shared function Choose(optional multiple as boolean = false, optional enabledOnly as boolean = false) as APReticle()
		//- Use a dialog to select one or more reticles from a list of all reticles.
		//- If multiple is true, allow selecting zero or more resources.
		//- If multiple is false, allow selection of a single resource.
		//- All defined reticles are displayed, unless enabledOnly = true, in which case only enabled reticles are displayed.
		//- If the Cancel button is used (or the dialog closed), or no reticle is selected, 
		//- then an empty array is returned.
	
		dim rlist() as APReticle = APReticle.Reticles
		if enabledOnly then 
			for i as integer = rlist.Ubound downto 0 
				if not rlist(i).Enabled then rlist.Remove i
			next
		end if
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,"Reticle")
		dim result() as APReticle
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = APReticle(r(i))
		next
		return result
	end function

end class

//------------------------------------------------------------------------------------
class PrinterCanvas
  inherits Canvas
  //- A special subclass of Canvas used by the printing mechanism. 
  //- A printing script must create an instance of this class and use it to output text and graphics.

  const ftype_Objects = 1
  const ftype_Sessions = 2
  const ftype_Observations = 3
  
  sub Constructor(optional canCancel as boolean = false, optional extra as string = "")
  	//- Construct a new PrinterCanvas.
		//- If canCancel is true, then add a Cancel button to the progress dialog and allow the user 
		//- to cancel the printing (see the Aborted method).
		//- When the canvas is being built (particularly multi-page canvases), a progress window is displayed. 
		//- Append the specified text (extra) to the end of that progress dialog. 
		//- This can be used to inform the user of stages of a long process, or for debugging.

		super.Constructor(APC_GetPrintType,canCancel,extra)
  end sub

  function GetTask( ) as string
  	//- Printing scripts consist of one or more "tasks", selectable by the user. 
  	//- This method returns the currently-selected task.
		return APC_CanvasGetTask(cIdx)
  end function

	function Aborted( ) as boolean
		//- This method returns true if the PrinterCanvas object was constructed with CanCancel = true, 
		//- and during the printing process the user clicked the Cancel button on the progress dialog. 
		//- The script should terminate as rapidly as possible if this is detected. 
		//- You should make calls to Aborted in all major loops of the printing script.
		return APC_CanvasWasCancelled(cIdx)
	end function
	
  function GetHeaderItem(item as string) as string
  	//- This function should be overridden to return the value of the specified page header item from the script. 
  	//- Some header items are pre-defined and will never be used as an item here (e.g. page number), 
  	//- but any script-specific items should be converted into their corresponding values by this method.
		return ""
  end function

  function GetFooterItem(item as string) as string
  	//- This function should be overridden to return the value of the specified page footer item from the script. 
  	//- Some footer items are pre-defined and will never be used as an item here (e.g. page number), 
  	//- but any script-specific items should be converted into their corresponding values by this method.
		return ""
  end function
  
  function Abbreviate(heading as string) as string
    //- Return the abbreviation for the given (full) heading. 
    //- Valid for objects, observations and sessions. 
    //- e.g. Abbreviate("Right Ascension") = "RA".
  	return APC_Abbreviate(heading)
  end function

  sub APC_HeaderFooterStuff() // private
		dim items() as string, i as integer
		items=APC_CanvasGetHeaderFooterItems(cIdx,true)
		for i=0 to ubound(items)
			items(i)=GetHeaderItem(items(i))
		next
		APC_CanvasSetHeaderFooterItems(cIdx,true,items)
		items=APC_CanvasGetHeaderFooterItems(cIdx,false)
		for i=0 to ubound(items)
			items(i)=GetFooterItem(items(i))
		next
		APC_CanvasSetHeaderFooterItems(cIdx,false,items)
  end sub

  sub NewPage(optional extra as string = "") // private
		APC_HeaderFooterStuff()
		super.NewPage(extra)
  end sub

  sub Close() // private
		APC_HeaderFooterStuff()
		super.Close()
  end sub

  function GetRestrictions() as string()
  	//- Returns a list of user-chosen (checked) restrictions. 
  	//- This will be a (possibly empty) subset of all restrictions defined by the script.
		return APC_CanvasGetRestrictions(cIdx)
  end function

  function HasRestriction(restriction as string) as boolean
  	//- Return true if restriction is one of the user-chosen (checked) restrictions.
		return restriction<>"" and APC_CanvasGetRestrictions(cIdx).IndexOf(restriction)>=0
  end function

  function GetFields(n as integer) as string()
  	//- Get a list of the selected fields for the record type n. n is one of the ftype_ constants.
		return APC_CanvasGetFields(cIdx,n)
  end function

  function HasField(field as string, n as integer) as boolean
  	//- Return true if the specified field from record type n is selected. 
  	//- n is one of the ftype_ constants.
		return field<>"" and APC_CanvasGetFields(cIdx,n).IndexOf(field)>=0
  end function

  function GetnOptions( ) as integer
  	//- Return the number of print options.
		return APC_CanvasGetnOptions(cIdx)
  end function

  sub GetOption(n as integer, byref name as string, byref caption as string, byref checked as boolean, byref value as string)
  	//- Return print option n, n = 1...GetnOptions.
  	//- name is the internal name of the option.
  	//- caption is the displayed name of the option.
  	//- checked is true if the checkbox associated with the option is checked.
  	//- value is the value associated with the option, where applicable.

		APC_CanvasGetOption(cIdx,n,name,caption,checked,value)
  end sub

  function GetOption(name as string, byref caption as string, byref checked as boolean, byref value as string) as boolean
  	//- Return the print option with the given name. Return true if found, or false if it doesn't exist.
  	//- name is the internal name of the option.
  	//- caption is the displayed name of the option.
  	//- checked is true if the checkbox associated with the option is checked.
  	//- value is the value associated with the option, where applicable.
		dim i as integer, oname as string
		for i=1 to GetnOptions
			APC_CanvasGetOption(cIdx,i,oname,caption,checked,value)
			if oname=name then return true
		next
		return false
  end function

  function OptionChecked(name as string) as boolean
  	//- Return true if the print option with the given name exists and is checked.
		dim i as integer, oname,caption,value as string, checked as boolean
		for i=1 to GetnOptions
			APC_CanvasGetOption(cIdx,i,oname,caption,checked,value)
			if oname=name then return checked
		next
		return false
  end function

  function HasOption(name as string) as boolean
  	//- Return true if the print option with the given name exists.
		dim i as integer, oname,caption,value as string, checked as boolean
		for i=1 to GetnOptions
			APC_CanvasGetOption(cIdx,i,oname,caption,checked,value)
			if oname=name then return true
		next
		return false
  end function

  function OptionValue(name as string) as string
  	//- Return the associated value of the print option with the given name.
		dim i as integer, oname,caption,value as string, checked as boolean
		for i=1 to GetnOptions
			APC_CanvasGetOption(cIdx,i,oname,caption,checked,value)
			if oname=name then return value
		next
		return ""
  end function

  function OptionIncludes(name as string, value as string) as boolean
  	//- Return true if the print option with the given name exists, and contains the given value.
		return instr("+"+OptionValue(name)+"+","+"+value+"+")>0
  end function

  function CMToPixels(cm as double) as integer
  	//- This function uses the printer resolution and page size to convert centimetres on the page to the equivalent number of pixels.
		return APC_CanvasCMToPixels(cIdx,cm)
  end function

end class

//------------------------------------------------------------------------------------
class SQLRecord
	// Documented 7/4/2012
	//- Usage:
	//- 
	//- dim r as new SQLRecord
	//- r.Column("RA")=ra
	//- r.Column("Dec")=dec
	//- r.Column("ID")=id
	//- db.InsertRecord "Objects",r
	
	private dim apc_key(-1) as string
	private dim apc_value(-1) as Variant
	
	sub Constructor()
	end sub
	
	sub Column(colname as string, assigns v as Variant)
		//- Set the value of column in this record
		if v=nil then return
		dim i as integer = apc_key.IndexOf(colname)
		if i>=0 then
			apc_value(i)=v
		else
			apc_key.Append colname
			apc_value.Append v
		end if
	end sub
	
	function Column(colname as string) as Variant
		//- Get the value of column in this record
		dim i as integer = apc_key.IndexOf(colname)
		if i>=0 then
			return apc_value(i)
		else
			return nil
		end if
	end function
	
	function Encode() as string // private
		dim fields(-1),parts(2) as string
		for i as integer = 0 to ubound(apc_key)
			parts(0)=apc_key(i)
			parts(1)=str(apc_value(i).Type)
			select case apc_value(i).Type
				case vtype_Integer,vType_Long					
					parts(2)=format(apc_value(i).IntegerValue,"-0")
				case vtype_Double,vType_Single					
					parts(2)=format(apc_value(i).DoubleValue,"-0.0000000")
				case vtype_Boolean					
					parts(2)=str(apc_value(i))
				case vtype_String					
					parts(2)=apc_value(i).StringValue
			else
				parts(2)=apc_value(i).StringValue
			end select
			fields.Append Join(parts,chr(1))
		next
		return Join(fields,chr(2))
	end function
	
end class

//------------------------------------------------------------------------------------
class SQLRecordSet
	// Documented 7/4/2012
	//- Note: Do not construct new instances of this object.
	//- Use the methods of the relevant class to retrieve
	//- instances (e.g. SQLDatabase.SQLSelect())

	private dim apc_rs as integer
	private dim apc_closed as boolean
	
	private sub Constructor()
  	// Do not allow creation of instances of this object
  end sub
  
	sub Constructor(rs as integer) // private
		apc_rs=rs
		apc_closed=false
	end sub
	
	sub Destructor() // private
		Close
	end sub
	
	function EOF() as boolean
		//- Return True if no more records in record set
		return APC_SQLRSEOF(apc_rs)
	end function
	
	sub MoveNext()
		//- Move to the next record in the record set
		APC_SQLRSMoveNext(apc_rs)
	end sub
	
	sub Close()
		//- Close the record set
		if not apc_closed then APC_SQLRSClose(apc_rs)
		apc_closed=true
	end sub
	
	function Field(fld as string) as Variant
		//- Return the value of the current record field by column name
		dim dbl as double, int as integer, str as string, bool as Boolean
		select case APC_SQLRSGetField(apc_rs,fld,str,dbl,int,bool)
		case 1
			return str
		case 2
			return dbl
		case 3
		  return int
		case 4
		  return bool
		case 5
		  return new Date(dbl)
		else
			return nil
		end select
	end function
	
	sub Field(fld as string, assigns v as Variant)
		//- Change the value of the current record field by column name
		if v.Type=vtype_Object and v.ObjectValue isa Date then
			APC_SQLRSSetField(apc_rs,fld,5,"",Date(v.ObjectValue).TotalSeconds,0,false)
			return
		end if
		select case v.Type
		case vtype_Integer, vtype_Long
			APC_SQLRSSetField(apc_rs,fld,3,"",0.0,v.IntegerValue,false)
		case vtype_Single, vtype_Double
			APC_SQLRSSetField(apc_rs,fld,2,"",v.DoubleValue,0,false)
		case vtype_Boolean
			APC_SQLRSSetField(apc_rs,fld,4,"",0.0,0,v.BooleanValue)
		else
			APC_SQLRSSetField(apc_rs,fld,1,v.StringValue,0.0,0,false)
		end select
	end sub
	
	function IdxField(fld as integer) as Variant
		//- Return the value of the current record field by column index (1-based)
		dim dbl as double, int as integer, str as string, bool as Boolean
		select case APC_SQLRSGetField(apc_rs,fld,str,dbl,int,bool)
		case 1
			return str
		case 2
			return dbl
		case 3
		  return int
		case 4
		  return bool
		case 5
		  return new Date(dbl)
		else
			return nil
		end select
	end function
	
	sub IdxField(fld as integer, assigns v as Variant)
		//- Change the value of the current record field by column index (1-based)
		if v.Type=vtype_Object and v.ObjectValue isa Date then
			APC_SQLRSSetField(apc_rs,fld,5,"",Date(v.ObjectValue).TotalSeconds,0,false)
			return
		end if
		select case v.Type
		case vtype_Integer, vtype_Long
			APC_SQLRSSetField(apc_rs,fld,3,"",0.0,v.IntegerValue,false)
		case vtype_Single, vtype_Double
			APC_SQLRSSetField(apc_rs,fld,2,"",v.DoubleValue,0,false)
		case vtype_Boolean
			APC_SQLRSSetField(apc_rs,fld,4,"",0.0,0,v.BooleanValue)
		else
			APC_SQLRSSetField(apc_rs,fld,1,v.StringValue,0.0,0,false)
		end select
	end sub
	
	function IdxFieldName(fld as integer) as string
		//- Return the name of the column by index (1-based)
		return APC_SQLRSGetFieldName(apc_rs,fld)
	end function
	
end class

//------------------------------------------------------------------------------------
class SQLDatabase
	// Documented 7/4/2012
	//- The base class for any type of SQL-based database.
	protected dim apc_DB as integer
	protected dim apc_closed as boolean
	
	const sqlerror_None = 0    // Not an error
	
	const sqlerror_Cancelled = -1 // User cancelled operation
	const sqlerror_BadFilePath = -2 // Bad file path specified
	const sqlerror_Create = -3 // Could not create file
	const sqlerror_Connect = -4 // Could not connect to database
	const sqlerror_NoFields = -5 // Record contains no fields

	private sub Constructor(optional path as string = "", optional createNew as boolean = false)
		// To avoid constructing base class instances
	end sub
	
	sub Destructor() // private
		if apc_DB>=0 and not apc_closed then 
			APC_SQLCommit(apc_DB)
			APC_SQLClose(apc_DB)
			apc_closed=true
		end if
	end sub
	
	function Error() as boolean
		//- True if the last operation caused an error condition
		//- Use ErrorCode() and/or ErrorMessage() for more info
		dim ecode as integer, emsg as string
		return APC_SQLError(apc_DB,ecode,emsg)
	end function
	
	function ErrorCode() as integer
		//- Returns error code (sqlerror_ constants) if the last operation caused an error condition
		//- Use ErrorMessage() for more info
		dim ecode as integer, emsg as string
		if APC_SQLError(apc_DB,ecode,emsg) then return ecode else return 0
	end function
	
	function ErrorMessage() as string
		//- Returns error message if the last operation caused an error condition
		//- Use ErrorCode() for more info
		dim ecode as integer, emsg as string
		if APC_SQLError(apc_DB,ecode,emsg) then return emsg else return ""
	end function
	
	sub SQLExecute(stmt as string)
		//- Execute the specified SQL statement/s
		if apc_DB>=0 and not apc_closed then APC_SQLExecute(apc_DB,stmt)
	end sub
	
	function SQLSelect(stmt as string) as SQLRecordSet
		//- Execute the specified SQL SELECT statement, returning a (possibly empty) record set
		if apc_DB<0 or apc_closed then return nil
		dim rs as integer=APC_SQLSelect(apc_DB,stmt)
		if rs<0 then return nil else return new SQLRecordSet(rs)
	end function
	
	function TableSchema() as SQLRecordSet
		//- Returns a record set with a list of all tables in the database.
		if apc_DB<0 or apc_closed then return nil
		dim rs as integer=APC_SQLTableSchema(apc_DB)
		if rs<0 then return nil else return new SQLRecordSet(rs)
	end function
	
	function IndexSchema(tablename as string) as SQLRecordSet
		//- Returns a record set containing the list of indexes for the passed table
		//- or Nil if the table has no indexes or the database source does not support indexes.
		if apc_DB<0 or apc_closed then return nil
		dim rs as integer=APC_SQLIndexSchema(apc_DB,tablename)
		if rs<0 then return nil else return new SQLRecordSet(rs)
	end function
	
	function FieldSchema(tablename as string) as SQLRecordSet
		//- Returns a record set containing information about all fields in the table.
		if apc_DB<0 or apc_closed then return nil
		dim rs as integer=APC_SQLFieldSchema(apc_DB,tablename)
		if rs<0 then return nil else return new SQLRecordSet(rs)
	end function
	
	sub Commit()
		//- Commit any outstanding write operations to the database
		if apc_DB>=0 then APC_SQLCommit(apc_DB)
	end sub
	
	sub Rollback()
		//- Cancel any outstanding write operations to the database (since the last commit).
		if apc_DB>=0 then APC_SQLRollback(apc_DB)
	end sub
	
	sub Close()
		//- Close the database. 
		//- Note that this will be done automatically when the object is destroyed.
		if apc_DB>=0 then APC_SQLClose(apc_DB)
		apc_closed=true
	end sub
	
	sub InsertRecord(tableName as string, r as SQLRecord)
		//- Insert new record into specified table
		if apc_DB>=0 then APC_SQLInsert(apc_DB,tableName,r.Encode)
	end sub
	
end class

//------------------------------------------------------------------------------------
class SQLiteDatabase
	// Documented 7/4/2012
	//- This class encapsulates the creation and accessing of local SQLite databases.
	//- Instantiation: dim d as new SQLiteDatabase(path, create)
	inherits SQLDatabase

	const sqlerror_LogicError = 1    // SQL logic error or missing database
	const sqlerror_Internal = 2    // Internal SQLite implementation flaw
	const sqlerror_Access = 3    // Access permission denied
	const sqlerror_Callback = 4    // Callback requested query abort
	const sqlerror_DBLocked = 5    // Database is locked
	const sqlerror_TableLocked = 6    // Database table is locked
	const sqlerror_Memory = 7    // Out of memory
	const sqlerror_ReadOnly = 8    // Attempt to write a readonly database
	const sqlerror_Interrupted = 9    // Interrupted
	const sqlerror_IO = 10    // Disk I/O error
	const sqlerror_Image = 11    // Database disk image is malformed
	const sqlerror_NotFound = 12    // Table or record not found
	const sqlerror_Full = 13    // Database is full
	const sqlerror_Open = 14    // Unable to open database file
	const sqlerror_Locking = 15    // Database locking protocol failure
	const sqlerror_NoData = 16    // Table contains no data
	const sqlerror_Schema = 17    // Database schema has changed
	const sqlerror_TooMuchData = 18    // Too much data for one table row
	const sqlerror_Constraint = 19    // Constraint failed
	const sqlerror_Mismatch = 20    // Datatype mismatch
	const sqlerror_Library = 21    // Library routine called out of sequence
	const sqlerror_LargeFile = 22    // Kernel lacks large file support
	const sqlerror_Authorization = 23    // Authorization denied
	const sqlerror_Format = 24    // Auxiliary database format error
	const sqlerror_Index = 25    // Bind or column index out of range
	const sqlerror_Encrypted = 26    // File is encrypted or is not a database

	sub Constructor(optional path as string = "", optional createNew as boolean = false)
	  //- If path="" and createNew=false then you'll be asked to select a SQLite database file to open
	  //- If path<>"" and createNew=false then the SQLite database file specified in path will be opened
	  //- If path="" and createNew=true you'll be asked to select a SQLite database file path to create
	  //- If path<>"" and createNew=true then the SQLite database file specified in path will be created (deleting any existing file)
	  //-
	  //- If path<>"" and starts with "memory" and createNew=true then an in-memory SQLite database will be created. 
	  //- Note that this database will remain available to subsequent runs of the script, or other scripts, 
	  //- until either recreated via an identical Constructor call, or the app quits.
	  //- If path<>"" and starts with "memory" and createNew=false then the in-memory database created previously 
	  //- in this or another run will be used. If no such database is present, a new one will be created. 
  		apc_DB=APC_SQLOpenSQLite(path,createnew)
  		apc_closed=false
	end sub
	
	function Path() as string
		//- Returns file path to database
		return APC_SQLPath(apc_DB)
	end function
	
end class

//------------------------------------------------------------------------------------
class MySQLDatabase
	inherits SQLDatabase
	// Documented 7/4/2012
	//- Connects to MySQL Community Server databases
	
	sub Constructor(host as string, port as integer, dbname as string, username as string, password as string)
		//- host is the server Internet address (e.g. "mysql.whatever.org").
		//- port is the port number to connect to (typically 3306).
		//- dbname is the name of your database on the server (e.g. "Users").
		//- username is your database login name.
		//- password is your database login password.
		
	  apc_DB=APC_SQLOpenMySQL(host,port,dbname,username,password)
  	apc_closed=false
	end sub
	
end class

//------------------------------------------------------------------------------------
class Date
	// Documented 7/3/2012
	//- Represents and manipulates a date/time
	//- Objects of this class can be used interchangeably with date/times as doubles or strings:
	//- e.g. 
	//- dim d as Date = Plan().LocalDateTime
  //- d.Year=d.Year+1
  //- Plan().LocalDateTime = d
  //- print d
  //-
  //- Two dates can be compared directly:
  //- dim d1,d2 as Date
  //- if d1>=d2 then ...
  //- 
  //- Seconds can be added to a date directly
  //- dim d as new Date
  //- d = d + 3600.0 // Add an hour
	implements NamedObject
	
	private dim t as double
	
	sub Constructor()
		//- Default constructor makes a Date with the current local date/time
		t=APC_CurrentDate
	end sub
	
	sub Constructor(d as Date)
		//- Makes a Date the same as d
		t=d.TotalSeconds
	end sub
	
	sub Constructor(dt as double)
		//- Makes a Date with the specified date/time in seconds
		//- If dt<24 then dt is assumed to be time in hours and the date will be initialised
		//- to the current date and the specified time.
		if abs(dt)<24.0 then
			dim d as new Date
			d.Hour=0
			d.Minute=0
			d.Second=0
			t=d.TotalSeconds+dt*3600.0
		else
			t=dt
		end if
	end sub
	
	sub Constructor(year as integer, month as integer, day as integer, optional hour as integer = 0, optional minute as integer = 0, optional second as integer = 0)
		//- Makes a Date with the specified date/time
		t=APC_SetDate(t,year,month,day,hour,minute,second)
	end sub
	
	function Year() as integer
		dim y,m,d,h,mn,s as integer
		APC_GetDate(t,y,m,d,h,mn,s)
		return y
	end function
	
	sub Year(assigns y as integer)
		t=APC_SetDate(t,y,-1,-1,-1,-1,-1)
	end sub
	
	function Month() as integer
		dim y,m,d,h,mn,s as integer
		APC_GetDate(t,y,m,d,h,mn,s)
		return m
	end function
	
	sub Month(assigns m as integer)
		t=APC_SetDate(t,-1,m,-1,-1,-1,-1)
	end sub
	
	function Day() as integer
		dim y,m,d,h,mn,s as integer
		APC_GetDate(t,y,m,d,h,mn,s)
		return d
	end function
	
	sub Day(assigns d as integer)
		t=APC_SetDate(t,-1,-1,d,-1,-1,-1)
	end sub
	
	function Hour() as integer
		dim y,m,d,h,mn,s as integer
		APC_GetDate(t,y,m,d,h,mn,s)
		return h
	end function
	
	sub Hour(assigns h as integer)
		t=APC_SetDate(t,-1,-1,-1,h,-1,-1)
	end sub
	
	function Minute() as integer
		dim y,m,d,h,mn,s as integer
		APC_GetDate(t,y,m,d,h,mn,s)
		return mn
	end function
	
	sub Minute(assigns m as integer)
		t=APC_SetDate(t,-1,-1,-1,-1,m,-1)
	end sub
	
	function Second() as integer
		dim y,m,d,h,mn,s as integer
		APC_GetDate(t,y,m,d,h,mn,s)
		return s
	end function
	
	sub Second(assigns s as integer)
		t=APC_SetDate(t,-1,-1,-1,-1,-1,s)
	end sub
	
	function ShortDate() as string
		//- Returns date as a short string (e.g. in the US:  10/31/12)
		return APC_FormattedDate(t,1)
	end function
	
	function LongDate() as string
		//- Returns date as a long string (e.g. in the US:  Wednesday, July 4, 2012)
		return APC_FormattedDate(t,2)
	end function
	
	function ShortTime() as string
		//- Returns time as a short string (e.g.  12:23 pm)
		return APC_FormattedDate(t,3)
	end function
	
	function LongTime() as string
		//- Returns time as a long string (e.g.  12:23:46 pm)
		return APC_FormattedDate(t,4)
	end function
	
	function SQLDate() as string
		//- Returns date as a standard SQL string (e.g.  2012-07-04)
		return APC_FormattedDate(t,5)
	end function
	
	function SQLDateTime() as string
		//- Returns date and time as a standard SQL string (e.g.  2012-07-04 12:23:55)
		return APC_FormattedDate(t,6)
	end function
	
	function ObjectName() as string // private
		return ShortDate+"  "+ShortTime
	end function
	
	function TotalSeconds() as double
		//- Returns the current date/time in seconds (based at 12:00AM, January 1, 1904.)
		return t
	end function
	
	sub TotalSeconds(assigns s as double)
		t=s
	end sub
	
	function JulianDate() as double
		return APC_ToJulian(t)
	end function
	
	sub JulianDate(assigns jd as double)
		t=APC_FromJulian(jd)
	end sub
	
	function DayOfYear() as integer
		return APC_DateStuff(t,1)
	end function
	
	function DayOfWeek() as integer
		return APC_DateStuff(t,2)
	end function
	
	function WeekOfYear() as integer
		return APC_DateStuff(t,3)
	end function
	
	// Conversion stuff
	
	function Operator_Compare(rhs as Date) as Integer // private
		// Allows direct comparison twixt Dates
		if t<rhs.t then return -1
		if t>rhs.t then return 1
		return 0
	end function
	
	sub Operator_Convert(rhs as double) // private
		// Allows direct assignment of a double date/time value
		t=rhs
	end sub
	
	function Operator_Convert() as double // private
		// Allows direct assignment of a Date to a double
		return t
	end function

	sub Operator_Convert(rhs as string) // private
		// Allows direct assignment of a string date/time value
		if IsNumeric(rhs) then
	  	t=CDbl(rhs)
	  else
			dim d as Date = ParseDate(rhs)
			if d=nil then t=0 else t=d.t
	  end if
	end sub
	
	function Operator_Convert() as string // private
		// Allows direct assignment of a Date to a string
		return SQLDateTime
	end function
	
	function Operator_Add(rhs as double) as Date // private
		// Allows adding a number of seconds to a date
		dim d as new Date
		d.t=t+rhs
		return d
	end function
	
	function Operator_AddRight(lhs as double) as Date // private
		// Allows adding a date to a number of seconds
		dim d as new Date
		d.t=lhs+t
		return d
	end function
	
	function Operator_Subtract(rhs as double) as Date // private
		// Allows subtracting a number of seconds from a date
		dim d as new Date
		d.t=t-rhs
		return d
	end function
	
	function Operator_SubtractRight(lhs as double) as Date // private
		// Allows subtracting a date from a number of seconds
		dim d as new Date
		d.t=lhs-t
		return d
	end function
	
	function Operator_Subtract(rhs as Date) as double // private
		// Allows subtracting two dates (giving difference in seconds)
		return t-rhs.t
	end function
		
	// Shared stuff
	
	shared function ParseDate(s as string) as Date
		//- Parse a date in a string and return a Date object, or nil if the string is not a recognised date format.
		dim t as double = APC_ParseDate(s)
		if t<=0.0 then return nil else return new Date(t)
	end function
	
	shared function ParseTime(s as string) as Date
		//- Parse a time in a string and return a Date object, or nil if the string is not a recognised time format.
		dim t as double = APC_ParseTime(s)
		if t<0.0 then return nil else return new Date(t)
	end function
	
	shared function DaysInMonth(month as integer, year as integer) As integer
		//- For the given month and year, return the number of days in that month.
		return APC_DaysInMonth(month,year)
	end Function

	shared function DayAbbreviations() As string()
		//- Return a 7-element array containing localised short names for the days of the week (e.g. "Sun", "Mon",..., "Sat")
		return APC_DayAbbreviations
	end function

	shared function DayNames() As string()
		//- Return a 7-element array containing localised full names for the days of the week (e.g. "Sunday", "Monday",..., "Saturday")
		return APC_DayNames
	end function

	shared function MonthAbbreviations() As string()
		//- Return a 12-element array containing localised short names for the months of the year (e.g. "Jan", "Feb",..., "Dec")
		return APC_MonthAbbreviations
	end function

	shared function MonthNames() As string()
		//- Return a 12-element array containing localised full names for the months of the year (e.g. "January", "February",..., "December")
		return APC_MonthNames
	end function

end class

//------------------------------------------------------------------------------------
class RegExOptions
	// Documented 7/3/2012
	//- Used to specify options when doing a search using regular expressions.
	//- Instatiation: Do not create new instances of this class. Get an instance via Regex.Options and modify that.
	
	dim CaseSensitive as boolean
	//- Specifies if case is to be considered when matching a string. The default is False.
	dim DotMatchAll as boolean
	//- Normally the period matches everything except a new line, this option allows it to match new lines. The default is False.
	dim Greedy as boolean
	//- Greedy means the search finds everything from the beginning of the first delimiter to end of the last delimiter and everything in-between.
	dim LineEndType as integer
	//- Changes the way \n is expanded for ReplacementPatterns. It is in effect for the current Regular Expression "session."
	//- This property has no effect on SearchPatterns if TreatTargetAsOneLine is True.
	//- LineEndType can take on the following values:
	//- 0 - Any line ending (Windows, Macintosh, or Unix). This is the default.
	//- 1 - The default for the current platform. If running on Macintosh, the same as 2; if running on Windows, the same as 3, if running on Linux, the same as 4.
	//- 2 - Mac ASCII 13 or \r
	//- 3 - Win32 ASCII 10 or \n
	//- 4 - Unix ASCII 10 or \n
	dim MatchEmpty as boolean
	//- Indicates whether patterns are allowed to match the empty string. The default is True.
	dim ReplaceAllMatches as boolean
	//- Indicates whether all occurrences of the pattern are to be replaced. The default is False.
	dim StringBeginIsLineBegin as boolean
	//- Indicates whether a string’s beginning should be counted as the beginning of a line. The default is True.
	dim StringEndIsLineEnd as boolean
	//- Indicates whether a string's end should be counted as the end of a line. The default is True.
	dim TreatTargetAsOneLIne as boolean
	//- Ignores internal newlines for purposes of matching against '^' and '$'. The default is False.
	
	sub Constructor() // private
		Greedy = true
		MatchEmpty = true
		StringBeginIsLineBegin = true
		StringEndIsLineEnd = true
	end sub
	
	function AsString() as string // private
		dim op(8) as string
		if CaseSensitive then op(0)="1"
		if DotMatchAll then op(1)="1"
		if Greedy then op(2)="1"
		op(3)=str(LineEndType)
		if MatchEmpty then op(4)="1"
		if ReplaceAllMatches then op(5)="1"
		if StringBeginIsLineBegin then op(6)="1"
		if StringEndIsLineEnd then op(7)="1"
		if TreatTargetAsOneLine then op(8)="1"
		return Join(op,chr(1))
	end function
	
end class

//------------------------------------------------------------------------------------
class RegExMatch
	// Documented 7/3/2012
	//- Used to extract the matched string when doing a search with regular expressions.
	//- Instantiation: Do not create new instances of this class. Get an instance via Regex.Search().
	
	private dim idx as integer
	private dim repPat as string
	
	private sub Constructor()
	end sub

	sub Constructor(n as integer, rp as string) // private
		idx=n
		repPat=rp
	end sub
	
	function SubExpressionCount( ) as integer
		//- Number of SubExpressions that are available with the search just performed.
		//- AstroPlanner's Regular Expressions support both \number and $number syntax for SubExpressions.
		//- SubExpressions allow replacement of parts of the pattern.
		return APC_RegExMatch_SubExpressionCount(idx)
	end function
	
	function SubExpressionStartB(optional MatchNumber as integer = 0) as integer
		//- Returns the starting byte offset of the SubExpression given by matchNumber. SubExpressionStartB is zero-based.
		return APC_RegExMatch_SubExpressionStartB(idx,MatchNumber)
	end function
	
	function SubExpressionString(optional MatchNumber as integer = 0) as string
		//- Returns the SubExpression as a String for the passed matchNumber.
		//- NOTE: 0 returns the entire MatchString (the implicit 0th SubExpression), and 1 is the first real SubExpression.
		return APC_RegExMatch_SubExpressionString(idx,MatchNumber)
	end function
	
	function Replace(optional ReplacementPattern as string = "") as string
		//- Substitutes the matched result in a manner specified by the given ReplacementPattern.
		dim rp as string
		if ReplacementPattern="" then rp=repPat else rp=ReplacementPattern
		return APC_RegExMatch_Replace(idx,rp)
	end function
	
end class

//------------------------------------------------------------------------------------
class RegEx
	// Documented 7/3/2012
	//- Used to do search and replace operations using regular expressions (i.e., perl). The RegEx class uses the current version of the PCRE library, 7.7.
	//- Instantiation: dim r as new RegEx
	
	dim ReplacementPattern as string
	//- This is the replacement string, which can include references to substrings matched previously, via the standard '\1' or '$1' notation common in regular expressions.
	dim SearchPattern as string
	//- This is the pattern you are currently searching for.
	dim SearchStartPosition as integer
	//- The byte offset (zero-based) at which you want to start the search if the optional TargetString parameter to Replace is not specified.
	
	private dim opt as RegExOptions
	private dim idx as integer
	
	sub Constructor()
		opt=new RegExOptions
		idx=APC_Regex_New
	end sub
	
	sub Destructor() // private
		APC_Regex_Destroy(idx)
	end sub
		
	function Options() as RegExOptions
		//- These options are various states which you can set for the Regular Expressions engine. See the RegExOptions class.
		return opt
	end function
	
	function Replace(optional TargetString as string = "", optional SearchStartPosition as integer = -1) as string
		//- Finds SearchPattern in TargetString and Replaces the contents of SearchPattern with ReplacementPattern.
		//- Returns the resulting String. Replace can take the optional parameters SearchPattern and TargetString.
		dim ssp as integer
		if SearchStartPosition=-1 then ssp = me.SearchStartPosition else ssp=SearchStartPosition
		return APC_Regex_Replace(idx,opt.AsString,ReplacementPattern,SearchPattern,ssp,TargetString)
	end function
	
	function Search(optional TargetString as string = "", optional SearchStartPosition as integer = -1) as RegExMatch
		//- Finds SearchPattern in TargetString, beginning at SearchStartPosition.
		//- SearchStartPosition is zero-based.

		dim ssp as integer
		if SearchStartPosition=-1 then ssp = me.SearchStartPosition else ssp=SearchStartPosition
		APC_Regex_Search(idx,opt.AsString,ReplacementPattern,SearchPattern,ssp,TargetString)
		return new RegExMatch(idx,ReplacementPattern)
	end function
	
end class

//------------------------------------------------------------------------------------
class Annotation
	// Documented 7/3/2012
	//- Encapsulates an Annotation object
	//- Instantiation: DO NOT instantiate objects of this class. Use the shared methods only.
	implements NamedObject
	
	private Idx as integer
	
	private sub Constructor()
	end sub
	
	function ObjectName() as string // private
		return ID
	end function
	
	function ID() as string
		//- ID assigned to the annotation (might be a synonym)
		return APC_Annotation_GetField(Idx,"ID")
	end function
	
	sub ID(assigns s as string)
		//- ID assigned to the annotation (might be a synonym)
		APC_Annotation_SetField(Idx,"ID",s)
	end sub
	
	function Notes() as string
		return APC_Annotation_GetField(Idx,"Notes")
	end function
	
	sub Notes(assigns s as string)
		//- Notes assigned to the annotation
		APC_Annotation_SetField(Idx,"Notes",s)
	end sub
	
	function OtherIDs() as string
		return APC_Annotation_GetField(Idx,"OtherIDs")
	end function
	
	sub OtherIDs(assigns s as string)
		//- OtherIDs assigned to the annotation
		APC_Annotation_SetField(Idx,"OtherIDs",s)
	end sub
	
	sub Delete()
		//- Deletes this annotation. Note that after this method has been called, this object
		//- should no longer be referenced in any way.
		APC_Annotation_Delete(Idx,ID)
	end sub
	
	shared function Count() as integer
		//- Total number of Annotations in the database
		return APC_Annotation_Count
	end function
	
	shared function Get(n as integer) as Annotation
		//- Get the n-th Annotation from the database, n = 1, 2, ... Count
		dim ann as new Annotation
		ann.Idx=APC_Annotation_NthIdx(n)
		if ann.Idx>0 then return ann else return nil
	end function
	
	shared function ForID(ID as string) as Annotation()
		//- Return all Annotations for the given ID (and hence its synonyms as well)
		dim idx() as integer = APC_Annotation_ForID(id)
		dim ann(-1),a as Annotation
		for i as integer = 0 to ubound(idx)
			a = new Annotation
			a.Idx=idx(i)
			ann.Append a
		next
		return ann
	end function
	
	shared function Create(ID as string, optional Notes as string = "", optional OtherIDs as string = "") as Annotation
		//- Create a new Annotation for the specified ID (and hence its synonyms as well).
		dim idx as integer = APC_Annotation_Create(ID,Notes,OtherIDs)
		if idx>0 then
			dim ann as new Annotation
			ann.Idx=idx
			return ann 
		else 
			return nil
		end if
	end function
	
end class

//------------------------------------------------------------------------------------
class Pair
	// Documented 7/3/2012
	//- This is a convenience class that encapsulates a pair of variants. It is used by other
	//- framework classes, but can be used by user scripts as well.
	//- Instantiation: dim p as new Pair(l,r)
	
	dim left as Variant
	dim right as Variant
	
	sub Constructor(l as Variant, r as Variant)
		left=l
		right=r
	end sub
	
end class
	
//------------------------------------------------------------------------------------
class Dictionary_Old // private
	// Documented 7/3/2012
	//- Dictionary class - functionally equivalent to the REALbasic one, except:
	//- a. No BinCount property (yet).
	//- b. Value(key) will return nil if key not found, rather than triggering an exception.
	//- c. Key(Index) will return nil if Index is out-of-bounds, rather than triggering an exception.
	//- d. Remove(key) will not trigger an exception if key not found.
	//- Instantiation:  dim d as new Dictionary
	
	private dim hash(-1) as integer
	private dim item(-1) as Pair
	
	function Count() as integer
		//- Return number of items stored in the dictionary
		return ubound(item)+1
	end function
	
	sub Value(key as Variant, assigns v as Variant)
		//- Assign an item by key to the dictionary
		if key is nil then return
		dim h as integer = key.Hash
		dim i as integer = hash.IndexOf(h)
		dim p as new Pair(key,v)
		if i<0 then
			hash.Append h
			item.Append p
		else
			item(i) = p
		end if
	end sub
	
	function Value(key as Variant) as Variant
		//- Retrieve an item by key from the dictionary. Return nil if not found
		if key is nil then return nil
		dim i as integer = hash.IndexOf(key.Hash)
		if i>=0 then return item(i).right else return nil
	end function
	
	sub Clear()
		//- Clear all items from the dictionary.
		redim hash(-1)
		redim item(-1)
	end sub
	
	function HasKey(key as Variant) as boolean
		//- Return TRUE if an item with the given key exists in the dictionary
		return hash.IndexOf(key.Hash)>=0
	end function
	
	function Key(Index as integer) as Variant
		//- Return the Index-th key from the dictionary. Index = 0, 1, ... Count-1
		if Index>=0 and Index<=ubound(item) then return item(Index).Left
	end function
	
	function Keys() as Variant()
		//- Return an array containing all the keys in the dictionary (in 1-to-1 correspondence with Values())
		dim v(-1) as Variant
		redim v(ubound(item))
		for i as integer = 0 to ubound(item)
			v(i)=item(i).left
		next
		return v
	end function
	
	function Values() as Variant()
		//- Return an array containing all the values in the dictionary (in 1-to-1 correspondence with Keys())
		dim v(-1) as Variant
		redim v(ubound(item))
		for i as integer = 0 to ubound(item)
			v(i)=item(i).right
		next
		return v
	end function
	
	function Lookup(key as Variant, default as Variant) as Variant
		//- If a value with the given key exists, return it, otherwise return default
		if HasKey(key) then return Value(key) else return default
	end function
	
	sub Remove(key as Variant)
		//- Remove the item with the given key from the dictionary
		dim i as integer = hash.IndexOf(key.Hash)
		if i>=0 then
			hash.Remove i
			item.Remove i
		end if
	end sub
	
end class

//------------------------------------------------------------------------------------
Class DictionaryBinEntry // private
Dim Keys() As Variant
Dim Values() As Variant
End Class


Class Dictionary
	// Documented 5/4/2014
	//- Dictionary class - functionally equivalent to the REALbasic/Xojo one.
	//- Instantiation:  dim d as new Dictionary or new Dictionary(binCount)
	
  Private Const kDefaultBinUbound = 500 // Makes Bin Count an odd number
  
  Private zBin() As DictionaryBinEntry
  Private zBinUbound As Integer
  Private zBinCount As Integer
  Private zCount As Integer
  
  // Private Methods
  Private Function VariantIndexOf ( variantArr() As Variant, value As Variant ) As Integer
    // Need this because native IndexOf is case-sensitive with Variants
    dim i as integer
    for i = 0  to variantArr.Ubound
      if variantArr( i ) = value then
        return i
      end if
    next i
    return -1 // Not found
  End Function

  Private Function pBinIndex ( key As Variant ) as Integer
    return key.Hash mod zBinCount
  End Function
  
  Private Function pBinEntry ( key As Variant, ByRef binIndex As Integer ) As DictionaryBinEntry
    binIndex  = pBinIndex( key )
    return zBin( binIndex )
  End Function
  
  Private Function pBinEntry ( key As Variant ) As DictionaryBinEntry
    dim binIndex as Integer = pBinIndex( key )
    return zBin( binIndex )
  End Function
  
  // Constructor
  Sub Constructor(optional binCount As Integer = 0)
  	//- Create a new dictionary. If binCount is <= 0 then choose a default binCount value.
    if binCount < 1 then
      zBinUbound = kDefaultBinUbound
    else
      zBinUbound = binCount - 1
    end if
    redim zBin( zBinUbound )
    zBinCount = zBinUbound + 1
  End Sub
  
  // Value
  Function Value(key As Variant) As Variant
  	//- Retrieve an item by key from the dictionary. Raise exception if missing.
    dim binEntry as DictionaryBinEntry = pBinEntry( key )
    dim keyIndex as Integer = VariantIndexOf( binEntry.Keys, key )
    return binEntry.Values( keyIndex )
  End Function
  
  Sub Value(key As Variant, Assigns value As Variant)
  	//- Assign an item by key to the dictionary
    dim binIndex as Integer
    dim binEntry as DictionaryBinEntry = pBinEntry( key, binIndex )
    
    dim keyIndex as Integer
    if binEntry is nil then
      binEntry = new DictionaryBinEntry
      keyIndex = -1
    else
      keyIndex = VariantIndexOf( binEntry.Keys, key )
    end if
    
    if keyIndex = -1 then // New entry
      binEntry.Keys.Append key
      binEntry.Values.Append value
      zCount = zCount + 1
    else
      binEntry.Values( keyIndex ) = value
    end if
    
    zBin( binIndex ) = binEntry
  End Sub
  
  Function Lookup(key As Variant, default As Variant) As Variant
  	//- If a value with the given key exists, return it, otherwise return default
    dim binEntry as DictionaryBinEntry = pBinEntry( key )
    if binEntry is nil or binEntry.Keys.Ubound = -1 then return default
    dim keyIndex as Integer = VariantIndexOf( binEntry.Keys, key )
    if keyIndex = -1 then
      return default
    else
      return binEntry.Values( keyIndex )
    end if
  End Function
  
  Function HasKey(key As Variant) As Boolean
  	//- Return TRUE if an item with the given key exists in the dictionary
    dim binEntry as DictionaryBinEntry = pBinEntry( key )
    if binEntry is nil or binEntry.Keys.Ubound = -1 then return false
    return VariantIndexOf( binEntry.Keys, key ) <> -1
  End Function
  
  Sub Remove(key As Variant)
  	//- Remove the item with the given key from the dictionary
    dim binIndex as Integer
    dim binEntry as DictionaryBinEntry = pBinEntry( key, binIndex )
    dim keyIndex as integer = VariantIndexOf( binEntry.Keys, key )
    binEntry.Keys.Remove keyIndex
    binEntry.Values.Remove keyIndex
    zCount = zCount - 1
  End Sub
  
  Function Keys() As Variant()
  	//- Return an array containing all the keys in the dictionary (in 1-to-1 correspondence with Values())
    dim k() as Variant
    dim binEntry as DictionaryBinEntry
    dim binIndex as Integer
    for binIndex = 0 to zBin.Ubound
      binEntry = zBin( binIndex )
      if binEntry <> nil then
        dim allKeys() as Variant = binEntry.Keys
        dim keyIndex as Integer
        for keyIndex = 0 to allKeys.Ubound
          k.Append allKeys( keyIndex )
        next keyIndex
      end if
    next binIndex
    return k
  End Function
  
  Function Values() As Variant()
  	//- Return an array containing all the values in the dictionary (in 1-to-1 correspondence with Keys())
    dim v() as Variant
    dim binEntry as DictionaryBinEntry
    dim binIndex as Integer
    for binIndex = 0 to zBin.Ubound
      binEntry = zBin( binIndex )
      if binEntry <> nil then
        dim allKeys() as Variant = binEntry.Values
        dim valueIndex as Integer
        for valueIndex = 0 to allKeys.Ubound
          v.Append allKeys( valueIndex )
        next valueIndex
      end if
    next binIndex
    return v
  End Function
  
  function Key(Index as integer) as Variant
		//- Return the Index-th key from the dictionary. Index = 0, 1, ... Count-1
		dim idx as integer = 0
    dim binEntry as DictionaryBinEntry
    dim binIndex as Integer
    for binIndex = 0 to zBin.Ubound
      binEntry = zBin( binIndex )
      if binEntry <> nil then
        dim allKeys() as Variant = binEntry.Values
        dim valueIndex as Integer
        for valueIndex = 0 to allKeys.Ubound
        	if idx=Index then return allKeys( valueIndex )
          idx = idx + 1
        next valueIndex
      end if
    next binIndex
    return nil
	end function
  
  Function Count() As Integer
  	//- Return number of items stored in the dictionary
    return zCount
  End Function
  
  Sub Clear()
  	//- Clear all items from the dictionary.
    redim zBin( -1 )
    redim zBin( zBinUbound )
    zCount = 0
  End Sub
    
End Class

//------------------------------------------------------------------------------------
class TextEncoding
	// Documented 7/3/2012
	//- Set or convert the text encoding of strings
	//- Instantiation: DO NOT instantiate objects of this class. Use the shared methods only.
	
	const ASCII = "ASCII"
	const MacRoman = "MacRoman"
	const UTF16 = "UTF16"
	const UTF16BE = "UTF16BE"
	const UTF16LE = "UTF16LE"
	const UTF32BE = "UTF32BE"
	const UTF32LE = "UTF32LE"
	const UTF8 = "UTF8"
	const WindowsANSI = "WindowsANSI"
	
	shared function DefineEncoding(s as string, encoding as string) as string
		//- Define the string s to have the given encoding (using TextEncoding constants).
		//- Note that this does not change the string's contents.
		//- The original string is left untouched.
		return APC_DefineEncoding(s,encoding)
	end function
	
	shared function ConvertEncoding(s as string, encoding as string) as string
		//- Convert the string s to the given encoding (using TextEncoding constants).
		//- The original string is left untouched.
		return APC_ConvertEncoding(s,encoding)
	end function 
	
end class

//------------------------------------------------------------------------------------
class Screen
	// Documented 7/3/2012
	//- Get parameters for the screens connected to your computer (Screen 0 is the main screen)
	//- Instantiation: DO NOT instantiate objects of this class. Use the shared methods only.
	
  private sub Constructor()
  end sub
  
  shared function nScreens() as integer
  	//- Return the number of screens connected to the computer
    return APC_Screen(0,0)
  end function

  shared function AvailableHeight(optional screenNumber as integer = 0) as integer
  	//- Return the available height of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,1)
  end function

  shared function AvailableLeft(optional screenNumber as integer = 0) as integer
  	//- Return the available left coordinate of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,2)
  end function

  shared function AvailableTop(optional screenNumber as integer = 0) as integer
  	//- Return the available top coordinate of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,3)
  end function

  shared function AvailableWidth(optional screenNumber as integer = 0) as integer
  	//- Return the available width of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,4)
  end function

  shared function Depth(optional screenNumber as integer = 0) as integer
  	//- Return the pixel depth of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,5)
  end function

  shared function Height(optional screenNumber as integer = 0) as integer
  	//- Return the height of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,6)
  end function

  shared function Left(optional screenNumber as integer = 0) as integer
  	//- Return the left coordinate of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,7)
  end function

  shared function Top(optional screenNumber as integer = 0) as integer
  	//- Return the top coordinate of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,8)
  end function

  shared function Width(optional screenNumber as integer = 0) as integer
  	//- Return the width of the specified screen, screenNumber = 0...nScreens-1
    return APC_Screen(screenNumber,9)
  end function
  
end class

//------------------------------------------------------------------------------------
interface TelescopeControl
  //- This interface is used only in Telescope Control scripts.
  //- The user is required to define a class that implements this interface.
  
	function CanGet(item as integer) as boolean
		//- Return TRUE if the telescope supports retrieving the specified item. 
		//- The item parameter will be one of the TelescopeController.item_ constants.
	//# end function
	
	function CanSet(item as integer) as boolean
		//- Return TRUE if the telescope supports sending the specified item to the telescope. 
		//- The item parameter will be one of the TelescopeController.item_ constants.
	//# end function
	
	function Get(item as integer, params() as string) as string
		//- Return the value of the specified item as a string. Multiple values should be tab-separated.
		//- params may be passed, depending on the item.
		//- The item parameter will be one of the TelescopeController.item_ constants.
	//# end function
	
	function Set(item as integer, params() as string) as string
		//- Set the specified item, using the params where required.
		//- A value may be returned as a string. Multiple values should be tab-separated. 
		//- The item parameter will be one of the TelescopeController.item_ constants.
	//# end function
	
	sub Restore()
		//- Called before any action to allow restoration of any non-volatile parameters
	//# end sub
	
	sub Save()
		//- Called at end of script to allow saving of any non-volatile parameters
	//# end sub
end interface

//------------------------------------------------------------------------------------
class TelescopeController
	//- This class is only used in Telescope Control scripts.
	//- The user is expected to call the shared Run() method,
	//- passing in an instance of a user class that implements the TelescopeControl interface.
	
	const item_Altitude = 0
	const item_Azimuth = 1
	const item_AltAz = 2
	const item_DaylightSavings = 3
	const item_GMTOffset = 4
	const item_Latitude = 5
	const item_Longitude = 6
	const item_LocalDate = 7
	const item_LocalTime = 8
	const item_SiderealTime = 9
	const item_RAAntiBacklash = 10
	const item_DecAntiBacklash = 11
	const item_SlewRate = 12
	const item_TrackingEnable = 13
	const item_TrackingRate = 14
	const item_TrackingRateLunar = 15
	const item_TrackingRateManual = 16
	const item_TrackingRateSidereal = 17
	const item_TrackingRateFixed = 18
	const item_TrackingRateSolar = 19
	const item_Derotator = 20
	const item_Fan = 21
	const item_Focus = 22
	const item_FocusSpeed = 23
	const item_FocusPreset = 24
	const item_FocusPosition = 25
	const item_Collimation = 26
	const item_ReticleBlinkRate = 27
	const item_ReticleBlinkRateMax = 28
	const item_ReticleDutyCycle = 29
	const item_ReticleBrightness = 30
	const item_RA = 31
	const item_Dec = 32
	const item_RADec = 33
	const item_Sleep = 34
	const item_Wake = 35
	const item_StartAlignment = 36
	const item_ResetPower = 37
	const item_Version = 38
	const item_Sync = 39
	const item_SyncTo = 40
	const item_SlewToRADec = 41
	const item_Move = 42
	const item_MoveRate = 43
	const item_MoveRateValues = 44
	const item_RAPECEnable = 45
	const item_DecPECEnable = 46
	const item_EndOfSlew = 47
	const item_CancelSlew = 48
	const item_LongFormat = 49
	const item_OTATemperature = 50
	const item_OTATemperaturePeriod = 51
	const item_OTATemperatureScale = 52
	const item_OTATemperatureTime = 53
	const item_CorrectorTemperature = 54
	const item_CorrectorHeat = 55
	const item_PanelPower = 56
	const item_SlewToHome = 57
	const item_Park = 58
	const item_ScopePalette = 59
	const item_ObjectDatabase = 60
	const item_Special1 = 61
	const item_Special2 = 62
	const item_Special3 = 63
	
	shared sub Run(scope as TelescopeControl)
		//- Handles the functionality.
		scope.Restore
		//debug APC_Telescope_GetCmd+": "+str(APC_Telescope_GetPType)
		select case APC_Telescope_GetCmd
		case "CanGet"
			APC_Telescope_SetResult(BooleanToStr(scope.CanGet(APC_Telescope_GetPType)))
		case "CanSet"
			APC_Telescope_SetResult(BooleanToStr(scope.CanSet(APC_Telescope_GetPType)))
		case "Get"
			APC_Telescope_SetResult(scope.Get(APC_Telescope_GetPType,APC_Telescope_GetItem))
		case "Set"
			APC_Telescope_SetResult(scope.Set(APC_Telescope_GetPType,APC_Telescope_GetItem))
		end select
		//debug "  Result: "+APC_Telescope_GetResult
		scope.Save
	end sub
	
	private shared function BooleanToStr(b as boolean) as string
		if b then return "1" else return "0"
	end function

end class

//------------------------------------------------------------------------------------
class PreferenceProperty
	// Documented 7/3/2012
	//- Represents a single global preferences property
	//- Instantiation: DO NOT instantiate this class. Use the PreferenceGroup methods to retrieve objects of this class.
	
	private dim vgroupName as string
	private dim vName as string
	
	private sub Constructor()
	end sub
	
	sub Constructor(gname as string, name as string) // private
		vgroupName=gname
		vName=name
	end sub
	
	function Name() as string
		//- Preference property name
		return vName
	end function
	
	function IsArray() as boolean
		//- Return TRUE if the property is an array
		return (APC_GetPreferenceType(vGroupName, vName) and Variant.TypeArray)<>0
	end function
	
	function Type() as integer
		//- Return the type of the property (see vtype_ constants)
		return APC_GetPreferenceType(vGroupName, vName) and not Variant.TypeArray
	end function
	
	function Value(optional index as integer = -1) as Variant
		//- Get the value of a preference property
		dim s as string = APC_GetPreference(vGroupName, vName, index)
		dim t as integer = val(NthField(s,chr(9),1))
		dim v as string = s.mid(s.instr(chr(9))+1)
		
		select case t
		case vtype_Boolean
			return v="1"
		case vtype_Color
			return RGB(val(NthField(v,",",1)),val(NthField(v,",",2)),val(NthField(v,",",3)))
		case vtype_Double
			return CDbl(v)
		case vtype_Integer
			return val(v)
		else
			return v
		end select
	end function
	
	sub Value(optional index as integer = -1, assigns v as Variant)
		//- Set the value of a preference property
		if v<>nil then
			dim s as string
			select case v.Type
			case vtype_Boolean
				if v then s="1" else s="0"
			case vtype_Color
				s = str(v.ColorValue.Red)+","+str(v.ColorValue.Green)+","+str(v.ColorValue.Blue)
			case vtype_Double
				s = format(v.DoubleValue,"-0.000000000")
			case vtype_Integer
				s = str(v.IntegerValue)
			else
				s = v.StringValue
			end select
			APC_SetPreference(vGroupName, vName, str(v.Type)+chr(9)+s, index)
		end if
	end sub
	
end class

//------------------------------------------------------------------------------------
class PreferenceGroup
	// Documented 7/3/2012
	//- Represents a group of preferences (e.g. FoV, Sky, etc.)
	//- Instantiation:  DO NOT instantiate this class. Use the Preferences methods to retrieve objects of this class.
	
	private dim vName as string
	private dim vProperties(-1) as PreferenceProperty
	
	private sub Constructor()
	end sub
	
	sub Constructor(name as string) // private
		vName=name
	end sub
	
	function Name() as string
		//- Name of the preferences group
		return vName
	end function
	
	function Properties() as PreferenceProperty()
		//- Returns an array of gettable/settable properties in the preferences group
		if ubound(vProperties)<0 then
			dim s() as string = APC_GetPreferenceGroupProperties(vName)
			for i as integer = 0 to ubound(s)
				vProperties.Append new PreferenceProperty(vName,s(i))
			next
		end if
		return vProperties
	end function
	
	function Item(name as string) as PreferenceProperty
		//- Get property by name
		call Properties
		for i as integer = 0 to vProperties.Ubound
			if vProperties(i).Name=name then return vProperties(i)
		next
		return nil
	end function
	
	sub Save()
		//- Save the current preference values
		APC_PreferencesSave(vName)
	end sub
	
	sub Restore()
		//- Save the current preference values
		APC_PreferencesRestore(vName)
	end sub
		
end class

//------------------------------------------------------------------------------------
class Preferences
	// Documented 7/3/2012
	//- Used to access global preferences in the application
	//- Instantiation: DO NOT instantiate this class. Use the shared methods.
	
	shared function Groups() as PreferenceGroup()
		//- Return a list of preference groups in the application
		if ubound(vGroups)<0 then
			dim s() as string = APC_GetPreferenceGroups
			for i as integer = 0 to ubound(s)
				vGroups.Append new PreferenceGroup(s(i))
			next
		end if
		return vGroups
	end function
	
	shared function Group(name as string) as PreferenceGroup
		//- Return named preference group
		call Groups
		for i as integer = 0 to vGroups.Ubound
			if vGroups(i).Name=name then return vGroups(i)
		next
    return nil
	end function
	
	private shared dim vGroups(-1) as PreferenceGroup
end class

//------------------------------------------------------------------------------------
class Image
	// Documented 7/3/2012
	//- Access fields of the image database
	//- Do not create new instances of this class. Use the Get() shared function
	//- WARNING: Setting values of Image properties can cause database corruption, blindness, loss of life, etc.
	implements NamedObject
	
	private idx as integer
	private shared dim cachedImg as Image
	private shared dim cachedImgIdx as integer
	
	sub Constructor(n as integer) // private
		idx=n-1
	end sub
	
	function APC_Img_Index() as integer // private
		return val(APC_Image_Get(idx,"Idx"))
	end function
	
	private Function BooleanToStr(b as boolean) As string
	  if b then
	    return "True"
	  else
	    return "False"
	  end if
	End Function

	private Function StrToBoolean(s as string) As boolean
	  return s="T" or s="True" or s="Y" or s="Yes" or s="1"
	End Function

	function ID() as string
		//- ID associated with image
		return APC_Image_Get(idx,"ID")
	end function
	
	sub ID(assigns value as string)
		APC_Image_Set(idx,"ID",value)
	end sub
	
	function RA() as double
		//- RA of the centre of the associated image
		return CDbl(APC_Image_Get(idx,"RACentre"))
	end function
	
	sub RA(assigns value as double)
		APC_Image_Set(idx,"RACentre",format(value,"-0.000000"))
	end sub
	
	function Dec() as double
		//- Dec of the centre of the associated image
		return CDbl(APC_Image_Get(idx,"DecCentre"))
	end function
	
	sub Dec(assigns value as double)
		APC_Image_Set(idx,"DecCentre",format(value,"-0.000000"))
	end sub
	
	function XSize() as double
		//- X-direction size in degrees of the associated image
		//- NOTE: Currently this MUST be the same as YSize.
		//- Is 0.0 for images with an unknown size
		return CDbl(APC_Image_Get(idx,"XSize"))
	end function
	
	sub XSize(assigns value as double)
		APC_Image_Set(idx,"XSize",format(value,"-0.000000"))
	end sub
	
	function YSize() as double
		//- Y-direction size in degrees of the associated image
		//- NOTE: Currently this MUST be the same as XSize.
		//- Is 0.0 for images with an unknown size
		return CDbl(APC_Image_Get(idx,"YSize"))
	end function
	
	sub YSize(assigns value as double)
		APC_Image_Set(idx,"YSize",format(value,"-0.000000"))
	end sub
	
	function IsApproximate() as boolean
		//- True if the associated RA/Dec of the image centre is an approximation (typically to within a few arcmin)
		return StrToBoolean(APC_Image_Get(idx,"ApproxCentre"))
	end function
	
	sub IsApproximate(assigns value as boolean)
		APC_Image_Set(idx,"ApproxCentre",BooleanToStr(value))
	end sub
	
	function IsBlackOnWhite() as boolean
		//- True if the associated image is inverted (black stars on white background)
		return StrToBoolean(APC_Image_Get(idx,"BonW"))
	end function
	
	sub IsBlackOnWhite(assigns value as boolean)
		APC_Image_Set(idx,"BonW",BooleanToStr(value))
	end sub
	
	function IsUser() as boolean
		//- True if the associated image is a user image (as opposed to a DSS/SDSS dowloaded image)
		return StrToBoolean(APC_Image_Get(idx,"User"))
	end function
	
	sub IsUser(assigns value as boolean)
		APC_Image_Set(idx,"User",BooleanToStr(value))
	end sub
	
	function IsSolarSystem() as boolean
		//- True if the associated image is an image of a solar system object (i.e. moving)
		return StrToBoolean(APC_Image_Get(idx,"SolarSystem"))
	end function
	
	sub IsSolarSystem(assigns value as boolean)
		APC_Image_Set(idx,"SolarSystem",BooleanToStr(value))
	end sub
	
	function IsColor() as boolean
		//- True if the associated image is a colour image
		return StrToBoolean(APC_Image_Get(idx,"Colour"))
	end function
	
	sub IsColor(assigns value as boolean)
		APC_Image_Set(idx,"Colour",BooleanToStr(value))
	end sub
	
	function Source() as string
		//- Source data set of the associated image. "User" for user-supplied images.
		//- WARNING: Reading this property causes a database disk access.
		return APC_Image_Get(idx,"Source")
	end function
	
	sub Source(assigns value as string)
		APC_Image_Set(idx,"Source",value)
	end sub
	
	function Type() as string
		//- Type of the image within the database.
		//- NOTE: Currently this is ALWAYS "jpg".
		//- WARNING: Reading this property causes a database disk access.
		return APC_Image_Get(idx,"Type")
	end function
	
	sub Type(assigns value as string)
		APC_Image_Set(idx,"Type",value)
	end sub
	
	function Other() as string
		//- Other IDs and names associated with the image (comma-separated)
		//- WARNING: Reading this property causes a database disk access.
		return APC_Image_Get(idx,"Other")
	end function
	
	sub Other(assigns value as string)
		APC_Image_Set(idx,"Other",value)
	end sub
	
	function Origin() as string
		//- File path to the original image file, where applicable
		//- WARNING: Reading this property causes a database disk access.
		return APC_Image_Get(idx,"Origin")
	end function
	
	sub Origin(assigns value as string)
		APC_Image_Set(idx,"Origin",value)
	end sub
	
	function Description() as string
		//- Description associated with user images
		//- WARNING: Reading this property causes a database disk access.
		return APC_Image_Get(idx,"Description")
	end function
	
	sub Description(assigns value as string)
		APC_Image_Set(idx,"Description",value)
	end sub
	
	function ObjectName() as string // private
		return ID+": "+Source+" ("+ format(round(XSize*60.0),"0")+"'x"+format(round(YSize*60.0),"0")+"')"
	end function
	
	function IsFlippedHorizontally() as boolean
		//- True if image is flipped horizontally from normal
		//- WARNING: Reading this property causes a database disk access.
		return StrToBoolean(APC_Image_Get(idx,"FlipH"))
	end function
	
	sub IsFlippedHorizontally(assigns value as boolean)
		APC_Image_Set(idx,"FlipH",BooleanToStr(value))
	end sub
	
	function IsFlippedVertically() as boolean
		//- True if image is flipped vertically from normal
		//- WARNING: Reading this property causes a database disk access.
		return StrToBoolean(APC_Image_Get(idx,"FlipV"))
	end function
	
	sub IsFlippedVertically(assigns value as boolean)
		APC_Image_Set(idx,"FlipV",BooleanToStr(value))
	end sub
	
	sub Delete()
		//- Deletes the image from the database.
		//- NOTE: This only happens after the script ends. You can continue to access and use the image database until then.
		APC_Image_Delete(idx)
	end sub
	
	function Save(optional path as string = "") as boolean
		//- Save the image to disk
		//- path is the file path of the file to save the image to.
		//- If path is blank (the default), then the user will be asked for the file path and image file type.
		//- The extension on the file name in the path will be used to determine the file type. This should be
		//- .jpeg, .jpg, or .png (other extensions will cause no image to be saved).
		//- If a file of the same name already exists, then it will be overwritten.
		//- TRUE is returned if the image was saved, FALSE otherwise.
		return APC_Image_Save(idx,path)
	end function
	  
	// Shared methods
	
	shared function Count() as integer
		//- Total number of images in database
		return APC_Image_Count
	end function
	
	shared function Get(n as integer) as Image
		//- Retrieve the n-th image from the database (n = 1...Count)
		if n<>cachedImgIdx then
			cachedImgIdx=n
			if n>0 and n<=APC_Image_Count then
				cachedImg = new Image(n)
			else
				cachedImg = nil
			end if
		end if
		return cachedImg
	end function
	
	shared sub CancelDeletions()
		//- Cancel any deletions scheduled by Image.Delete.
		APC_Image_CancelDelete
	end sub
	
	shared function Images( ) as Image()
  	//- Return an array of all images
  	dim p(-1) as Image
  	for i as integer = 1 to Count
  		p.Append Get(i)
  	next
  	return p
  end function
  
	shared function Choose(optional multiple as boolean = false) as Image()
		//- Use a dialog to select one or more open plan documents from a list of all open plans.
		//- If multiple is true, allow selecting zero or more plans.
		//- If multiple is false, allow selection of a single plan.
		//- If the Cancel button is used (or the dialog closed), or no plan is selected, 
		//- then an empty array is returned.

		dim rlist() as Image = Image.Images
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,"Image")
		dim result() as Image
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = Image(r(i))
		next
		return result
	end function

	
end class

//------------------------------------------------------------------------------------
class GnomicTransform
	// Documented 7/3/2012
	//- This class transforms RA/Dec coordinates to/from X/Y coordinates on a flat plane using the gnomic transformation.
	//- It can be used to construct small charts.
	private dim ra0 as double
	private dim dec0 as double
	private dim r0 as double
	private dim fliph as boolean
	private dim flipv as boolean
	private dim scaling as double
	private dim cwidth as integer
	private dim cheight as integer
		
	sub Constructor(raCentre as double, decCentre as double, radius as double, optional flipHorizontal as boolean = false, optional flipVertical as boolean = false)
		//- Create a transform for a chart centred at raCentre/decCentre with a given radius.
		//- raCentre is in hours (0<= raCentre <24).
		//- decCentre is in degrees (-90<= decCentre <=90).
		//- radius is in degrees (0< radius <60)
		//- Use the flipHorizontal/flipVertical flags to change the sense of ra/dec.
		ra0=raCentre*HoursToRadians
		dec0=decCentre*DegreesToRadians
		r0=radius*DegreesToRadians
		
		fliph=flipHorizontal
		flipv=flipVertical
		
		scaling=1.0
		dim x,y as double
		RADectoXY(raCentre,decCentre+radius,x,y)
		scaling=1.0/abs(y)
		
		cwidth=100
		cheight=100
	end sub
	
	sub RADecToXY(ra as double, dec as double, byref X as double, byref Y as double)
		//- Map the given RA/Dec (in hours/degrees) to X/Y coordinates.
		//- X/Y are in the range -1 to +1, with 0/0 in the middle of the chart. 
		//- X = -1 on the far left, i.e. radius degrees to the left of centre.
		//- X = +1 on the far right, i.e. radius degrees to the right of centre.
		//- Y = -1 on the top, i.e. radius degrees above centre.
		//- Y = +1 on the bottom, i.e. radius degrees below centre.
		dim den,r,d as double
		
		r=ra*HoursToRadians
		d=dec*DegreesToRadians
		
		den=cos(dec0)*cos(d)*cos(r-ra0)+sin(dec0)*sin(d)
		x=(cos(d)*sin(r-ra0))/den
		y=(sin(dec0)*cos(d)*cos(r-ra0)-cos(dec0)*sin(d))/den
		
		if fliph then x=-x
		if flipv then y=-y
		
		x=-x*scaling
		y=y*scaling
	end sub
	
	sub XYToRADec(X as double, Y as double, byref ra as double, byref dec as double)
		//- Map the given X/Y coordinates to RA/Dec (in hours/degrees)
		//- X/Y are in the range -1 to +1, with 0/0 in the middle of the chart. 
		//- X = -1 on the far left, i.e. radius degrees to the left of centre.
		//- X = +1 on the far right, i.e. radius degrees to the right of centre.
		//- Y = -1 on the top, i.e. radius degrees above centre.
		//- Y = +1 on the bottom, i.e. radius degrees below centre.
		dim xx,yy as double
		
		xx=x
		yy=y
		if fliph then xx=-xx
		if flipv then yy=-yy
		
		ra=ra0+ATan2(-xx,(cos(dec0)-yy*sin(dec0)))*RadiansToHours
		dec=asin((sin(dec0)+yy*cos(dec0))/sqrt(1.0+xx*xx+yy*yy))*RadiansToDegrees
	end sub
	
	sub CanvasSize(width as integer, height as integer)
		//- Set the width and height (in pixels) of your canvas.
		//- Required by the RADectoPixels and PixelstoRADec methods.
		cwidth=width
		cheight=height
	end sub
	
	sub RADecToPixels(ra as double, dec as double, byref x as integer, byref y as integer)
		//- Map the given RA/Dec (in hours/degrees) to x/y coordinates as pixel values on a canvas.
		//- The CanvasSize method must be called prior to the first call to this method.
		dim xx,yy as double
		RADecToXY(ra,dec,xx,yy)
		if cwidth>=cheight then
			x=round((cwidth+xx*cheight)*0.5)
			y=round((yy+1.0)*cheight*0.5)
		else
			x=round((xx+1.0)*cwidth*0.5)
			y=round((cheight+xx*cwidth)*0.5)
		end if
	end sub
	
	sub PixelsToRADec(x as integer, y as integer, byref ra as double, byref dec as double)
		//- Map the given x/y coordinates as pixel values on a canvas to RA/Dec (in hours/degrees).
		//- The CanvasSize method must be called prior to the first call to this method.
		dim xx,yy as double
		if cwidth>=cheight then
			xx=(x/cwidth*2.0-1.0)*cheight/cwidth
			yy=y/cheight*2.0-1.0
		else
			xx=x/cwidth*2.0-1.0
			yy=(y/cheight*2.0-1.0)*cwidth/cheight
		end if
		XYtoRADec(xx,yy,ra,dec)
	end sub
	
end class

//------------------------------------------------------------------------------------
class Random
	// Documented 7/3/2012
	//- Generate random numbers
	//- e.g.
	//-   dim r as new Random
	//-   r.Seed = 0.987659
	//-   dim dicethrow as integer = r.InRange(1,6)
	//- Instantiation: dim r as new Random
	
	private dim idx as integer
	
	sub Constructor()
		idx=APC_Random_New
	end sub
	
	sub Destructor() // private
		APC_Random_Destroy(idx)
	end sub
	
	sub Seed(assigns v as double)
		//- Gets or sets the seed used by the random number generator.
		//- Use the Seed to initialize the pseudo-random number generator's 
		//- algorithm so that you can always get the same stream of numbers from the same seed.
		APC_Random_SetSeed(idx,v)
	end sub
	
	function Seed() as double
		return APC_Random_GetSeed(idx)
	end function
	
	function Gaussian( ) as double
		//- Returns a random number drawn from a Gaussian (a.k.a. Normal) 
		//- distribution rather than from a uniform distribution.
		//- The Gaussian distribution has a mean of zero and a standard deviation of 1.
		return APC_Random_Gaussian(idx)
	end function
	
	function InRange(minR as integer, maxR as integer) as integer
		//- Returns a random number as an Integer in the range from minR to maxR, inclusive.
		return APC_Random_InRange(idx,minR,maxR)
	end function
	
	function LessThan(Range as integer) as integer
		//- Returns a random number as an Integer in the range greater 
		//- than or equal to 0 and less or equal to Range-1.
		return APC_Random_LessThan(idx,Range)
	end function
	
	function Number( ) as double
		//- Returns a random number as a Double in the range greater than or equal to 0 and less than 1.
		return APC_Random_Number(idx)
	end function
	
end class

//------------------------------------------------------------------------------------
class Collection
	// Documented 7/3/2012
	//- Used to store a set of related items in a larger structure. 
	//- The concept of a collection is similar to that of an array, 
	//- except that each element in a collection can be a different data type. 
	//- A collection can be thought of as an array of variants. 
	//- Also, each element in a collection can be named with an optional key. 
	//- Elements in a collection can be referred to either by number or name/key.
	//- Instantiation: dim c as new Collection
	
	private dim c_items(-1) as Variant
	private dim c_keys(-1) as string
	
	sub Add(value as Variant, optional Key as string = "")
		//- Add an entry to the end of the collection
		c_items.Append value
		c_keys.Append Key
	end sub
	
	function Count() as integer
		//- Return the number of entries in the collection
		return c_items.UBound+1
	end function
	
	function Item(index as integer) as Variant
		//- Return the item at the given index (0...Count-1)
		if index>=0 and index<=c_items.Ubound then return c_items(index) else return nil
	end function
	
	function Item(key as string) as Variant
		//- Return the (first) item with the given key
		if key="" then return nil else return Item(c_keys.IndexOf(key))
	end function
	
	sub Remove(index as integer)
		//- Remove the item at the given index (0...Count-1)
		if index>=0 and index<=c_items.Ubound then 
			c_items.Remove(index)
			c_keys.Remove(index)
		end if
	end sub
	
	sub Remove(key as string)
		//- Remove the (first) item with the given key
		if key="" then return else Remove(c_keys.IndexOf(key))
	end sub
	
	sub Clear()
		//- Remove all items from the collection
		redim c_items(-1)
		redim c_keys(-1)
	end sub
	
end class

//------------------------------------------------------------------------------------
class Set
	// Documented 7/3/2012
	inherits Collection
	//- A Set is a Collection that only holds one copy of a given item. i.e. if you attempt
	//- to add an item that already exists in the Set, it will be ignored. 
	//- Note that if you add objects then equality will be based solely on the references, 
	//- unless the objects implement the Operator_Compare method (e.g. the Date class).
	//- Note, also, that the Set class assumes you are storing only items of the _same_ type/class,
	//- otherwise an exception might occur when adding new items (since they need to be compared).
	//- Instantiation: dim c as new Set
	
	sub Add(value as Variant, optional Key as string = "")
		//- Add an entry to the set. If value already exists in the Set, it is ignored.
		for i as integer = 0 to Count-1
			if Item(i)=value then return
		next
		super.Add(value,Key)
	end sub
	
end class

//------------------------------------------------------------------------------------
module StringUtilities
	// Documented 7/3/2012
	//- Various string extensions for convenience
	
	Function Chop(extends s As String, charsToCut As Integer) As String
		//- Return s with the rightmost 'charsToCut' chars removed.
		Dim charsLeft As Integer = s.Len - charsToCut
		if charsLeft <= 0 then return ""
		return s.Left( s.Len - charsToCut )
	End Function
	
	Function Chop(extends s As String, stringToCut As String) As String
		//- Chops 'stringToCut' off of s, if stringToCut is found at the end.
		//- Useful for removing file extensions, trailing punctuation, etc.
		Dim cutLen As Integer = stringToCut.Len
		if Right(s, cutLen) = stringToCut then
			return s.Left( s.Len - cutLen )
		else
			return s
		end if
	End Function
	
	Function ChopB(extends s As String, bytesToCut As Integer) As String
		//- Return s with the rightmost 'bytesToCut' bytes removed.
		Dim bytesLeft As Integer = s.LenB - bytesToCut
		if bytesLeft <= 0 then return ""
		return s.LeftB( s.LenB - bytesToCut )
	End Function
	
	Function ChopB(extends s As String, stringToCut As String) As String
		//- Chops 'stringToCut' off of s, if stringToCut is found at the end.
		//- Useful for removing file extensions, trailing punctuation, etc.
		Dim cutLenB As Integer = stringToCut.LenB
		if StrComp( RightB(s, cutLenB), stringToCut, 0 ) = 0 then
			return s.LeftB( s.LenB - cutLenB )
		else
			return s
		end if
	End Function
	
	Function Contains(extends s As String, what As String) As Boolean
		//- Return true if 's' contains the substring 'what'.
		//- By "contains" we mean case-insensitive, encoding-savvy containment
		//- as with InStr.
		if what = "" then return true
		return InStr( s, what ) > 0
	End Function
	
	Function ContainsB(extends s As String, what As String) As Boolean
		//- Return true if 's' contains the substring 'what'.
		//- By "contains" we mean binary containment
		//- as with InStrB.
		if what = "" then return true
		return InStrB( s, what ) > 0
	End Function
	
	Function EndsWith(extends s As String, withWhat As String) As Boolean
		//- Return true if 's' ends with the string 'withWhat',
		//- doing a standard string comparison.
		return Right(s, withWhat.Len) = withWhat
	End Function
	
	Function EndsWithB(extends s As String, withWhat As String) As Boolean
		//- Return true if 's' ends with the string 'withWhat',
		//- doing a binary comparison.
		return StrComp( RightB(s, withWhat.LenB), withWhat, 0 ) = 0
	End Function
	
	Function JoinInt(source() As Integer, optional delimiter As String = " ") As string
		//- Join an array of integers together with the given delimiter
		Dim fields(-1) As String
		redim fields(ubound(source))
		for i as integer = 0 to ubound(source)
			fields(i)=format(source(i),"-0")
		next
		return Join(fields,delimiter)
	End Function
	
	Function JoinQuoted(fields() as String, delimiter as String) As String
		//- Join the given strings with a delimiter, just like the intrinsic Join
		//- method, except that if any of the fields contains the delimiter,
		//- that item will be surrounded by quotes in the output.  See
		//- SplitQuoted for the inverse function.
		Dim quoted() As String
		Dim ub As Integer = UBound( fields )
		Redim quoted( ub )
		for i As Integer = 0 to ub
			Dim fld As String = fields(i)
			if Instr( fld, Delimiter ) > 0 then
				quoted(i) = """" + fld + """"
			else
				quoted(i) = fld
			end if
		next
		return Join( quoted, delimiter )
	End Function
	
	Function InStrQuoted(optional start As Integer = 1, source As String, find As String) As Integer
	  //- This is the same as the built-in InStr function, except that it ignores
	  //- any occurrence of "find" within double quotes.
  
  
	  do
	    // Find the next occurrence of the search string.  If none, then we're done.
	    Dim foundPos As Integer = InStr( start, source, find )
	    if foundPos < 1 then return foundPos
    
	    // Now, also find the next quotation mark; if this comes before
	    // our foundPos, then we need to ignore that and resume searching
	    // after the closing quote.  Otherwise, we're done.
	    Dim quotePos As Integer = InStr( start, source, """" )
	    if quotePos = 0 or quotePos > foundPos then return foundPos
    
	    Dim closeQuotePos As Integer = InStr( quotePos+1, source, """" )
	    if closeQuotePos = 0 then return 0 // no closing quote, treat whole end of string as quoted
    
	    start = closeQuotePos + 1
	  loop
  
	End Function

	Function SplitQuoted(source As String, delimiter As String, removeQuotes as Boolean) As String()
		//- Same as Split, except that it respects quoted strings.
		
		Dim out() As String
		
		// Easy cases: no occurrences of the separator, or no quotation marks
		if InStr( source, delimiter )=0 then
			out = Array( source )
		elseif InStr( source, """" )= 0 then
			out = Split( source, delimiter )
		else
			// Harder case: both separator and quotation marks.
			// We'll use InStrQuoted to help us out.
			Dim delimiterLen As Integer = delimiter.Len
			Dim startPos As Integer = 1
			do
				Dim delimiterPos As Integer = InStrQuoted( startPos, source, delimiter )
				if delimiterPos = 0 then
					// no more separators
					out.Append Mid( source, startPos )
					exit
				end if
				out.Append Mid( source, startPos, delimiterPos - startPos )
				startPos = delimiterPos + delimiterLen
			loop
		end if
		
		// Finally, strip quotes if asked to do so.
		// (Including the case of a start quote without an end quote, which
		// could happen in the last field.)
		if removeQuotes then
			for i As Integer = 0 to UBound( out )
				Dim s As String = out(i)
				if s.LeftB( 1 ) = """" then
					if s.RightB( 1 ) = """" then
						out(i) = MidB( s, 2, s.LenB - 2 )
					else
						out(i) = MidB( s, 2 )
					end if
				end if
			next
		end if
		
		return out
		
	End Function
	
	Function SplitToInt(source As String, optional delimiter As String=" ") As Integer()
		//- Split a string into fields, then convert each field into an Integer
		//- using the Val function.
		
		Dim fields(-1) As String
		fields = source.Split(delimiter)
		
		Dim out(-1) As Integer
		Redim out( UBound(fields) )
		
		Dim i As Integer
		for i = UBound(fields) DownTo 0
			out(i) = Val( fields(i) )
		next
		
		return out
		
	End Function
	
	Function StartsWith(extends s As String, withWhat As String) As Boolean
		//- Return true if 's' starts with the string 'withWhat',
		//- doing a standard string comparison.
		
		return Left(s, withWhat.Len) = withWhat
		
	End Function
	
	Function StartsWithB(extends s As String, withWhat As String) As Boolean
		//- Return true if 's' starts with the string 'withWhat',
		//- doing a binary comparison.
		
		return StrComp( LeftB(s, withWhat.Len), withWhat, 0 ) = 0
		
	End Function
	
end module

//------------------------------------------------------------------------------------
class Constellation
	// Documented 7/2/2012
	//- A class to retrieve constellation information: names, abbreviations, bounds, visibility, etc.
	//- Instantiation: DO NOT create instances yourself. Use the GetConstellation shared methods to do so.
	implements NamedObject
	
	private dim v_Idx as integer
	private dim v_Name as string
	private dim v_Abbr as string
	private dim v_RAFrom as double
	private dim v_DecFrom as double
	private dim v_RATo as double
	private dim v_DecTo as double
	
	private sub Constructor(n as integer)
		v_Idx = n
		v_Name = APC_Constellation(n,1)
		v_Abbr = APC_Constellation(n,2)
	end sub
	
	function ObjectName() as string // private
		return Name
	end function
	
	function Name() as string
		//- Name of constellation, e.g. Ursa Major
		return v_Name
	end function
	
	function Abbreviation() as string
		//- Abbreviation of constellation, e.g. UMa
		return v_Abbr
	end function
	
	function Description() as string
		//- Description of constellation (abbreviation + Name), e.g. UMa - Ursa Major
		return v_Abbr+" - "+v_Name
	end function
	
	function Genitive() as string
		//- Genitive form of constellation name, e.g. Ursae Majoris
		return APC_Constellation(v_Idx,3)
	end function
	
	function RAFrom() as double
		//- Minimum RA along constellation bounds
		if v_RAFrom=0.0 and v_DecFrom=0.0 then APC_ConstellationBounds(v_Idx,v_RAFrom,v_RATo,v_DecFrom,v_DecTo)
		return v_RAFrom
	end function
	
	function DecFrom() as double
		//- Minimum Dec along constellation bounds
		if v_RAFrom=0.0 and v_DecFrom=0.0 then APC_ConstellationBounds(v_Idx,v_RAFrom,v_RATo,v_DecFrom,v_DecTo)
		return v_DecFrom
	end function
	
	function RATo() as double
		//- Maximum RA along constellation bounds
		if v_RAFrom=0.0 and v_DecFrom=0.0 then APC_ConstellationBounds(v_Idx,v_RAFrom,v_RATo,v_DecFrom,v_DecTo)
		return v_RATo
	end function
	
	function DecTo() as double
		//- Maximum Dec along constellation bounds
		if v_RAFrom=0.0 and v_DecFrom=0.0 then APC_ConstellationBounds(v_Idx,v_RAFrom,v_RATo,v_DecFrom,v_DecTo)
		return v_DecTo
	end function
	
	function Contains(ra as double, dec as double) as boolean
		//- Return TRUE if constellation contains given coordinates
		return v_Abbr=APC_ConstellationFind(ra,dec)
	end function
	
	function IsFigureStar(ra as double, dec as double) as boolean
		//- Return TRUE if the star at the given coordinates is a star that forms part of the constellation stick figure
		return Contains(ra,dec) and APC_ConstellationFigureStar(ra,dec)
	end function
	
	function IsFigureStar(star as RADecObject) as boolean
		//- Return TRUE if the star object is a star that forms part of the constellation stick figure
		return IsFigureStar(star.RA,star.Dec)
	end function
	
	function CanSeeAtSite(site as SiteResource, optional jdate as double = 0.0, optional altitude as double = 0.0) as integer
		//- Return 0 if the constellation can never be seen at the given site.
		//- Return 1 if the constellation can be partially seen at the given site.
		//- Return 2 if the constellation can be seen in its entirety at the given site.
		//- If jdate = 0.0 then return result if true for some date/time during the year, otherwise
		//- if jdate > 0.0 then return result for the given jdate only.
		//- The altitude parameter specifies the altitude above the (theoretical) horizon that the
		//- constellation must rise in order to be considered partially or fully visible.
		return APC_ConstellationAtSite(v_Idx,site.Latitude,site.Longitude,site.GMTOffset, jdate, altitude)
	end function
	
	shared function Count() as integer
		//- Return number of constellations
		return 88
	end function
	
	shared function GetConstellation(n as integer) as Constellation
		//- Return constellation object (n = 0, 1, ... Count-1)
		return new Constellation(n)
	end function
	
	shared function GetConstellation(NameOrAbbrev as string) as Constellation
		//- Return constellation object by name or abbreviation
		for i as integer = 0 to 87
			dim c as new Constellation(i)
			if c.Abbreviation=NameOrAbbrev or c.Name=NameOrAbbrev then return c
		next
		return nil
	end function
	
	shared function GetConstellation(ra as double, dec as double) as Constellation
		//- Return constellation object by RA/Dec coordinate
		return GetConstellation(APC_ConstellationFind(ra,dec))
	end function
	
	shared function Descriptions() as string()
		//- Return an array of strings containing "abbreviation - full Name" for each constellation
		dim i as integer
		dim s(-1) as string
		for i=0 to 87
			s.Append GetConstellation(i).Description
		next
		return s
	end function
	
	shared function Names() as string()
		//- Return an array of strings containing the full names of the constellations
		dim i as integer
		dim s(-1) as string
		for i=0 to 87
			s.Append GetConstellation(i).Name
		next
		return s
	end function

	shared function Abbreviations() as string()
		//- Return an array of strings containing the 3-letter abbreviations of the constellations
		dim i as integer
		dim s(-1) as string
		for i=0 to 87
			s.Append GetConstellation(i).Abbreviation
		next
		return s
	end function
	
  shared function Constellations( ) as Constellation()
  	//- Return an array of constellations
  	dim p(-1) as Constellation
  	for i as integer = 0 to Count-1
  		p.Append GetConstellation(i)
  	next
  	return p
  end function
  
	shared function Choose(optional multiple as boolean = false) as Constellation()
		//- Use a dialog to select one or more Constellations from a list of all constellations.
		//- If multiple is true, allow selecting zero or more constellations.
		//- If multiple is false, allow selection of a single constellations.
		//- If the Cancel button is used (or the dialog closed), or no constellation is selected, 
		//- then an empty array is returned.
	
		dim rlist() as Constellation = Constellation.Constellations
		dim r() as NamedObject = Dialog.Choose(multiple,rlist,"Constellation")
		dim result() as Constellation
		redim result(r.Ubound)
		for i as integer = 0 to r.Ubound
			result(i) = Constellation(r(i))
		next
		return result
	end function


end class

//------------------------------------------------------------------------------------
class Web
	// Documented 7/2/2012
	//- A class to perform various functions via an Internet connection.
	//- Instantiation: DO NOT create an instance of this class. Just use the shared methods.
  
  
  shared function HTTPGet(url as string, optional timeout as integer = 10) as string
  	
  	//- Retrieve the web page at url (using GET) and return it as a string. 
  	//- Timeout is in seconds (default = 10), after which the function returns "" if
  	//- the URL cannot be accessed.
  	//; dim page as string = Web.HTTPGet("http://www.astroplanner.net/")
  	//; if page<>"" then // process the HTML page in page
  	return APC_Web_HTTPGet(url,timeout)
  end function
  
  shared function HTTPGet(url as string, path as string, optional timeout as integer = 10) as boolean
  	
  	//- Retrieve the file at url (using GET), and store it as the given file path.
  	//- Return true if successful.
  	//- Timeout is in seconds (default = 10), after which the function returns file if
  	//- the URL cannot be accessed.
  	//; if Web.HTTPGet("http://www.astroplanner.net/",APFile.SpecialFolder(APFile.folder_Desktop,"page.html"),5) then
  	//;   // Process the file "page.html" on the desktop, which should contain the contents of http://www.astroplanner.net
  	//; end if
  	return APC_Web_HTTPGet(url,path,timeout)
  end function
  
  shared function HTTPPost(url as string, formData as Dictionary, optional timeout as integer = 10) as string
  	
  	//- Retrieve the web page at url (using POST) and return it as a string. 
  	//- Timeout is in seconds (default = 10), after which the function returns "" if
  	//- the URL cannot be accessed.
  	// formData contains any form parameters to be passed (keys) together with their corresponding string values.
  	// If there are no form parameters, you can set formData to nil.
  	//; dim form as new Dictionary
  	//; form.Value("tolerance") = "low"
  	//; dim page as string = Web.HTTPPost("http://www.debug.com/",form,4)
  	//; if page<>"" then // process the HTML results in page
  	dim keys(-1),data(-1) as string
  	if formData<>nil then
  		for i as integer = 0 to formData.Count-1
  			dim k as string = formData.Key(i)
  			keys.Append k
  			data.Append formData.Value(k)
  		next
  	end if
  	return APC_Web_HTTPPost(url,keys,data,timeout)
  end function
  
  shared function HTTPPost(url as string, formData as Dictionary, path as string, optional timeout as integer = 10) as boolean
  	//- Retrieve the file at url (using POST), and store it as the given file path.
  	//- Return true if successful.
  	//- Timeout is in seconds (default = 10), after which the function returns file if
  	//- the URL cannot be accessed.
  	// formData contains any form parameters to be passed (keys) together with their corresponding string values.
  	// If there are no form parameters, you can set formData to nil.
  	//; dim form as new Dictionary
  	//; form.Value("tolerance") = "low"
  	//; if Web.HTTPPost("http://www.debug.com/",APFile.SpecialFolder(APFile.folder_Desktop,"page.html"),6) then
  	//;   // Process the file "page.html" on the desktop, which should contain the contents of the POST action
  	//; end if
  	dim keys(-1),data(-1) as string
  	if formData<>nil then
  		for i as integer = 0 to formData.Count-1
  			dim k as string = formData.Key(i)
  			keys.Append k
  			data.Append formData.Value(k)
  		next
  	end if
  	return APC_Web_HTTPPost(url,keys,data,path,timeout)
  end function
  
  shared function HTMLTableCount(source as string) as integer
  	//- Retrieve the number of HTML tables ( <table>...</table> ) in the given source
  	return CountFields(source,"<table")-1
  end function
  
  shared function ExtractItems(source as string, tags() as string) as string() // private
  	dim items() as string
  	dim src as string = source
  	while true
  		dim tag as string
  		dim idx as integer = 0
  		for i as integer = 0 to tags.Ubound
  			dim j as integer = src.instr("<"+tags(i))
  			if j>0 then
  				if idx=0 or j<idx then
  					idx = j
  					tag = tags(i)
  				end if
  			end if
  		next
  		if idx<=0 then return items
  		src = src.mid(idx)
  		idx = src.instr("</"+tag+">")
  		if idx<=0 then idx = len(src)-(tag.len+2)
  		dim s as string = src.left(idx+tag.len+2)
  		s = NthField(s,"</"+tag+">",1).trim
  		dim i as integer = s.instr(">")
  		if i>0 then s = s.mid(i+1).trim
  		items.Append s
  		src = src.mid(idx+tag.len+3)
  	wend
  end function
  
  shared function HTMLTable(source as string, n as integer) as string(,)
  	//- Retrieve the n-th table (n = 1, 2, ... TableCount) from the given HTML source.
  	//- The returned result is a 2D array containing the table cell contents (including HTML code).
  	dim cells(-1,-1) as string
  	if n<1 or n>HTMLTableCount(source) then return cells
  	dim tbls() as string = ExtractItems(source,array("table"))
  	dim tbl as string = tbls(n-1)
  	dim rows() as string = ExtractItems(tbl,array("tr"))
  	redim cells(rows.Ubound,-1)
  	for row as integer = 0 to rows.Ubound
  		dim cols() as string = ExtractItems(rows(row),array("td"))
  		if cols.Ubound>Ubound(cells,2) then 
  			redim cells(Ubound(cells,1),cols.Ubound)
  		end if
  		for col as integer = 0 to cols.Ubound
  			cells(row,col) = cols(col)
  		next
  	next
  	return cells
  end function
  
end class

//------------------------------------------------------------------------------------
class Excel
	// Documented 1/20/2013
	//- A class to export an Excel file.
	//- Instantiation: dim ex as new Excel(path)
	
	private nExcelID as integer
	
	sub Constructor(path as string)
		//- Create an empty Excel worksheet file.
		//- If path is "" then prompt the user for the file path, otherwise use the given path and file name.
		nExcelID = APC_Excel_Open(path)
	end sub
	
	sub Destructor() // Private
		Close()
	end sub
	
	sub Close()
		//- Close the Excel file.
		APC_Excel_Close(nExcelID)
		nExcelID = 0
	end sub
	
	sub Heading(s as string, row as integer, column as integer)
		//- Populate the cell at the given (row,column) with the given heading string.
		//- The cell will be displayed in bold face.
		APC_Excel_Heading(nExcelID,s,row,column)
	end sub
	
	sub Heading(s() as string, row as integer, optional startColumn as integer = 1)
		//- Populate a row of cells with heading strings in the array s,
		//- starting at the given startColumn in the specified row.
		for col as integer = 0 to s.UBound
			me.Heading(s(col),row,startColumn+col)
		next
	end sub
	
	sub Data(v as Variant, row as integer, column as integer)
		//- Populate the cell at the given (row,column) with the given data, v.
		//- v can be any common "scalar" data type, e.g. double, integer, string, boolean.
		dim s as string
		select case v.Type
		case vtype_Integer, vtype_Long  // Integer
			 s = format(v.IntegerValue,"-0")
		case vtype_Single, vType_Double  // Double
			 s = DoubleToStr(v.DoubleValue,-6)
		case vtype_Boolean   // Boolean
			 if v.BooleanValue then s="1" else s="0"
		else    // String, etc.
			 s = v.StringValue
		end select
		APC_Excel_Data(nExcelID,s,row,column)
	end sub
	
	sub Data(s() as string, row as integer, optional startColumn as integer = 1)
		//- Populate a row of cells with data strings in the array s,
		//- starting at the given startColumn in the specified row.
		for col as integer = 0 to s.UBound
			me.Data(s(col),row,startColumn+col)
		next
	end sub
	
	sub Data(n() as integer, row as integer, optional startColumn as integer = 1)
		//- Populate a row of cells with integer data values in the array n,
		//- starting at the given startColumn in the specified row.
		for col as integer = 0 to n.UBound
			me.Data(n(col),row,startColumn+col)
		next
	end sub
	
	sub Data(r() as double, row as integer, optional startColumn as integer = 1)
		//- Populate a row of cells with double data values in the array r,
		//- starting at the given startColumn in the specified row.
		for col as integer = 0 to r.UBound
			me.Data(r(col),row,startColumn+col)
		next
	end sub
	
	sub Data(v() as Variant, row as integer, optional startColumn as integer = 1)
		//- Populate a row of cells with data values in the array v,
		//- starting at the given startColumn in the specified row.
		//- v can contain any common "scalar" data types, e.g. double, integer, string, boolean.
		//- Mixed data types can be used.
		for col as integer = 0 to v.UBound
			me.Data(v(col),row,startColumn+col)
		next
	end sub
	
end class

//------------------------------------------------------------------------------------
class PrinterSetup
	// Documented ???
	//- A class to get printer parameters for the currently selected printer.
	//- Instantiation: none (all access via shared functions)

  private sub Constructor()
  	// Do not allow instantiation
  end sub
  
	shared function Left() as integer
		//- The left pixel coordinate of the printable area (typically 0)
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return left
	end function
	
	shared function Top() as integer
		//- The top pixel coordinate of the printable area (typically 0)
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return top
	end function
	
	shared function Width() as integer
		//- The pixel width of the printable area
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return width
	end function
	
	shared function Height() as integer
		//- The pixel height of the printable area
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return height
	end function
	
	shared function PageLeft() as integer
		//- The left pixel coordinate of the page with respect to the printable area
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return pageleft
	end function
	
	shared function PageTop() as integer
		//- The top pixel coordinate of the page with respect to the printable area
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return pagetop
	end function
	
	shared function PageWidth() as integer
		//- The pixel width of the page
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return pagewidth
	end function
	
	shared function PageHeight() as integer
		//- The pixel height of the page
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return pageheight
	end function
	
	shared function HorizontalResolution() as integer
		//- The horizontal resolution in pixels/inch (DPI)
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return horizontalres
	end function
	
	shared function VerticalResolution() as integer
		//- The vertical resolution in pixels/inch (DPI)
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return verticalres
	end function
	
	shared function MaxHorizontalResolution() as integer
		//- The maximum horizontal resolution in pixels/inch (DPI)
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return maxhorizontalres
	end function
	
	shared function MaxVerticalResolution() as integer
		//- The maximum vertical resolution in pixels/inch (DPI)
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return maxverticalres
	end function
	
	shared function Landscape() as boolean
		//- Return TRUE if the page is in landscape mode (page is wider than it is tall), or FALSE otherwise.
		dim left as integer, top as integer, width as integer, height as integer, pageleft as integer, pagetop as integer, pagewidth as integer, pageheight as integer, horizontalres as integer, verticalres as integer, maxhorizontalres as integer, maxverticalres as integer, landscape as boolean
		APC_PrinterSetup(left, top, width, height, pageleft, pagetop, pagewidth, pageheight, horizontalres, verticalres, maxhorizontalres, maxverticalres, landscape)
		return landscape
	end function
	
end class


sub APC_Initialise() // private
	// Always called first to initialise stuff, before calling sub main()
	APResource.APResourcesInitialise
	APMinorPlanetObject.ASTORB_MPCORB_Initialise
	APCometObject.COMET_Initialise
	APC_ScriptStarting
end sub
